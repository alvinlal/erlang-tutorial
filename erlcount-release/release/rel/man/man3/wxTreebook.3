.TH wxTreebook 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxTreebook \- Functions for wxTreebook class
.SH DESCRIPTION
.LP
This class is an extension of the \fIwxNotebook\fR\& class that allows a tree structured set of pages to be shown in a control\&. A classic example is a netscape preferences dialog that shows a tree of preference sections on the left and select section page on the right\&.
.LP
To use the class simply create it and populate with pages using \fIinsertPage/5\fR\&, \fIinsertSubPage/5\fR\&, \fIaddPage/4\fR\&, \fIAddSubPage()\fR\& (not implemented in wx)\&.
.LP
If your tree is no more than 1 level in depth then you could simply use \fIaddPage/4\fR\& and \fIAddSubPage()\fR\& (not implemented in wx) to sequentially populate your tree by adding at every step a page or a subpage to the end of the tree\&.
.LP
See: ?wxBookCtrl, \fIwxBookCtrlEvent\fR\&, \fIwxNotebook\fR\&, \fIwxTreeCtrl\fR\&, \fIwxImageList\fR\&, Overview bookctrl, Examples 
.LP
This class is derived (and can use functions) from: \fIwxBookCtrlBase\fR\& \fIwxControl\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxTreebook
.SH "EVENTS"

.LP
Event types emitted from this class: \fItreebook_page_changed\fR\&, \fItreebook_page_changing\fR\&
.SH DATA TYPES
.nf

\fBwxTreebook()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxTreebook()
.br
.fi
.br
.RS
.LP
Default constructor\&.
.RE
.LP
.nf

.B
new(Parent, Id) -> wxTreebook()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Id, Options :: [Option]) -> wxTreebook()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Creates an empty \fIwxTreebook\fR\&\&.
.RE
.LP
.nf

.B
destroy(This :: wxTreebook()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the \fIwxTreebook\fR\& object\&.
.LP
Also deletes all the pages owned by the control (inserted previously into it)\&.
.RE
.LP
.nf

.B
addPage(This, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
addPage(This, Page, Text, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Option = {bSelect, boolean()} | {imageId, integer()}
.br
.RE
.RE
.RS
.LP
Adds a new page\&.
.LP
The page is placed at the topmost level after all other pages\&. NULL could be specified for page to create an empty page\&.
.RE
.LP
.nf

.B
advanceSelection(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
.RE
.RE
.LP
.nf

.B
advanceSelection(This, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Option = {forward, boolean()}
.br
.RE
.RE
.RS
.LP
Cycles through the tabs\&.
.LP
The call to this function generates the page changing events\&.
.RE
.LP
.nf

.B
assignImageList(This, ImageList) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
ImageList = wxImageList:wxImageList()
.br
.RE
.RE
.RS
.LP
Sets the image list for the page control and takes ownership of the list\&.
.LP
See: \fIwxImageList\fR\&, \fIsetImageList/2\fR\& 
.RE
.LP
.nf

.B
create(This, Parent, Id) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Id, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Creates a treebook control\&.
.LP
See \fInew/3\fR\& for the description of the parameters\&.
.RE
.LP
.nf

.B
deleteAllPages(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
.RE
.RE
.RS
.LP
Deletes all pages\&.
.RE
.LP
.nf

.B
getCurrentPage(This) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
.RE
.RE
.RS
.LP
Returns the currently selected page or NULL\&.
.RE
.LP
.nf

.B
getImageList(This) -> wxImageList:wxImageList()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
.RE
.RE
.RS
.LP
Returns the associated image list, may be NULL\&.
.LP
See: \fIwxImageList\fR\&, \fIsetImageList/2\fR\& 
.RE
.LP
.nf

.B
getPage(This, Page) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Returns the window at the given page position\&.
.RE
.LP
.nf

.B
getPageCount(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
.RE
.RE
.RS
.LP
Returns the number of pages in the control\&.
.RE
.LP
.nf

.B
getPageImage(This, NPage) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
NPage = integer()
.br
.RE
.RE
.RS
.LP
Returns the image index for the given page\&.
.RE
.LP
.nf

.B
getPageText(This, NPage) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
NPage = integer()
.br
.RE
.RE
.RS
.LP
Returns the string for the given page\&.
.RE
.LP
.nf

.B
getSelection(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
.RE
.RE
.RS
.LP
Returns the currently selected page, or \fIwxNOT_FOUND\fR\& if none was selected\&.
.LP
Note: This method may return either the previously or newly selected page when called from the EVT_TREEBOOK_PAGE_CHANGED() handler depending on the platform and so \fIwxBookCtrlEvent:getSelection/1\fR\& should be used instead in this case\&.
.RE
.LP
.nf

.B
expandNode(This, PageId) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PageId = integer()
.br
.RE
.RE
.LP
.nf

.B
expandNode(This, PageId, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PageId = integer()
.br
Option = {expand, boolean()}
.br
.RE
.RE
.RS
.LP
Expands (collapses) the \fIpageId\fR\& node\&.
.LP
Returns the previous state\&. May generate page changing events (if selected page is under the collapsed branch, then its parent is autoselected)\&.
.RE
.LP
.nf

.B
isNodeExpanded(This, PageId) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PageId = integer()
.br
.RE
.RE
.RS
.LP
Returns true if the page represented by \fIpageId\fR\& is expanded\&.
.RE
.LP
.nf

.B
hitTest(This, Pt) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = {Res :: integer(), Flags :: integer()}
.br
This = wxTreebook()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Returns the index of the tab at the specified position or \fIwxNOT_FOUND\fR\& if none\&.
.LP
If \fIflags\fR\& parameter is non-NULL, the position of the point inside the tab is returned as well\&.
.LP
Return: Returns the zero-based tab index or \fIwxNOT_FOUND\fR\& if there is no tab at the specified position\&.
.RE
.LP
.nf

.B
insertPage(This, PagePos, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PagePos = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
insertPage(This, PagePos, Page, Text, Options :: [Option]) ->
.B
              boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PagePos = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Option = {bSelect, boolean()} | {imageId, integer()}
.br
.RE
.RE
.RS
.LP
Inserts a new page just before the page indicated by \fIpagePos\fR\&\&.
.LP
The new page is placed before \fIpagePos\fR\& page and on the same level\&. NULL could be specified for page to create an empty page\&.
.RE
.LP
.nf

.B
insertSubPage(This, PagePos, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PagePos = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
insertSubPage(This, PagePos, Page, Text, Options :: [Option]) ->
.B
                 boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
PagePos = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Option = {bSelect, boolean()} | {imageId, integer()}
.br
.RE
.RE
.RS
.LP
Inserts a sub page under the specified page\&.
.LP
NULL could be specified for page to create an empty page\&.
.RE
.LP
.nf

.B
setImageList(This, ImageList) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
ImageList = wxImageList:wxImageList()
.br
.RE
.RE
.RS
.LP
Sets the image list to use\&.
.LP
It does not take ownership of the image list, you must delete it yourself\&.
.LP
See: \fIwxImageList\fR\&, \fIassignImageList/2\fR\& 
.RE
.LP
.nf

.B
setPageSize(This, Size) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Size = {W :: integer(), H :: integer()}
.br
.RE
.RE
.RS
.LP
Sets the width and height of the pages\&.
.LP
Note: This method is currently not implemented for wxGTK\&.
.RE
.LP
.nf

.B
setPageImage(This, Page, Image) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = Image = integer()
.br
.RE
.RE
.RS
.LP
Sets the image index for the given page\&.
.LP
\fIimage\fR\& is an index into the image list which was set with \fIsetImageList/2\fR\&\&.
.RE
.LP
.nf

.B
setPageText(This, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Sets the text for the given page\&.
.RE
.LP
.nf

.B
setSelection(This, Page) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Sets the selection to the given page, returning the previous selection\&.
.LP
Notice that the call to this function generates the page changing events, use the \fIchangeSelection/2\fR\& function if you don\&'t want these events to be generated\&.
.LP
See: \fIwxBookCtrlBase:getSelection/1\fR\& 
.RE
.LP
.nf

.B
changeSelection(This, Page) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTreebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Changes the selection to the given page, returning the previous selection\&.
.LP
This function behaves as \fIsetSelection/2\fR\& but does \fInot\fR\& generate the page changing events\&.
.LP
See overview_events_prog for more information\&.
.RE