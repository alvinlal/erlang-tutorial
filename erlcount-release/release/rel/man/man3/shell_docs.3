.TH shell_docs 3 "stdlib 4.3.1" "Ericsson AB" "Erlang Module Definition"
.SH NAME
shell_docs \- Functions used to render EEP-48 style documentation for a shell.
.SH DESCRIPTION
.LP
This module can be used to render function and type documentation to be printed in a shell\&. This is the module that is used to render the docs accessed through the shell through \fIc:h/1,2,3\fR\&\&. Example:
.LP
.nf

1> h(maps,new,0).

  -spec new() -> Map when Map :: #{}.

Since:
  OTP 17.0

  Returns a new empty map.

  Example:

    > maps:new().
    #{}

.fi
.LP
This module formats and renders EEP-48 documentation of the format \fIapplication/erlang+html\fR\&\&. For more information about this format see Documentation Storage in Erl_Docgen\&'s User\&'s Guide\&. It can also render any other format of "text" type, although those will be rendered as is\&.
.SH DATA TYPES
.nf

\fBdocs_v1()\fR\& = #docs_v1{}
.br
.fi
.RS
.LP
The record holding EEP-48 documentation for a module\&. You can use code:get_doc/1 to fetch this information from a module\&.
.RE
.nf

\fBconfig()\fR\& = 
.br
    #{encoding => unicode | latin1,
.br
      columns => integer() >= 1,
.br
      ansi => boolean()}
.br
.fi
.RS
.LP
The configuration of how the documentation should be rendered\&.
.RS 2
.TP 2
.B
encoding:
 Configure the encoding that should be used by the renderer for graphical details such as bullet-points\&. By default \fIshell_docs\fR\& uses the value returned by \fIio:getopts()\fR\&\&.
.TP 2
.B
ansi:
 Configure whether  ansi escape codes should be used to render graphical details such as bold and underscore\&. By default \fIshell_docs\fR\& will try to determine if the receiving shell supports ansi escape codes\&. It is possible to override the automated check by setting the kernel configuration parameter \fIshell_docs_ansi\fR\& to a \fIboolean()\fR\& value\&.
.TP 2
.B
columns:
 Configure how wide the target documentation should be rendered\&. By default \fIshell_docs\fR\& used the value returned by \fIio:columns()\fR\&\&. 
.RE
.RE
.nf

\fBchunk_element_block_type()\fR\& = 
.br
    p | \&'div\&' | br | pre | ul | ol | li | dl | dt | dd | h1 | h2 |
.br
    h3 | h4 | h5 | h6
.br
.fi
.nf

\fBchunk_element_inline_type()\fR\& = a | code | em | strong | i | b
.br
.fi
.nf

\fBchunk_element_type()\fR\& = 
.br
    chunk_element_inline_type() | chunk_element_block_type()
.br
.fi
.RS
.LP
The HTML tags allowed in \fIapplication/erlang+html\fR\&\&.
.RE
.nf

\fBchunk_element_attr()\fR\& = {atom(), unicode:chardata()}
.br
.fi
.nf

\fBchunk_element_attrs()\fR\& = [chunk_element_attr()]
.br
.fi
.nf

\fBchunk_element()\fR\& = 
.br
    {chunk_element_type(),
.br
     chunk_element_attrs(),
.br
     chunk_elements()} |
.br
    binary()
.br
.fi
.nf

\fBchunk_elements()\fR\& = [chunk_element()]
.br
.fi
.RS
.RE
.SH EXPORTS
.LP
.nf

.B
render(Module, Docs) -> unicode:chardata()
.br
.fi
.br
.nf

.B
render(Module, Docs, Config) -> unicode:chardata()
.br
.fi
.br
.nf

.B
render(Module, Function, Docs) -> Res
.br
.fi
.br
.nf

.B
render(Module, Function, Docs, Config) -> Res
.br
.fi
.br
.nf

.B
render(Module, Function, Arity, Docs) -> Res
.br
.fi
.br
.nf

.B
render(Module, Function, Arity, Docs, Config) -> Res
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Function = atom()
.br
Arity = arity()
.br
Docs = docs_v1()
.br
Config = config()
.br
Res = unicode:chardata() | {error, function_missing}
.br
.RE
.RE
.RS
.LP
Render the documentation for a module or function\&.
.RE
.LP
.nf

.B
render_type(Module, Docs) -> unicode:chardata()
.br
.fi
.br
.nf

.B
render_type(Module, Docs, Config) -> unicode:chardata()
.br
.fi
.br
.nf

.B
render_type(Module, Type, Docs) -> Res
.br
.fi
.br
.nf

.B
render_type(Module, Type, Docs, Config) -> Res
.br
.fi
.br
.nf

.B
render_type(Module, Type, Arity, Docs) -> Res
.br
.fi
.br
.nf

.B
render_type(Module, Type, Arity, Docs, Config) -> Res
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Type = atom()
.br
Arity = arity()
.br
Docs = docs_v1()
.br
Config = config()
.br
Res = unicode:chardata() | {error, type_missing}
.br
.RE
.RE
.RS
.LP
Render the documentation of a type in a module\&.
.RE
.LP
.nf

.B
render_callback(Module, Docs) -> unicode:chardata()
.br
.fi
.br
.nf

.B
render_callback(Module, Docs, Config) -> unicode:chardata()
.br
.fi
.br
.nf

.B
render_callback(Module, Callback, Docs) -> Res
.br
.fi
.br
.nf

.B
render_callback(Module, Callback, Docs, Config) -> Res
.br
.fi
.br
.nf

.B
render_callback(Module, Callback, Arity, Docs) -> Res
.br
.fi
.br
.nf

.B
render_callback(Module, Callback, Arity, Docs, Config) -> Res
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module()
.br
Callback = atom()
.br
Arity = arity()
.br
Docs = docs_v1()
.br
Config = config()
.br
Res = unicode:chardata() | {error, callback_missing}
.br
.RE
.RE
.RS
.LP
Render the documentation of a callback in a module\&.
.RE
.LP
.nf

.B
validate(Module) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Module = module() | docs_v1()
.br
.RE
.RE
.RS
.LP
This function can be used to do a basic validation of the doc content of \fIapplication/erlang+html\fR\& format\&.
.RE
.LP
.nf

.B
normalize(Docs) -> NormalizedDocs
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Docs = NormalizedDocs = chunk_elements()
.br
.RE
.RE
.RS
.LP
This function can be used to do whitespace normalization of \fIapplication/erlang+html\fR\& documentation\&.
.RE
.LP
.nf

.B
supported_tags() -> [chunk_element_type()]
.br
.fi
.br
.RS
.LP
This function can be used to find out which tags are supported by \fIapplication/erlang+html\fR\& documentation\&.
.RE