.TH wxTextAttr 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxTextAttr \- Functions for wxTextAttr class
.SH DESCRIPTION
.LP
\fIwxTextAttr\fR\& represents the character and paragraph attributes, or style, for a range of text in a \fIwxTextCtrl\fR\& or \fIwxRichTextCtrl\fR\& (not implemented in wx)\&.
.LP
When setting up a \fIwxTextAttr\fR\& object, pass a bitlist mask to \fIsetFlags/2\fR\& to indicate which style elements should be changed\&. As a convenience, when you call a setter such as SetFont, the relevant bit will be set\&.
.LP
See: \fIwxTextCtrl\fR\&, \fIwxRichTextCtrl\fR\& (not implemented in wx)
.LP
wxWidgets docs: wxTextAttr
.SH DATA TYPES
.nf

\fBwxTextAttr()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxTextAttr()
.br
.fi
.br
.RS
.LP
Constructors\&.
.RE
.LP
.nf

.B
new(ColText) -> wxTextAttr()
.br
.fi
.br
.nf

.B
new(Attr) -> wxTextAttr()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Attr = wxTextAttr()
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
new(ColText, Options :: [Option]) -> wxTextAttr()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
ColText = wx:wx_colour()
.br
Option = 
.br
    {colBack, wx:wx_colour()} |
.br
    {font, wxFont:wxFont()} |
.br
    {alignment, wx:wx_enum()}
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
getAlignment(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the alignment flags\&.
.LP
See ?wxTextAttrAlignment for a list of available styles\&.
.RE
.LP
.nf

.B
getBackgroundColour(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the background colour\&.
.RE
.LP
.nf

.B
getFont(This) -> wxFont:wxFont()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Creates and returns a font specified by the font attributes in the \fIwxTextAttr\fR\& object\&.
.LP
Note that \fIwxTextAttr\fR\& does not store a \fIwxFont\fR\& object, so this is only a temporary font\&.
.LP
For greater efficiency, access the font attributes directly\&.
.RE
.LP
.nf

.B
getFontEncoding(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the font encoding\&.
.RE
.LP
.nf

.B
getFontFaceName(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the font face name\&.
.RE
.LP
.nf

.B
getFontSize(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the font size in points\&.
.RE
.LP
.nf

.B
getFontStyle(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the font style\&.
.RE
.LP
.nf

.B
getFontUnderlined(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns true if the font is underlined\&.
.RE
.LP
.nf

.B
getFontWeight(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the font weight\&.
.RE
.LP
.nf

.B
getLeftIndent(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the left indent in tenths of a millimetre\&.
.RE
.LP
.nf

.B
getLeftSubIndent(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the left sub-indent in tenths of a millimetre\&.
.RE
.LP
.nf

.B
getRightIndent(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the right indent in tenths of a millimeter\&.
.RE
.LP
.nf

.B
getTabs(This) -> [integer()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns an array of tab stops, each expressed in tenths of a millimeter\&.
.LP
Each stop is measured from the left margin and therefore each value must be larger than the last\&.
.RE
.LP
.nf

.B
getTextColour(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns the text foreground colour\&.
.RE
.LP
.nf

.B
hasBackgroundColour(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns true if the attribute object specifies a background colour\&.
.RE
.LP
.nf

.B
hasFont(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns true if the attribute object specifies any font attributes\&.
.RE
.LP
.nf

.B
hasTextColour(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns true if the attribute object specifies a text foreground colour\&.
.RE
.LP
.nf

.B
getFlags(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns flags indicating which attributes are applicable\&.
.LP
See \fIsetFlags/2\fR\& for a list of available flags\&.
.RE
.LP
.nf

.B
isDefault(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
.RE
.RE
.RS
.LP
Returns false if we have any attributes set, true otherwise\&.
.RE
.LP
.nf

.B
setAlignment(This, Alignment) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Alignment = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the paragraph alignment\&.
.LP
See ?wxTextAttrAlignment enumeration values\&.
.LP
Of these, wxTEXT_ALIGNMENT_JUSTIFIED is unimplemented\&. In future justification may be supported when printing or previewing, only\&.
.RE
.LP
.nf

.B
setBackgroundColour(This, ColBack) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
ColBack = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Sets the background colour\&.
.RE
.LP
.nf

.B
setFlags(This, Flags) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Flags = integer()
.br
.RE
.RE
.RS
.LP
Sets the flags determining which styles are being specified\&.
.LP
The ?wxTextAttrFlags values can be passed in a bitlist\&.
.RE
.LP
.nf

.B
setFont(This, Font) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Font = wxFont:wxFont()
.br
.RE
.RE
.LP
.nf

.B
setFont(This, Font, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Font = wxFont:wxFont()
.br
Option = {flags, integer()}
.br
.RE
.RE
.RS
.LP
Sets the attributes for the given font\&.
.LP
Note that \fIwxTextAttr\fR\& does not store an actual \fIwxFont\fR\& object\&.
.RE
.LP
.nf

.B
setFontEncoding(This, Encoding) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Encoding = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the font encoding\&.
.RE
.LP
.nf

.B
setFontFaceName(This, FaceName) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
FaceName = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Sets the font face name\&.
.RE
.LP
.nf

.B
setFontFamily(This, Family) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Family = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the font family\&.
.RE
.LP
.nf

.B
setFontSize(This, PointSize) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
PointSize = integer()
.br
.RE
.RE
.RS
.LP
Sets the font size in points\&.
.RE
.LP
.nf

.B
setFontPointSize(This, PointSize) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
PointSize = integer()
.br
.RE
.RE
.RS
.LP
Sets the font size in points\&.
.RE
.LP
.nf

.B
setFontPixelSize(This, PixelSize) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
PixelSize = integer()
.br
.RE
.RE
.RS
.LP
Sets the font size in pixels\&.
.RE
.LP
.nf

.B
setFontStyle(This, FontStyle) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
FontStyle = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the font style (normal, italic or slanted)\&.
.RE
.LP
.nf

.B
setFontUnderlined(This, Underlined) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Underlined = boolean()
.br
.RE
.RE
.RS
.LP
Sets the font underlining (solid line, text colour)\&.
.RE
.LP
.nf

.B
setFontWeight(This, FontWeight) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
FontWeight = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the font weight\&.
.RE
.LP
.nf

.B
setLeftIndent(This, Indent) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Indent = integer()
.br
.RE
.RE
.LP
.nf

.B
setLeftIndent(This, Indent, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Indent = integer()
.br
Option = {subIndent, integer()}
.br
.RE
.RE
.RS
.LP
Sets the left indent and left subindent in tenths of a millimetre\&.
.LP
The sub-indent is an offset from the left of the paragraph, and is used for all but the first line in a paragraph\&.
.LP
A positive value will cause the first line to appear to the left of the subsequent lines, and a negative value will cause the first line to be indented relative to the subsequent lines\&.
.LP
\fIwxRichTextBuffer\fR\& (not implemented in wx) uses indentation to render a bulleted item\&. The left indent is the distance between the margin and the bullet\&. The content of the paragraph, including the first line, starts at leftMargin + leftSubIndent\&. So the distance between the left edge of the bullet and the left of the actual paragraph is leftSubIndent\&.
.RE
.LP
.nf

.B
setRightIndent(This, Indent) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Indent = integer()
.br
.RE
.RE
.RS
.LP
Sets the right indent in tenths of a millimetre\&.
.RE
.LP
.nf

.B
setTabs(This, Tabs) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
Tabs = [integer()]
.br
.RE
.RE
.RS
.LP
Sets the tab stops, expressed in tenths of a millimetre\&.
.LP
Each stop is measured from the left margin and therefore each value must be larger than the last\&.
.RE
.LP
.nf

.B
setTextColour(This, ColText) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxTextAttr()
.br
ColText = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Sets the text foreground colour\&.
.RE
.LP
.nf

.B
destroy(This :: wxTextAttr()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the object\&.
.RE