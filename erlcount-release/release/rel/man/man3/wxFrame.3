.TH wxFrame 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxFrame \- Functions for wxFrame class
.SH DESCRIPTION
.LP
A frame is a window whose size and position can (usually) be changed by the user\&.
.LP
It usually has thick borders and a title bar, and can optionally contain a menu bar, toolbar and status bar\&. A frame can contain any window that is not a frame or dialog\&.
.LP
A frame that has a status bar and toolbar, created via the \fIcreateStatusBar/2\fR\& and \fIcreateToolBar/2\fR\& functions, manages these windows and adjusts the value returned by \fIwxWindow:getClientSize/1\fR\& to reflect the remaining size available to application windows\&.
.LP
Remark: An application should normally define an \fIwxCloseEvent\fR\& handler for the frame to respond to system close events, for example so that related data and subwindows can be cleaned up\&.
.LP
Default event processing
.LP
\fIwxFrame\fR\& processes the following events:
.LP
Styles
.LP
This class supports the following styles:
.LP
See also the overview_windowstyles\&.
.LP
Extra Styles
.LP
This class supports the following extra styles:
.LP
See: \fIwxMDIParentFrame\fR\&, \fIwxMDIChildFrame\fR\&, \fIwxMiniFrame\fR\&, \fIwxDialog\fR\& 
.LP
This class is derived (and can use functions) from: \fIwxTopLevelWindow\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxFrame
.SH "EVENTS"

.LP
Event types emitted from this class: \fIclose_window\fR\&, \fIiconize\fR\&, \fImenu_open\fR\&, \fImenu_close\fR\&, \fImenu_highlight\fR\&
.SH DATA TYPES
.nf

\fBwxFrame()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxFrame()
.br
.fi
.br
.RS
.LP
Default constructor\&.
.RE
.LP
.nf

.B
new(Parent, Id, Title) -> wxFrame()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Id, Title, Options :: [Option]) -> wxFrame()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Constructor, creating the window\&.
.LP
Remark: For Motif, MWM (the Motif Window Manager) should be running for any window styles to work (otherwise all styles take effect)\&.
.LP
See: \fIcreate/5\fR\& 
.RE
.LP
.nf

.B
destroy(This :: wxFrame()) -> ok
.br
.fi
.br
.RS
.LP
Destructor\&.
.LP
Destroys all child windows and menu bar if present\&.
.LP
See overview_windowdeletion for more info\&.
.RE
.LP
.nf

.B
create(This, Parent, Id, Title) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Id, Title, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Used in two-step frame construction\&.
.LP
See \fInew/4\fR\& for further details\&.
.RE
.LP
.nf

.B
createStatusBar(This) -> wxStatusBar:wxStatusBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.LP
.nf

.B
createStatusBar(This, Options :: [Option]) ->
.B
                   wxStatusBar:wxStatusBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Option = 
.br
    {number, integer()} | {style, integer()} | {id, integer()}
.br
.RE
.RE
.RS
.LP
Creates a status bar at the bottom of the frame\&.
.LP
Return: A pointer to the status bar if it was created successfully, NULL otherwise\&.
.LP
Remark: The width of the status bar is the whole width of the frame (adjusted automatically when resizing), and the height and text size are chosen by the host windowing system\&.
.LP
See: \fIsetStatusText/3\fR\&, \fIOnCreateStatusBar()\fR\& (not implemented in wx), \fIgetStatusBar/1\fR\& 
.RE
.LP
.nf

.B
createToolBar(This) -> wxToolBar:wxToolBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.LP
.nf

.B
createToolBar(This, Options :: [Option]) -> wxToolBar:wxToolBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Option = {style, integer()} | {id, integer()}
.br
.RE
.RE
.RS
.LP
Creates a toolbar at the top or left of the frame\&.
.LP
Return: A pointer to the toolbar if it was created successfully, NULL otherwise\&.
.LP
Remark: By default, the toolbar is an instance of \fIwxToolBar\fR\&\&. To use a different class, override \fIOnCreateToolBar()\fR\& (not implemented in wx)\&. When a toolbar has been created with this function, or made known to the frame with \fIsetToolBar/2\fR\&, the frame will manage the toolbar position and adjust the return value from \fIwxWindow:getClientSize/1\fR\& to reflect the available space for application windows\&. Under Pocket PC, you should always use this function for creating the toolbar to be managed by the frame, so that wxWidgets can use a combined menubar and toolbar\&. Where you manage your own toolbars, create a \fIwxToolBar\fR\& as usual\&.
.LP
See: \fIcreateStatusBar/2\fR\&, \fIOnCreateToolBar()\fR\& (not implemented in wx), \fIsetToolBar/2\fR\&, \fIgetToolBar/1\fR\& 
.RE
.LP
.nf

.B
getClientAreaOrigin(This) -> {X :: integer(), Y :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.RS
.LP
Returns the origin of the frame client area (in client coordinates)\&.
.LP
It may be different from (0, 0) if the frame has a toolbar\&.
.RE
.LP
.nf

.B
getMenuBar(This) -> wxMenuBar:wxMenuBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.RS
.LP
Returns a pointer to the menubar currently associated with the frame (if any)\&.
.LP
See: \fIsetMenuBar/2\fR\&, \fIwxMenuBar\fR\&, \fIwxMenu\fR\& 
.RE
.LP
.nf

.B
getStatusBar(This) -> wxStatusBar:wxStatusBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.RS
.LP
Returns a pointer to the status bar currently associated with the frame (if any)\&.
.LP
See: \fIcreateStatusBar/2\fR\&, \fIwxStatusBar\fR\& 
.RE
.LP
.nf

.B
getStatusBarPane(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.RS
.LP
Returns the status bar pane used to display menu and toolbar help\&.
.LP
See: \fIsetStatusBarPane/2\fR\& 
.RE
.LP
.nf

.B
getToolBar(This) -> wxToolBar:wxToolBar()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.RS
.LP
Returns a pointer to the toolbar currently associated with the frame (if any)\&.
.LP
See: \fIcreateToolBar/2\fR\&, \fIwxToolBar\fR\&, \fIsetToolBar/2\fR\& 
.RE
.LP
.nf

.B
processCommand(This, Id) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Id = integer()
.br
.RE
.RE
.RS
.LP
Simulate a menu command\&.
.RE
.LP
.nf

.B
sendSizeEvent(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
.RE
.RE
.LP
.nf

.B
sendSizeEvent(This, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Option = {flags, integer()}
.br
.RE
.RE
.RS
.LP
This function sends a dummy \fIwxSizeEvent\fR\& to the window allowing it to re-layout its children positions\&.
.LP
It is sometimes useful to call this function after adding or deleting a children after the frame creation or if a child size changes\&. Note that if the frame is using either sizers or constraints for the children layout, it is enough to call \fIwxWindow:layout/1\fR\& directly and this function should not be used in this case\&.
.LP
If \fIflags\fR\& includes \fIwxSEND_EVENT_POST\fR\& value, this function posts the event, i\&.e\&. schedules it for later processing, instead of dispatching it directly\&. You can also use \fIPostSizeEvent()\fR\& (not implemented in wx) as a more readable equivalent of calling this function with this flag\&.
.RE
.LP
.nf

.B
setMenuBar(This, MenuBar) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
MenuBar = wxMenuBar:wxMenuBar()
.br
.RE
.RE
.RS
.LP
Tells the frame to show the given menu bar\&.
.LP
Remark: If the frame is destroyed, the menu bar and its menus will be destroyed also, so do not delete the menu bar explicitly (except by resetting the frame\&'s menu bar to another frame or NULL)\&. Under Windows, a size event is generated, so be sure to initialize data members properly before calling \fIsetMenuBar/2\fR\&\&. Note that on some platforms, it is not possible to call this function twice for the same frame object\&.
.LP
See: \fIgetMenuBar/1\fR\&, \fIwxMenuBar\fR\&, \fIwxMenu\fR\& 
.RE
.LP
.nf

.B
setStatusBar(This, StatusBar) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
StatusBar = wxStatusBar:wxStatusBar()
.br
.RE
.RE
.RS
.LP
Associates a status bar with the frame\&.
.LP
If \fIstatusBar\fR\& is NULL, then the status bar, if present, is detached from the frame, but \fInot\fR\& deleted\&.
.LP
See: \fIcreateStatusBar/2\fR\&, \fIwxStatusBar\fR\&, \fIgetStatusBar/1\fR\& 
.RE
.LP
.nf

.B
setStatusBarPane(This, N) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
N = integer()
.br
.RE
.RE
.RS
.LP
Set the status bar pane used to display menu and toolbar help\&.
.LP
Using -1 disables help display\&.
.RE
.LP
.nf

.B
setStatusText(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
setStatusText(This, Text, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Text = unicode:chardata()
.br
Option = {number, integer()}
.br
.RE
.RE
.RS
.LP
Sets the status bar text and updates the status bar display\&.
.LP
This is a simple wrapper for \fIwxStatusBar:setStatusText/3\fR\& which doesn\&'t do anything if the frame has no status bar, i\&.e\&. \fIgetStatusBar/1\fR\& returns NULL\&.
.LP
Remark: Use an empty string to clear the status bar\&.
.LP
See: \fIcreateStatusBar/2\fR\&, \fIwxStatusBar\fR\& 
.RE
.LP
.nf

.B
setStatusWidths(This, Widths_field) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
Widths_field = [integer()]
.br
.RE
.RE
.RS
.LP
Sets the widths of the fields in the status bar\&.
.LP
Remark: The widths of the variable fields are calculated from the total width of all fields, minus the sum of widths of the non-variable fields, divided by the number of variable fields\&.
.RE
.LP
.nf

.B
setToolBar(This, ToolBar) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxFrame()
.br
ToolBar = wxToolBar:wxToolBar()
.br
.RE
.RE
.RS
.LP
Associates a toolbar with the frame\&.
.RE