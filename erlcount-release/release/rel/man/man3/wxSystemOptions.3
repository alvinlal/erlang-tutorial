.TH wxSystemOptions 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxSystemOptions \- Functions for wxSystemOptions class
.SH DESCRIPTION
.LP
\fIwxSystemOptions\fR\& stores option/value pairs that wxWidgets itself or applications can use to alter behaviour at run-time\&. It can be used to optimize behaviour that doesn\&'t deserve a distinct API, but is still important to be able to configure\&.
.LP
System options can be set by the program itself using \fIsetOption/2\fR\& method and they also can be set from the program environment by defining an environment variable \fIwx_option\fR\& to set the given option for all wxWidgets applications or \fIwx_appname_option\fR\& to set it just for the application with the given name (as returned by \fIwxApp::GetAppName()\fR\& (not implemented in wx))\&. Notice that any characters not allowed in the environment variables names, such as periods and dashes, should be replaced with underscores\&. E\&.g\&. to define a system option "foo-bar" you need to define the environment variable "wx_foo_bar"\&.
.LP
The program may use system options for its own needs but they are mostly used to control the behaviour of wxWidgets library itself\&.
.LP
These options are currently recognised by wxWidgets:
.LP
All platforms
.LP
Windows
.LP
GTK+
.LP
Mac
.LP
Motif
.LP
The compile-time option to include or exclude this functionality is wxUSE_SYSTEM_OPTIONS\&.
.LP
See: \fIwxSystemSettings\fR\& 
.LP
wxWidgets docs: wxSystemOptions
.SH DATA TYPES
.nf

\fBwxSystemOptions()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
getOption(Name) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Gets an option\&.
.LP
The function is case-insensitive to \fIname\fR\&\&. Returns empty string if the option hasn\&'t been set\&.
.LP
See: \fIsetOption/2\fR\&, \fIgetOptionInt/1\fR\&, \fIhasOption/1\fR\& 
.RE
.LP
.nf

.B
getOptionInt(Name) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Gets an option as an integer\&.
.LP
The function is case-insensitive to \fIname\fR\&\&. If the option hasn\&'t been set, this function returns 0\&.
.LP
See: \fIsetOption/2\fR\&, \fIgetOption/1\fR\&, \fIhasOption/1\fR\& 
.RE
.LP
.nf

.B
hasOption(Name) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Returns true if the given option is present\&.
.LP
The function is case-insensitive to \fIname\fR\&\&.
.LP
See: \fIsetOption/2\fR\&, \fIgetOption/1\fR\&, \fIgetOptionInt/1\fR\& 
.RE
.LP
.nf

.B
isFalse(Name) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Returns true if the option with the given \fIname\fR\& had been set to 0 value\&.
.LP
This is mostly useful for boolean options for which you can\&'t use \fIGetOptionInt(name)\fR\& == 0 as this would also be true if the option hadn\&'t been set at all\&.
.RE
.LP
.nf

.B
setOption(Name, Value) -> ok
.br
.fi
.br
.nf

.B
setOption(Name, Value) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = Value = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Sets an option\&.
.LP
The function is case-insensitive to \fIname\fR\&\&.
.RE