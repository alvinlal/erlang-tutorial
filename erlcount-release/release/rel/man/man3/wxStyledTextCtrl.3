.TH wxStyledTextCtrl 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxStyledTextCtrl \- Functions for wxStyledTextCtrl class
.SH DESCRIPTION
.LP
A wxWidgets implementation of the Scintilla source code editing component\&.
.LP
As well as features found in standard text editing components, Scintilla includes features especially useful when editing and debugging source code\&. These include support for syntax styling, error indicators, code completion and call tips\&.
.LP
The selection margin can contain markers like those used in debuggers to indicate breakpoints and the current line\&. Styling choices are more open than with many editors, allowing the use of proportional fonts, bold and italics, multiple foreground and background colours and multiple fonts\&.
.LP
\fIwxStyledTextCtrl\fR\& is a 1 to 1 mapping of "raw" scintilla interface, whose documentation can be found in the Scintilla website (http://www\&.scintilla\&.org/)\&.
.LP
Please see \fIwxStyledTextEvent\fR\& for the documentation of all event types you can use with \fIwxStyledTextCtrl\fR\&\&.
.LP
Index of the member groups
.LP
Links for quick access to the various categories of \fIwxStyledTextCtrl\fR\& functions:
.LP
See: \fIwxStyledTextEvent\fR\& 
.LP
This class is derived (and can use functions) from: \fIwxControl\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxStyledTextCtrl
.SH DATA TYPES
.nf

\fBwxStyledTextCtrl()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxStyledTextCtrl()
.br
.fi
.br
.RS
.LP
Default ctor\&.
.RE
.LP
.nf

.B
new(Parent) -> wxStyledTextCtrl()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Options :: [Option]) -> wxStyledTextCtrl()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Ctor\&.
.RE
.LP
.nf

.B
destroy(This :: wxStyledTextCtrl()) -> ok
.br
.fi
.br
.RS
.LP
Destructor\&.
.RE
.LP
.nf

.B
create(This, Parent) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Create the UI elements for a STC that was created with the default ctor\&.
.LP
(For 2-phase create\&.)
.RE
.LP
.nf

.B
addText(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Add text to the document at current position\&.
.RE
.LP
.nf

.B
insertText(This, Pos, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Insert string at a position\&.
.RE
.LP
.nf

.B
clearAll(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete all text in the document\&.
.RE
.LP
.nf

.B
clearDocumentStyle(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Set all style bytes to 0, remove all folding information\&.
.RE
.LP
.nf

.B
getLength(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the number of bytes in the document\&.
.RE
.LP
.nf

.B
getCharAt(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Returns the character byte at the position\&.
.RE
.LP
.nf

.B
getCurrentPos(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the position of the caret\&.
.RE
.LP
.nf

.B
getAnchor(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the position of the opposite end of the selection to the caret\&.
.RE
.LP
.nf

.B
getStyleAt(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Returns the style byte at the position\&.
.RE
.LP
.nf

.B
redo(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Redoes the next action on the undo history\&.
.RE
.LP
.nf

.B
setUndoCollection(This, CollectUndo) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CollectUndo = boolean()
.br
.RE
.RE
.RS
.LP
Choose between collecting actions into the undo history and discarding them\&.
.RE
.LP
.nf

.B
selectAll(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Select all the text in the document\&.
.RE
.LP
.nf

.B
setSavePoint(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Remember the current position in the undo history as the position at which the document was saved\&.
.RE
.LP
.nf

.B
canRedo(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Are there any redoable actions in the undo history?
.RE
.LP
.nf

.B
markerLineFromHandle(This, MarkerHandle) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerHandle = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the line number at which a particular marker is located\&.
.RE
.LP
.nf

.B
markerDeleteHandle(This, MarkerHandle) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerHandle = integer()
.br
.RE
.RE
.RS
.LP
Delete a marker\&.
.RE
.LP
.nf

.B
getUndoCollection(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is undo history being collected?
.RE
.LP
.nf

.B
getViewWhiteSpace(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Are white space characters currently visible? Returns one of wxSTC_WS_* constants\&.
.RE
.LP
.nf

.B
setViewWhiteSpace(This, ViewWS) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
ViewWS = integer()
.br
.RE
.RE
.RS
.LP
Make white space characters invisible, always visible or visible outside indentation\&.
.LP
The input should be one of the ?wxSTC_WS_* constants\&.
.RE
.LP
.nf

.B
positionFromPoint(This, Pt) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Find the position from a point within the window\&.
.RE
.LP
.nf

.B
positionFromPointClose(This, X, Y) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
X = Y = integer()
.br
.RE
.RE
.RS
.LP
Find the position from a point within the window but return wxSTC_INVALID_POSITION if not close to text\&.
.RE
.LP
.nf

.B
gotoLine(This, Line) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Set caret to start of a line and ensure it is visible\&.
.RE
.LP
.nf

.B
gotoPos(This, Caret) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Caret = integer()
.br
.RE
.RE
.RS
.LP
Set caret to a position and ensure it is visible\&.
.RE
.LP
.nf

.B
setAnchor(This, Anchor) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Anchor = integer()
.br
.RE
.RE
.RS
.LP
Set the selection anchor to a position\&.
.LP
The anchor is the opposite end of the selection from the caret\&.
.RE
.LP
.nf

.B
getCurLine(This) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = {Res :: unicode:charlist(), LinePos :: integer()}
.br
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the text of the line containing the caret\&.
.LP
linePos can optionally be passed in to receive the index of the caret on the line\&.
.RE
.LP
.nf

.B
getEndStyled(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the position of the last correctly styled character\&.
.RE
.LP
.nf

.B
convertEOLs(This, EolMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
EolMode = integer()
.br
.RE
.RE
.RS
.LP
Convert all line endings in the document to one mode\&.
.RE
.LP
.nf

.B
getEOLMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the current end of line mode - one of wxSTC_EOL_CRLF, wxSTC_EOL_CR, or wxSTC_EOL_LF\&.
.RE
.LP
.nf

.B
setEOLMode(This, EolMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
EolMode = integer()
.br
.RE
.RE
.RS
.LP
Set the current end of line mode\&.
.LP
The input should be one of the ?wxSTC_EOL_* constants\&.
.RE
.LP
.nf

.B
startStyling(This, Start) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Start = integer()
.br
.RE
.RE
.RS
.LP
Set the current styling position to start\&.
.RE
.LP
.nf

.B
setStyling(This, Length, Style) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Length = Style = integer()
.br
.RE
.RE
.RS
.LP
Change style from current styling position for length characters to a style and move the current styling position to after this newly styled segment\&.
.RE
.LP
.nf

.B
getBufferedDraw(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is drawing done first into a buffer or direct to the screen?
.RE
.LP
.nf

.B
setBufferedDraw(This, Buffered) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Buffered = boolean()
.br
.RE
.RE
.RS
.LP
If drawing is buffered then each line of text is drawn into a bitmap buffer before drawing it to the screen to avoid flicker\&.
.RE
.LP
.nf

.B
setTabWidth(This, TabWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
TabWidth = integer()
.br
.RE
.RE
.RS
.LP
Change the visible size of a tab to be a multiple of the width of a space character\&.
.RE
.LP
.nf

.B
getTabWidth(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the visible size of a tab\&.
.RE
.LP
.nf

.B
setCodePage(This, CodePage) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CodePage = integer()
.br
.RE
.RE
.RS
.LP
Set the code page used to interpret the bytes of the document as characters\&.
.RE
.LP
.nf

.B
markerDefine(This, MarkerNumber, MarkerSymbol) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = MarkerSymbol = integer()
.br
.RE
.RE
.LP
.nf

.B
markerDefine(This, MarkerNumber, MarkerSymbol,
.B
             Options :: [Option]) ->
.B
                ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = MarkerSymbol = integer()
.br
Option = 
.br
    {foreground, wx:wx_colour()} | {background, wx:wx_colour()}
.br
.RE
.RE
.RS
.LP
Set the symbol used for a particular marker number, and optionally the fore and background colours\&.
.LP
The second argument should be one of the ?wxSTC_MARK_* constants\&.
.RE
.LP
.nf

.B
markerSetForeground(This, MarkerNumber, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = integer()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour used for a particular marker number\&.
.RE
.LP
.nf

.B
markerSetBackground(This, MarkerNumber, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = integer()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the background colour used for a particular marker number\&.
.RE
.LP
.nf

.B
markerAdd(This, Line, MarkerNumber) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = MarkerNumber = integer()
.br
.RE
.RE
.RS
.LP
Add a marker to a line, returning an ID which can be used to find or delete the marker\&.
.RE
.LP
.nf

.B
markerDelete(This, Line, MarkerNumber) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = MarkerNumber = integer()
.br
.RE
.RE
.RS
.LP
Delete a marker from a line\&.
.RE
.LP
.nf

.B
markerDeleteAll(This, MarkerNumber) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = integer()
.br
.RE
.RE
.RS
.LP
Delete all markers with a particular number from all lines\&.
.RE
.LP
.nf

.B
markerGet(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Get a bit mask of all the markers set on a line\&.
.RE
.LP
.nf

.B
markerNext(This, LineStart, MarkerMask) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
LineStart = MarkerMask = integer()
.br
.RE
.RE
.RS
.LP
Find the next line at or after lineStart that includes a marker in mask\&.
.LP
Return -1 when no more lines\&.
.RE
.LP
.nf

.B
markerPrevious(This, LineStart, MarkerMask) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
LineStart = MarkerMask = integer()
.br
.RE
.RE
.RS
.LP
Find the previous line before lineStart that includes a marker in mask\&.
.RE
.LP
.nf

.B
markerDefineBitmap(This, MarkerNumber, Bmp) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = integer()
.br
Bmp = wxBitmap:wxBitmap()
.br
.RE
.RE
.RS
.LP
Define a marker with a \fIwxBitmap\fR\&\&.
.RE
.LP
.nf

.B
markerAddSet(This, Line, MarkerSet) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = MarkerSet = integer()
.br
.RE
.RE
.RS
.LP
Add a set of markers to a line\&.
.RE
.LP
.nf

.B
markerSetAlpha(This, MarkerNumber, Alpha) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MarkerNumber = Alpha = integer()
.br
.RE
.RE
.RS
.LP
Set the alpha used for a marker that is drawn in the text area, not the margin\&.
.RE
.LP
.nf

.B
setMarginType(This, Margin, MarginType) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = MarginType = integer()
.br
.RE
.RE
.RS
.LP
Set a margin to be either numeric or symbolic\&.
.LP
The second argument should be one of the ?wxSTC_MARGIN_* constants\&.
.RE
.LP
.nf

.B
getMarginType(This, Margin) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the type of a margin\&.
.LP
The return value will be one of the ?wxSTC_MARGIN_* constants\&.
.RE
.LP
.nf

.B
setMarginWidth(This, Margin, PixelWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = PixelWidth = integer()
.br
.RE
.RE
.RS
.LP
Set the width of a margin to a width expressed in pixels\&.
.RE
.LP
.nf

.B
getMarginWidth(This, Margin) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the width of a margin in pixels\&.
.RE
.LP
.nf

.B
setMarginMask(This, Margin, Mask) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = Mask = integer()
.br
.RE
.RE
.RS
.LP
Set a mask that determines which markers are displayed in a margin\&.
.RE
.LP
.nf

.B
getMarginMask(This, Margin) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the marker mask of a margin\&.
.RE
.LP
.nf

.B
setMarginSensitive(This, Margin, Sensitive) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = integer()
.br
Sensitive = boolean()
.br
.RE
.RE
.RS
.LP
Make a margin sensitive or insensitive to mouse clicks\&.
.RE
.LP
.nf

.B
getMarginSensitive(This, Margin) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Margin = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the mouse click sensitivity of a margin\&.
.RE
.LP
.nf

.B
styleClearAll(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Clear all the styles and make equivalent to the global default style\&.
.RE
.LP
.nf

.B
styleSetForeground(This, Style, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour of a style\&.
.RE
.LP
.nf

.B
styleSetBackground(This, Style, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the background colour of a style\&.
.RE
.LP
.nf

.B
styleSetBold(This, Style, Bold) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Bold = boolean()
.br
.RE
.RE
.RS
.LP
Set a style to be bold or not\&.
.RE
.LP
.nf

.B
styleSetItalic(This, Style, Italic) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Italic = boolean()
.br
.RE
.RE
.RS
.LP
Set a style to be italic or not\&.
.RE
.LP
.nf

.B
styleSetSize(This, Style, SizePoints) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = SizePoints = integer()
.br
.RE
.RE
.RS
.LP
Set the size of characters of a style\&.
.RE
.LP
.nf

.B
styleSetFaceName(This, Style, FontName) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
FontName = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Set the font of a style\&.
.RE
.LP
.nf

.B
styleSetEOLFilled(This, Style, EolFilled) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
EolFilled = boolean()
.br
.RE
.RE
.RS
.LP
Set a style to have its end of line filled or not\&.
.RE
.LP
.nf

.B
styleResetDefault(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Reset the default style to its state at startup\&.
.RE
.LP
.nf

.B
styleSetUnderline(This, Style, Underline) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Underline = boolean()
.br
.RE
.RE
.RS
.LP
Set a style to be underlined or not\&.
.RE
.LP
.nf

.B
styleSetCase(This, Style, CaseVisible) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = CaseVisible = integer()
.br
.RE
.RE
.RS
.LP
Set a style to be mixed case, or to force upper or lower case\&.
.LP
The second argument should be one of the ?wxSTC_CASE_* constants\&.
.RE
.LP
.nf

.B
styleSetHotSpot(This, Style, Hotspot) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Hotspot = boolean()
.br
.RE
.RE
.RS
.LP
Set a style to be a hotspot or not\&.
.RE
.LP
.nf

.B
setSelForeground(This, UseSetting, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour of the main and additional selections and whether to use this setting\&.
.RE
.LP
.nf

.B
setSelBackground(This, UseSetting, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the background colour of the main and additional selections and whether to use this setting\&.
.RE
.LP
.nf

.B
getSelAlpha(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the alpha of the selection\&.
.RE
.LP
.nf

.B
setSelAlpha(This, Alpha) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Alpha = integer()
.br
.RE
.RE
.RS
.LP
Set the alpha of the selection\&.
.RE
.LP
.nf

.B
setCaretForeground(This, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour of the caret\&.
.RE
.LP
.nf

.B
cmdKeyAssign(This, Key, Modifiers, Cmd) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Key = Modifiers = Cmd = integer()
.br
.RE
.RE
.RS
.LP
When key+modifier combination keyDefinition is pressed perform sciCommand\&.
.LP
The second argument should be a bit list containing one or more of the ?wxSTC_KEYMOD_* constants and the third argument should be one of the ?wxSTC_CMD_* constants\&.
.RE
.LP
.nf

.B
cmdKeyClear(This, Key, Modifiers) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Key = Modifiers = integer()
.br
.RE
.RE
.RS
.LP
When key+modifier combination keyDefinition is pressed do nothing\&.
.LP
The second argument should be a bit list containing one or more of the ?wxSTC_KEYMOD_* constants\&.
.RE
.LP
.nf

.B
cmdKeyClearAll(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Drop all key mappings\&.
.RE
.LP
.nf

.B
setStyleBytes(This, Length) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Length = integer()
.br
.RE
.RE
.RS
.LP
Set the styles for a segment of the document\&.
.RE
.LP
.nf

.B
styleSetVisible(This, Style, Visible) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Visible = boolean()
.br
.RE
.RE
.RS
.LP
Set a style to be visible or not\&.
.RE
.LP
.nf

.B
getCaretPeriod(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the time in milliseconds that the caret is on and off\&.
.RE
.LP
.nf

.B
setCaretPeriod(This, PeriodMilliseconds) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PeriodMilliseconds = integer()
.br
.RE
.RE
.RS
.LP
Get the time in milliseconds that the caret is on and off\&.
.LP
0 = steady on\&.
.RE
.LP
.nf

.B
setWordChars(This, Characters) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Characters = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Set the set of characters making up words for when moving or selecting by word\&.
.LP
First sets defaults like SetCharsDefault\&.
.RE
.LP
.nf

.B
beginUndoAction(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Start a sequence of actions that is undone and redone as a unit\&.
.LP
May be nested\&.
.RE
.LP
.nf

.B
endUndoAction(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
End a sequence of actions that is undone and redone as a unit\&.
.RE
.LP
.nf

.B
indicatorSetStyle(This, Indicator, IndicatorStyle) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Indicator = IndicatorStyle = integer()
.br
.RE
.RE
.RS
.LP
Set an indicator to plain, squiggle or TT\&.
.LP
The second argument should be one of the ?wxSTC_INDIC_* constants\&.
.RE
.LP
.nf

.B
indicatorGetStyle(This, Indicator) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Indicator = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the style of an indicator\&.
.LP
The return value will be one of the ?wxSTC_INDIC_* constants\&.
.RE
.LP
.nf

.B
indicatorSetForeground(This, Indicator, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Indicator = integer()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour of an indicator\&.
.RE
.LP
.nf

.B
indicatorGetForeground(This, Indicator) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Indicator = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the foreground colour of an indicator\&.
.RE
.LP
.nf

.B
setWhitespaceForeground(This, UseSetting, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour of all whitespace and whether to use this setting\&.
.RE
.LP
.nf

.B
setWhitespaceBackground(This, UseSetting, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the background colour of all whitespace and whether to use this setting\&.
.RE
.LP
.nf

.B
getStyleBits(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve number of bits in style bytes used to hold the lexical state\&.
.LP
Deprecated:
.RE
.LP
.nf

.B
setLineState(This, Line, State) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = State = integer()
.br
.RE
.RE
.RS
.LP
Used to hold extra styling information for each line\&.
.RE
.LP
.nf

.B
getLineState(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the extra styling information for a line\&.
.RE
.LP
.nf

.B
getMaxLineState(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the last line number that has line state\&.
.RE
.LP
.nf

.B
getCaretLineVisible(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is the background of the line containing the caret in a different colour?
.RE
.LP
.nf

.B
setCaretLineVisible(This, Show) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Show = boolean()
.br
.RE
.RE
.RS
.LP
Display the background of the line containing the caret in a different colour\&.
.RE
.LP
.nf

.B
getCaretLineBackground(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the colour of the background of the line containing the caret\&.
.RE
.LP
.nf

.B
setCaretLineBackground(This, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the colour of the background of the line containing the caret\&.
.RE
.LP
.nf

.B
autoCompShow(This, LengthEntered, ItemList) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
LengthEntered = integer()
.br
ItemList = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Display a auto-completion list\&.
.LP
The lengthEntered parameter indicates how many characters before the caret should be used to provide context\&.
.RE
.LP
.nf

.B
autoCompCancel(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Remove the auto-completion list from the screen\&.
.RE
.LP
.nf

.B
autoCompActive(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is there an auto-completion list visible?
.RE
.LP
.nf

.B
autoCompPosStart(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the position of the caret when the auto-completion list was displayed\&.
.RE
.LP
.nf

.B
autoCompComplete(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
User has selected an item so remove the list and insert the selection\&.
.RE
.LP
.nf

.B
autoCompStops(This, CharacterSet) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CharacterSet = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Define a set of character that when typed cancel the auto-completion list\&.
.RE
.LP
.nf

.B
autoCompSetSeparator(This, SeparatorCharacter) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SeparatorCharacter = integer()
.br
.RE
.RE
.RS
.LP
Change the separator character in the string setting up an auto-completion list\&.
.LP
Default is space but can be changed if items contain space\&.
.RE
.LP
.nf

.B
autoCompGetSeparator(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the auto-completion list separator character\&.
.RE
.LP
.nf

.B
autoCompSelect(This, Select) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Select = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Select the item in the auto-completion list that starts with a string\&.
.RE
.LP
.nf

.B
autoCompSetCancelAtStart(This, Cancel) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Cancel = boolean()
.br
.RE
.RE
.RS
.LP
Should the auto-completion list be cancelled if the user backspaces to a position before where the box was created\&.
.RE
.LP
.nf

.B
autoCompGetCancelAtStart(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether auto-completion cancelled by backspacing before start\&.
.RE
.LP
.nf

.B
autoCompSetFillUps(This, CharacterSet) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CharacterSet = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Define a set of characters that when typed will cause the autocompletion to choose the selected item\&.
.RE
.LP
.nf

.B
autoCompSetChooseSingle(This, ChooseSingle) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
ChooseSingle = boolean()
.br
.RE
.RE
.RS
.LP
Should a single item auto-completion list automatically choose the item\&.
.RE
.LP
.nf

.B
autoCompGetChooseSingle(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether a single item auto-completion list automatically choose the item\&.
.RE
.LP
.nf

.B
autoCompSetIgnoreCase(This, IgnoreCase) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
IgnoreCase = boolean()
.br
.RE
.RE
.RS
.LP
Set whether case is significant when performing auto-completion searches\&.
.RE
.LP
.nf

.B
autoCompGetIgnoreCase(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve state of ignore case flag\&.
.RE
.LP
.nf

.B
userListShow(This, ListType, ItemList) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
ListType = integer()
.br
ItemList = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Display a list of strings and send notification when user chooses one\&.
.RE
.LP
.nf

.B
autoCompSetAutoHide(This, AutoHide) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
AutoHide = boolean()
.br
.RE
.RE
.RS
.LP
Set whether or not autocompletion is hidden automatically when nothing matches\&.
.RE
.LP
.nf

.B
autoCompGetAutoHide(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether or not autocompletion is hidden automatically when nothing matches\&.
.RE
.LP
.nf

.B
autoCompSetDropRestOfWord(This, DropRestOfWord) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
DropRestOfWord = boolean()
.br
.RE
.RE
.RS
.LP
Set whether or not autocompletion deletes any word characters after the inserted text upon completion\&.
.RE
.LP
.nf

.B
autoCompGetDropRestOfWord(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether or not autocompletion deletes any word characters after the inserted text upon completion\&.
.RE
.LP
.nf

.B
registerImage(This, Type, Bmp) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Type = integer()
.br
Bmp = wxBitmap:wxBitmap()
.br
.RE
.RE
.RS
.LP
Register an image for use in autocompletion lists\&.
.RE
.LP
.nf

.B
clearRegisteredImages(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Clear all the registered images\&.
.RE
.LP
.nf

.B
autoCompGetTypeSeparator(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the auto-completion list type-separator character\&.
.RE
.LP
.nf

.B
autoCompSetTypeSeparator(This, SeparatorCharacter) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SeparatorCharacter = integer()
.br
.RE
.RE
.RS
.LP
Change the type-separator character in the string setting up an auto-completion list\&.
.LP
Default is \&'?\&' but can be changed if items contain \&'?\&'\&.
.RE
.LP
.nf

.B
autoCompSetMaxWidth(This, CharacterCount) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CharacterCount = integer()
.br
.RE
.RE
.RS
.LP
Set the maximum width, in characters, of auto-completion and user lists\&.
.LP
Set to 0 to autosize to fit longest item, which is the default\&.
.RE
.LP
.nf

.B
autoCompGetMaxWidth(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the maximum width, in characters, of auto-completion and user lists\&.
.RE
.LP
.nf

.B
autoCompSetMaxHeight(This, RowCount) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
RowCount = integer()
.br
.RE
.RE
.RS
.LP
Set the maximum height, in rows, of auto-completion and user lists\&.
.LP
The default is 5 rows\&.
.RE
.LP
.nf

.B
autoCompGetMaxHeight(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Set the maximum height, in rows, of auto-completion and user lists\&.
.RE
.LP
.nf

.B
setIndent(This, IndentSize) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
IndentSize = integer()
.br
.RE
.RE
.RS
.LP
Set the number of spaces used for one level of indentation\&.
.RE
.LP
.nf

.B
getIndent(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve indentation size\&.
.RE
.LP
.nf

.B
setUseTabs(This, UseTabs) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseTabs = boolean()
.br
.RE
.RE
.RS
.LP
Indentation will only use space characters if useTabs is false, otherwise it will use a combination of tabs and spaces\&.
.RE
.LP
.nf

.B
getUseTabs(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether tabs will be used in indentation\&.
.RE
.LP
.nf

.B
setLineIndentation(This, Line, Indentation) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = Indentation = integer()
.br
.RE
.RE
.RS
.LP
Change the indentation of a line to a number of columns\&.
.RE
.LP
.nf

.B
getLineIndentation(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the number of columns that a line is indented\&.
.RE
.LP
.nf

.B
getLineIndentPosition(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the position before the first non indentation character on a line\&.
.RE
.LP
.nf

.B
getColumn(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the column number of a position, taking tab width into account\&.
.RE
.LP
.nf

.B
setUseHorizontalScrollBar(This, Visible) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Visible = boolean()
.br
.RE
.RE
.RS
.LP
Show or hide the horizontal scroll bar\&.
.RE
.LP
.nf

.B
getUseHorizontalScrollBar(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is the horizontal scroll bar visible?
.RE
.LP
.nf

.B
setIndentationGuides(This, IndentView) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
IndentView = integer()
.br
.RE
.RE
.RS
.LP
Show or hide indentation guides\&.
.LP
The input should be one of the ?wxSTC_IV_* constants\&.
.RE
.LP
.nf

.B
getIndentationGuides(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Are the indentation guides visible?
.LP
The return value will be one of the ?wxSTC_IV_* constants\&.
.RE
.LP
.nf

.B
setHighlightGuide(This, Column) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Column = integer()
.br
.RE
.RE
.RS
.LP
Set the highlighted indentation guide column\&.
.LP
0 = no highlighted guide\&.
.RE
.LP
.nf

.B
getHighlightGuide(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the highlighted indentation guide column\&.
.RE
.LP
.nf

.B
getLineEndPosition(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Get the position after the last visible characters on a line\&.
.RE
.LP
.nf

.B
getCodePage(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the code page used to interpret the bytes of the document as characters\&.
.RE
.LP
.nf

.B
getCaretForeground(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the foreground colour of the caret\&.
.RE
.LP
.nf

.B
getReadOnly(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
In read-only mode?
.RE
.LP
.nf

.B
setCurrentPos(This, Caret) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Caret = integer()
.br
.RE
.RE
.RS
.LP
Sets the position of the caret\&.
.RE
.LP
.nf

.B
setSelectionStart(This, Anchor) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Anchor = integer()
.br
.RE
.RE
.RS
.LP
Sets the position that starts the selection - this becomes the anchor\&.
.RE
.LP
.nf

.B
getSelectionStart(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the position at the start of the selection\&.
.RE
.LP
.nf

.B
setSelectionEnd(This, Caret) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Caret = integer()
.br
.RE
.RE
.RS
.LP
Sets the position that ends the selection - this becomes the caret\&.
.RE
.LP
.nf

.B
getSelectionEnd(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the position at the end of the selection\&.
.RE
.LP
.nf

.B
setPrintMagnification(This, Magnification) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Magnification = integer()
.br
.RE
.RE
.RS
.LP
Sets the print magnification added to the point size of each style for printing\&.
.RE
.LP
.nf

.B
getPrintMagnification(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the print magnification\&.
.RE
.LP
.nf

.B
setPrintColourMode(This, Mode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Mode = integer()
.br
.RE
.RE
.RS
.LP
Modify colours when printing for clearer printed text\&.
.LP
The input should be one of the ?wxSTC_PRINT_* constants\&.
.RE
.LP
.nf

.B
getPrintColourMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the print colour mode\&.
.LP
The return value will be one of the ?wxSTC_PRINT_* constants\&.
.RE
.LP
.nf

.B
findText(This, MinPos, MaxPos, Text) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MinPos = MaxPos = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
findText(This, MinPos, MaxPos, Text, Options :: [Option]) ->
.B
            integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
MinPos = MaxPos = integer()
.br
Text = unicode:chardata()
.br
Option = {flags, integer()}
.br
.RE
.RE
.RS
.LP
\fI Find some text in the document\&. @param minPos The position (starting from zero) in the document at which to begin the search @param maxPos The last position (starting from zero) in the document to which the search will be restricted\&. @param text The text to search for\&. @param flags (Optional) The search flags\&. This should be a bit list containing one or more of the @link wxStyledTextCtrl::wxSTC_FIND_WHOLEWORD wxSTC_FIND_* @endlink constants\&. \fR\& 
.LP
Return: The position (starting from zero) in the document at which the text was found or wxSTC_INVALID_POSITION if the search fails\&.
.LP
Remark: A backwards search can be performed by setting minPos to be greater than maxPos\&.
.RE
.LP
.nf

.B
formatRange(This, DoDraw, StartPos, EndPos, Draw, Target,
.B
            RenderRect, PageRect) ->
.B
               integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
DoDraw = boolean()
.br
StartPos = EndPos = integer()
.br
Draw = Target = wxDC:wxDC()
.br
RenderRect = PageRect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
.RE
.RE
.RS
.LP
On Windows, will draw the document into a display context such as a printer\&.
.RE
.LP
.nf

.B
getFirstVisibleLine(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the display line at the top of the display\&.
.RE
.LP
.nf

.B
getLine(This, Line) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the contents of a line\&.
.RE
.LP
.nf

.B
getLineCount(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the number of lines in the document\&.
.LP
There is always at least one\&.
.RE
.LP
.nf

.B
setMarginLeft(This, PixelWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PixelWidth = integer()
.br
.RE
.RE
.RS
.LP
Sets the size in pixels of the left margin\&.
.RE
.LP
.nf

.B
getMarginLeft(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the size in pixels of the left margin\&.
.RE
.LP
.nf

.B
setMarginRight(This, PixelWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PixelWidth = integer()
.br
.RE
.RE
.RS
.LP
Sets the size in pixels of the right margin\&.
.RE
.LP
.nf

.B
getMarginRight(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the size in pixels of the right margin\&.
.RE
.LP
.nf

.B
getModify(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is the document different from when it was last saved?
.RE
.LP
.nf

.B
setSelection(This, From, To) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
From = To = integer()
.br
.RE
.RE
.RS
.LP
Selects the text starting at the first position up to (but not including) the character at the last position\&.
.LP
If both parameters are equal to -1 all text in the control is selected\&.
.LP
Notice that the insertion point will be moved to \fIfrom\fR\& by this function\&.
.LP
See: \fIselectAll/1\fR\& 
.RE
.LP
.nf

.B
getSelectedText(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the selected text\&.
.RE
.LP
.nf

.B
getTextRange(This, StartPos, EndPos) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
StartPos = EndPos = integer()
.br
.RE
.RE
.RS
.LP
Retrieve a range of text\&.
.RE
.LP
.nf

.B
hideSelection(This, Hide) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Hide = boolean()
.br
.RE
.RE
.RS
.LP
Draw the selection in normal style or with selection highlighted\&.
.RE
.LP
.nf

.B
lineFromPosition(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the line containing a position\&.
.RE
.LP
.nf

.B
positionFromLine(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the position at the start of a line\&.
.RE
.LP
.nf

.B
lineScroll(This, Columns, Lines) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Columns = Lines = integer()
.br
.RE
.RE
.RS
.LP
Scroll horizontally and vertically\&.
.RE
.LP
.nf

.B
ensureCaretVisible(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Ensure the caret is visible\&.
.RE
.LP
.nf

.B
replaceSelection(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Replace the selected text with the argument text\&.
.RE
.LP
.nf

.B
setReadOnly(This, ReadOnly) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
ReadOnly = boolean()
.br
.RE
.RE
.RS
.LP
Set to read only or read write\&.
.RE
.LP
.nf

.B
canPaste(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Will a paste succeed?
.RE
.LP
.nf

.B
canUndo(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Are there any undoable actions in the undo history?
.RE
.LP
.nf

.B
emptyUndoBuffer(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete the undo history\&.
.RE
.LP
.nf

.B
undo(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Undo one action in the undo history\&.
.RE
.LP
.nf

.B
cut(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Cut the selection to the clipboard\&.
.RE
.LP
.nf

.B
copy(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Copy the selection to the clipboard\&.
.RE
.LP
.nf

.B
paste(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Paste the contents of the clipboard into the document replacing the selection\&.
.RE
.LP
.nf

.B
clear(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Clear the selection\&.
.RE
.LP
.nf

.B
setText(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Replace the contents of the document with the argument text\&.
.RE
.LP
.nf

.B
getText(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve all the text in the document\&.
.RE
.LP
.nf

.B
getTextLength(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the number of characters in the document\&.
.RE
.LP
.nf

.B
getOvertype(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns true if overtype mode is active otherwise false is returned\&.
.RE
.LP
.nf

.B
setCaretWidth(This, PixelWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PixelWidth = integer()
.br
.RE
.RE
.RS
.LP
Set the width of the insert mode caret\&.
.RE
.LP
.nf

.B
getCaretWidth(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the width of the insert mode caret\&.
.RE
.LP
.nf

.B
setTargetStart(This, Start) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Start = integer()
.br
.RE
.RE
.RS
.LP
Sets the position that starts the target which is used for updating the document without affecting the scroll position\&.
.RE
.LP
.nf

.B
getTargetStart(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the position that starts the target\&.
.RE
.LP
.nf

.B
setTargetEnd(This, End) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
End = integer()
.br
.RE
.RE
.RS
.LP
Sets the position that ends the target which is used for updating the document without affecting the scroll position\&.
.RE
.LP
.nf

.B
getTargetEnd(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the position that ends the target\&.
.RE
.LP
.nf

.B
replaceTarget(This, Text) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Replace the target text with the argument text\&.
.LP
Text is counted so it can contain NULs\&. Returns the length of the replacement text\&.
.RE
.LP
.nf

.B
searchInTarget(This, Text) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Search for a counted string in the target and set the target to the found range\&.
.LP
Text is counted so it can contain NULs\&. Returns length of range or -1 for failure in which case target is not moved\&.
.RE
.LP
.nf

.B
setSearchFlags(This, SearchFlags) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SearchFlags = integer()
.br
.RE
.RE
.RS
.LP
Set the search flags used by SearchInTarget\&.
.LP
The input should be a bit list containing one or more of the ?wxSTC_FIND_* constants\&.
.RE
.LP
.nf

.B
getSearchFlags(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the search flags used by SearchInTarget\&.
.LP
The return value will be a bit list containing one or more of the ?wxSTC_FIND_* constants\&.
.RE
.LP
.nf

.B
callTipShow(This, Pos, Definition) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
Definition = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Show a call tip containing a definition near position pos\&.
.RE
.LP
.nf

.B
callTipCancel(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Remove the call tip from the screen\&.
.RE
.LP
.nf

.B
callTipActive(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is there an active call tip?
.RE
.LP
.nf

.B
callTipPosAtStart(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the position where the caret was before displaying the call tip\&.
.LP
Since: 3\&.1\&.0
.RE
.LP
.nf

.B
callTipSetHighlight(This, HighlightStart, HighlightEnd) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
HighlightStart = HighlightEnd = integer()
.br
.RE
.RE
.RS
.LP
Highlight a segment of the definition\&.
.RE
.LP
.nf

.B
callTipSetBackground(This, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the background colour for the call tip\&.
.RE
.LP
.nf

.B
callTipSetForeground(This, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour for the call tip\&.
.RE
.LP
.nf

.B
callTipSetForegroundHighlight(This, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the foreground colour for the highlighted part of the call tip\&.
.RE
.LP
.nf

.B
callTipUseStyle(This, TabSize) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
TabSize = integer()
.br
.RE
.RE
.RS
.LP
Enable use of wxSTC_STYLE_CALLTIP and set call tip tab size in pixels\&.
.RE
.LP
.nf

.B
visibleFromDocLine(This, DocLine) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
DocLine = integer()
.br
.RE
.RE
.RS
.LP
Find the display line of a document line taking hidden lines into account\&.
.RE
.LP
.nf

.B
docLineFromVisible(This, DisplayLine) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
DisplayLine = integer()
.br
.RE
.RE
.RS
.LP
Find the document line of a display line taking hidden lines into account\&.
.RE
.LP
.nf

.B
wrapCount(This, DocLine) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
DocLine = integer()
.br
.RE
.RE
.RS
.LP
The number of display lines needed to wrap a document line\&.
.RE
.LP
.nf

.B
setFoldLevel(This, Line, Level) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = Level = integer()
.br
.RE
.RE
.RS
.LP
Set the fold level of a line\&.
.LP
This encodes an integer level along with flags indicating whether the line is a header and whether it is effectively white space\&.
.RE
.LP
.nf

.B
getFoldLevel(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the fold level of a line\&.
.RE
.LP
.nf

.B
getLastChild(This, Line, Level) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = Level = integer()
.br
.RE
.RE
.RS
.LP
Find the last child line of a header line\&.
.RE
.LP
.nf

.B
getFoldParent(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Find the parent line of a child line\&.
.RE
.LP
.nf

.B
showLines(This, LineStart, LineEnd) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
LineStart = LineEnd = integer()
.br
.RE
.RE
.RS
.LP
Make a range of lines visible\&.
.RE
.LP
.nf

.B
hideLines(This, LineStart, LineEnd) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
LineStart = LineEnd = integer()
.br
.RE
.RE
.RS
.LP
Make a range of lines invisible\&.
.RE
.LP
.nf

.B
getLineVisible(This, Line) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Is a line visible?
.RE
.LP
.nf

.B
setFoldExpanded(This, Line, Expanded) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
Expanded = boolean()
.br
.RE
.RE
.RS
.LP
Show the children of a header line\&.
.RE
.LP
.nf

.B
getFoldExpanded(This, Line) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Is a header line expanded?
.RE
.LP
.nf

.B
toggleFold(This, Line) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Switch a header line between expanded and contracted\&.
.RE
.LP
.nf

.B
ensureVisible(This, Line) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Ensure a particular line is visible by expanding any header line hiding it\&.
.RE
.LP
.nf

.B
setFoldFlags(This, Flags) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Flags = integer()
.br
.RE
.RE
.RS
.LP
Set some style options for folding\&.
.LP
The second argument should be a bit list containing one or more of the ?wxSTC_FOLDFLAG_* constants\&.
.RE
.LP
.nf

.B
ensureVisibleEnforcePolicy(This, Line) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Ensure a particular line is visible by expanding any header line hiding it\&.
.LP
Use the currently set visibility policy to determine which range to display\&.
.RE
.LP
.nf

.B
setTabIndents(This, TabIndents) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
TabIndents = boolean()
.br
.RE
.RE
.RS
.LP
Sets whether a tab pressed when caret is within indentation indents\&.
.RE
.LP
.nf

.B
getTabIndents(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Does a tab pressed when caret is within indentation indent?
.RE
.LP
.nf

.B
setBackSpaceUnIndents(This, BsUnIndents) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
BsUnIndents = boolean()
.br
.RE
.RE
.RS
.LP
Sets whether a backspace pressed when caret is within indentation unindents\&.
.RE
.LP
.nf

.B
getBackSpaceUnIndents(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Does a backspace pressed when caret is within indentation unindent?
.RE
.LP
.nf

.B
setMouseDwellTime(This, PeriodMilliseconds) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PeriodMilliseconds = integer()
.br
.RE
.RE
.RS
.LP
Sets the time the mouse must sit still to generate a mouse dwell event\&.
.LP
The input should be a time in milliseconds or wxSTC_TIME_FOREVER\&.
.RE
.LP
.nf

.B
getMouseDwellTime(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the time the mouse must sit still to generate a mouse dwell event\&.
.LP
The return value will be a time in milliseconds or wxSTC_TIME_FOREVER\&.
.RE
.LP
.nf

.B
wordStartPosition(This, Pos, OnlyWordCharacters) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
OnlyWordCharacters = boolean()
.br
.RE
.RE
.RS
.LP
Get position of start of word\&.
.RE
.LP
.nf

.B
wordEndPosition(This, Pos, OnlyWordCharacters) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
OnlyWordCharacters = boolean()
.br
.RE
.RE
.RS
.LP
Get position of end of word\&.
.RE
.LP
.nf

.B
setWrapMode(This, WrapMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
WrapMode = integer()
.br
.RE
.RE
.RS
.LP
Sets whether text is word wrapped\&.
.LP
The input should be one of the ?wxSTC_WRAP_* constants\&.
.RE
.LP
.nf

.B
getWrapMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether text is word wrapped\&.
.LP
The return value will be one of the ?wxSTC_WRAP_* constants\&.
.RE
.LP
.nf

.B
setWrapVisualFlags(This, WrapVisualFlags) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
WrapVisualFlags = integer()
.br
.RE
.RE
.RS
.LP
Set the display mode of visual flags for wrapped lines\&.
.LP
The input should be a bit list containing one or more of the ?wxSTC_WRAPVISUALFLAG_* constants\&.
.RE
.LP
.nf

.B
getWrapVisualFlags(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the display mode of visual flags for wrapped lines\&.
.LP
The return value will be a bit list containing one or more of the ?wxSTC_WRAPVISUALFLAG_* constants\&.
.RE
.LP
.nf

.B
setWrapVisualFlagsLocation(This, WrapVisualFlagsLocation) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
WrapVisualFlagsLocation = integer()
.br
.RE
.RE
.RS
.LP
Set the location of visual flags for wrapped lines\&.
.LP
The input should be a bit list containing one or more of the ?wxSTC_WRAPVISUALFLAGLOC_* constants\&.
.RE
.LP
.nf

.B
getWrapVisualFlagsLocation(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the location of visual flags for wrapped lines\&.
.LP
The return value will be a bit list containing one or more of the ?wxSTC_WRAPVISUALFLAGLOC_* constants\&.
.RE
.LP
.nf

.B
setWrapStartIndent(This, Indent) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Indent = integer()
.br
.RE
.RE
.RS
.LP
Set the start indent for wrapped lines\&.
.RE
.LP
.nf

.B
getWrapStartIndent(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the start indent for wrapped lines\&.
.RE
.LP
.nf

.B
setLayoutCache(This, CacheMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CacheMode = integer()
.br
.RE
.RE
.RS
.LP
Sets the degree of caching of layout information\&.
.LP
The input should be one of the ?wxSTC_CACHE_* constants\&.
.RE
.LP
.nf

.B
getLayoutCache(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the degree of caching of layout information\&.
.LP
The return value will be one of the ?wxSTC_CACHE_* constants\&.
.RE
.LP
.nf

.B
setScrollWidth(This, PixelWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PixelWidth = integer()
.br
.RE
.RE
.RS
.LP
Sets the document width assumed for scrolling\&.
.RE
.LP
.nf

.B
getScrollWidth(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the document width assumed for scrolling\&.
.RE
.LP
.nf

.B
textWidth(This, Style, Text) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Measure the pixel width of some text in a particular style\&.
.LP
Does not handle tab or control characters\&.
.RE
.LP
.nf

.B
getEndAtLastLine(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve whether the maximum scroll position has the last line at the bottom of the view\&.
.RE
.LP
.nf

.B
textHeight(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the height of a particular line of text in pixels\&.
.RE
.LP
.nf

.B
setUseVerticalScrollBar(This, Visible) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Visible = boolean()
.br
.RE
.RE
.RS
.LP
Show or hide the vertical scroll bar\&.
.RE
.LP
.nf

.B
getUseVerticalScrollBar(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is the vertical scroll bar visible?
.RE
.LP
.nf

.B
appendText(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Append a string to the end of the document without changing the selection\&.
.RE
.LP
.nf

.B
getTwoPhaseDraw(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is drawing done in two phases with backgrounds drawn before foregrounds?
.RE
.LP
.nf

.B
setTwoPhaseDraw(This, TwoPhase) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
TwoPhase = boolean()
.br
.RE
.RE
.RS
.LP
In twoPhaseDraw mode, drawing is performed in two phases, first the background and then the foreground\&.
.LP
This avoids chopping off characters that overlap the next run\&.
.RE
.LP
.nf

.B
targetFromSelection(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Make the target range start and end be the same as the selection range start and end\&.
.RE
.LP
.nf

.B
linesJoin(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Join the lines in the target\&.
.RE
.LP
.nf

.B
linesSplit(This, PixelWidth) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PixelWidth = integer()
.br
.RE
.RE
.RS
.LP
Split the lines in the target into lines that are less wide than pixelWidth where possible\&.
.RE
.LP
.nf

.B
setFoldMarginColour(This, UseSetting, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set one of the colours used as a chequerboard pattern in the fold margin\&.
.RE
.LP
.nf

.B
setFoldMarginHiColour(This, UseSetting, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set the other colour used as a chequerboard pattern in the fold margin\&.
.RE
.LP
.nf

.B
lineDown(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret down one line\&.
.RE
.LP
.nf

.B
lineDownExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret down one line extending selection to new caret position\&.
.RE
.LP
.nf

.B
lineUp(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret up one line\&.
.RE
.LP
.nf

.B
lineUpExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret up one line extending selection to new caret position\&.
.RE
.LP
.nf

.B
charLeft(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one character\&.
.RE
.LP
.nf

.B
charLeftExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one character extending selection to new caret position\&.
.RE
.LP
.nf

.B
charRight(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one character\&.
.RE
.LP
.nf

.B
charRightExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one character extending selection to new caret position\&.
.RE
.LP
.nf

.B
wordLeft(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one word\&.
.RE
.LP
.nf

.B
wordLeftExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one word extending selection to new caret position\&.
.RE
.LP
.nf

.B
wordRight(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one word\&.
.RE
.LP
.nf

.B
wordRightExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one word extending selection to new caret position\&.
.RE
.LP
.nf

.B
home(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position on line\&.
.RE
.LP
.nf

.B
homeExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position on line extending selection to new caret position\&.
.RE
.LP
.nf

.B
lineEnd(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position on line\&.
.RE
.LP
.nf

.B
lineEndExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position on line extending selection to new caret position\&.
.RE
.LP
.nf

.B
documentStart(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position in document\&.
.RE
.LP
.nf

.B
documentStartExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position in document extending selection to new caret position\&.
.RE
.LP
.nf

.B
documentEnd(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position in document\&.
.RE
.LP
.nf

.B
documentEndExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position in document extending selection to new caret position\&.
.RE
.LP
.nf

.B
pageUp(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret one page up\&.
.RE
.LP
.nf

.B
pageUpExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret one page up extending selection to new caret position\&.
.RE
.LP
.nf

.B
pageDown(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret one page down\&.
.RE
.LP
.nf

.B
pageDownExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret one page down extending selection to new caret position\&.
.RE
.LP
.nf

.B
editToggleOvertype(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Switch from insert to overtype mode or the reverse\&.
.RE
.LP
.nf

.B
cancel(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Cancel any modes such as call tip or auto-completion list display\&.
.RE
.LP
.nf

.B
deleteBack(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete the selection or if no selection, the character before the caret\&.
.RE
.LP
.nf

.B
tab(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
If selection is empty or all on one line replace the selection with a tab character\&.
.LP
If more than one line selected, indent the lines\&.
.RE
.LP
.nf

.B
backTab(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Dedent the selected lines\&.
.RE
.LP
.nf

.B
newLine(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Insert a new line, may use a CRLF, CR or LF depending on EOL mode\&.
.RE
.LP
.nf

.B
formFeed(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Insert a Form Feed character\&.
.RE
.LP
.nf

.B
vCHome(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to before first visible character on line\&.
.LP
If already there move to first character on line\&.
.RE
.LP
.nf

.B
vCHomeExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Like VCHome but extending selection to new caret position\&.
.RE
.LP
.nf

.B
zoomIn(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Magnify the displayed text by increasing the sizes by 1 point\&.
.RE
.LP
.nf

.B
zoomOut(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Make the displayed text smaller by decreasing the sizes by 1 point\&.
.RE
.LP
.nf

.B
delWordLeft(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete the word to the left of the caret\&.
.RE
.LP
.nf

.B
delWordRight(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete the word to the right of the caret\&.
.RE
.LP
.nf

.B
lineCut(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Cut the line containing the caret\&.
.RE
.LP
.nf

.B
lineDelete(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete the line containing the caret\&.
.RE
.LP
.nf

.B
lineTranspose(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Switch the current line with the previous\&.
.RE
.LP
.nf

.B
lineDuplicate(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Duplicate the current line\&.
.RE
.LP
.nf

.B
lowerCase(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Transform the selection to lower case\&.
.RE
.LP
.nf

.B
upperCase(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Transform the selection to upper case\&.
.RE
.LP
.nf

.B
lineScrollDown(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Scroll the document down, keeping the caret visible\&.
.RE
.LP
.nf

.B
lineScrollUp(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Scroll the document up, keeping the caret visible\&.
.RE
.LP
.nf

.B
deleteBackNotLine(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete the selection or if no selection, the character before the caret\&.
.LP
Will not delete the character before at the start of a line\&.
.RE
.LP
.nf

.B
homeDisplay(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position on display line\&.
.RE
.LP
.nf

.B
homeDisplayExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position on display line extending selection to new caret position\&.
.RE
.LP
.nf

.B
lineEndDisplay(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position on display line\&.
.RE
.LP
.nf

.B
lineEndDisplayExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position on display line extending selection to new caret position\&.
.RE
.LP
.nf

.B
homeWrapExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Like HomeExtend but when word-wrap is enabled extends first to start of display line HomeDisplayExtend, then to start of document line HomeExtend\&.
.RE
.LP
.nf

.B
lineEndWrap(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Like LineEnd but when word-wrap is enabled goes first to end of display line LineEndDisplay, then to start of document line LineEnd\&.
.RE
.LP
.nf

.B
lineEndWrapExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Like LineEndExtend but when word-wrap is enabled extends first to end of display line LineEndDisplayExtend, then to start of document line LineEndExtend\&.
.RE
.LP
.nf

.B
vCHomeWrap(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Like VCHome but when word-wrap is enabled goes first to start of display line VCHomeDisplay, then behaves like VCHome\&.
.RE
.LP
.nf

.B
vCHomeWrapExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Like VCHomeExtend but when word-wrap is enabled extends first to start of display line VCHomeDisplayExtend, then behaves like VCHomeExtend\&.
.RE
.LP
.nf

.B
lineCopy(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Copy the line containing the caret\&.
.RE
.LP
.nf

.B
moveCaretInsideView(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move the caret inside current view if it\&'s not there already\&.
.RE
.LP
.nf

.B
lineLength(This, Line) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
How many characters are on a line, including end of line characters?
.RE
.LP
.nf

.B
braceHighlight(This, PosA, PosB) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PosA = PosB = integer()
.br
.RE
.RE
.RS
.LP
Highlight the characters at two positions\&.
.RE
.LP
.nf

.B
braceBadLight(This, Pos) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Highlight the character at a position indicating there is no matching brace\&.
.RE
.LP
.nf

.B
braceMatch(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Find the position of a matching brace or wxSTC_INVALID_POSITION if no match\&.
.RE
.LP
.nf

.B
getViewEOL(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Are the end of line characters visible?
.RE
.LP
.nf

.B
setViewEOL(This, Visible) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Visible = boolean()
.br
.RE
.RE
.RS
.LP
Make the end of line characters visible or invisible\&.
.RE
.LP
.nf

.B
setModEventMask(This, EventMask) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
EventMask = integer()
.br
.RE
.RE
.RS
.LP
Set which document modification events are sent to the container\&.
.LP
The input should be a bit list containing one or more of the ?wxSTC_MOD_* constants, the ?wxSTC_PERFORMED_* constants, wxSTC_STARTACTION, wxSTC_MULTILINEUNDOREDO, wxSTC_MULTISTEPUNDOREDO, and wxSTC_LASTSTEPINUNDOREDO\&. The input can also be wxSTC_MODEVENTMASKALL to indicate that all changes should generate events\&.
.RE
.LP
.nf

.B
getEdgeColumn(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the column number which text should be kept within\&.
.RE
.LP
.nf

.B
setEdgeColumn(This, Column) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Column = integer()
.br
.RE
.RE
.RS
.LP
Set the column number of the edge\&.
.LP
If text goes past the edge then it is highlighted\&.
.RE
.LP
.nf

.B
setEdgeMode(This, EdgeMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
EdgeMode = integer()
.br
.RE
.RE
.RS
.LP
The edge may be displayed by a line (wxSTC_EDGE_LINE/wxSTC_EDGE_MULTILINE) or by highlighting text that goes beyond it (wxSTC_EDGE_BACKGROUND) or not displayed at all (wxSTC_EDGE_NONE)\&.
.LP
The input should be one of the ?wxSTC_EDGE_* constants\&.
.RE
.LP
.nf

.B
getEdgeMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the edge highlight mode\&.
.LP
The return value will be one of the ?wxSTC_EDGE_* constants\&.
.RE
.LP
.nf

.B
getEdgeColour(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the colour used in edge indication\&.
.RE
.LP
.nf

.B
setEdgeColour(This, EdgeColour) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
EdgeColour = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Change the colour used in edge indication\&.
.RE
.LP
.nf

.B
searchAnchor(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Sets the current caret position to be the search anchor\&.
.RE
.LP
.nf

.B
searchNext(This, SearchFlags, Text) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SearchFlags = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Find some text starting at the search anchor\&.
.LP
Does not ensure the selection is visible\&.
.RE
.LP
.nf

.B
searchPrev(This, SearchFlags, Text) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SearchFlags = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Find some text starting at the search anchor and moving backwards\&.
.LP
Does not ensure the selection is visible\&.
.RE
.LP
.nf

.B
linesOnScreen(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieves the number of lines completely visible\&.
.RE
.LP
.nf

.B
usePopUp(This, PopUpMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
PopUpMode = integer()
.br
.RE
.RE
.RS
.LP
Set whether a pop up menu is displayed automatically when the user presses the wrong mouse button on certain areas\&.
.LP
The input should be one of the ?wxSTC_POPUP_* constants\&.
.LP
Remark: When \fIwxContextMenuEvent\fR\& is used to create a custom popup menu, this function should be called with wxSTC_POPUP_NEVER\&. Otherwise the default menu will be shown instead of the custom one\&.
.RE
.LP
.nf

.B
selectionIsRectangle(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is the selection rectangular? The alternative is the more common stream selection\&.
.RE
.LP
.nf

.B
setZoom(This, ZoomInPoints) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
ZoomInPoints = integer()
.br
.RE
.RE
.RS
.LP
Set the zoom level\&.
.LP
This number of points is added to the size of all fonts\&. It may be positive to magnify or negative to reduce\&.
.RE
.LP
.nf

.B
getZoom(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the zoom level\&.
.RE
.LP
.nf

.B
getModEventMask(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get which document modification events are sent to the container\&.
.LP
The return value will wxSTC_MODEVENTMASKALL if all changes generate events\&. Otherwise it will be a bit list containing one or more of the ?wxSTC_MOD_* constants, the ?wxSTC_PERFORMED_* constants, wxSTC_STARTACTION, wxSTC_MULTILINEUNDOREDO, wxSTC_MULTISTEPUNDOREDO, and wxSTC_LASTSTEPINUNDOREDO\&.
.RE
.LP
.nf

.B
setSTCFocus(This, Focus) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Focus = boolean()
.br
.RE
.RE
.RS
.LP
Change internal focus flag\&.
.RE
.LP
.nf

.B
getSTCFocus(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get internal focus flag\&.
.RE
.LP
.nf

.B
setStatus(This, Status) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Status = integer()
.br
.RE
.RE
.RS
.LP
Change error status - 0 = OK\&.
.LP
The input should be one of the ?wxSTC_STATUS_* constants\&.
.RE
.LP
.nf

.B
getStatus(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get error status\&.
.LP
The return value will be one of the ?wxSTC_STATUS_* constants\&.
.RE
.LP
.nf

.B
setMouseDownCaptures(This, Captures) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Captures = boolean()
.br
.RE
.RE
.RS
.LP
Set whether the mouse is captured when its button is pressed\&.
.RE
.LP
.nf

.B
getMouseDownCaptures(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get whether mouse gets captured\&.
.RE
.LP
.nf

.B
setSTCCursor(This, CursorType) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CursorType = integer()
.br
.RE
.RE
.RS
.LP
Sets the cursor to one of the wxSTC_CURSOR* values\&.
.RE
.LP
.nf

.B
getSTCCursor(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get cursor type\&.
.LP
The return value will be one of the ?wxSTC_CURSOR* constants\&.
.RE
.LP
.nf

.B
setControlCharSymbol(This, Symbol) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Symbol = integer()
.br
.RE
.RE
.RS
.LP
Change the way control characters are displayed: If symbol is < 32, keep the drawn way, else, use the given character\&.
.RE
.LP
.nf

.B
getControlCharSymbol(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the way control characters are displayed\&.
.RE
.LP
.nf

.B
wordPartLeft(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move to the previous change in capitalisation\&.
.RE
.LP
.nf

.B
wordPartLeftExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move to the previous change in capitalisation extending selection to new caret position\&.
.RE
.LP
.nf

.B
wordPartRight(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move to the change next in capitalisation\&.
.RE
.LP
.nf

.B
wordPartRightExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move to the next change in capitalisation extending selection to new caret position\&.
.RE
.LP
.nf

.B
setVisiblePolicy(This, VisiblePolicy, VisibleSlop) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
VisiblePolicy = VisibleSlop = integer()
.br
.RE
.RE
.RS
.LP
Set the way the display area is determined when a particular line is to be moved to by Find, FindNext, GotoLine, etc\&.
.LP
The first argument should be a bit list containing one or more of the ?wxSTC_VISIBLE_* constants\&.
.RE
.LP
.nf

.B
delLineLeft(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete back from the current position to the start of the line\&.
.RE
.LP
.nf

.B
delLineRight(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Delete forwards from the current position to the end of the line\&.
.RE
.LP
.nf

.B
getXOffset(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the xOffset (ie, horizontal scroll position)\&.
.RE
.LP
.nf

.B
chooseCaretX(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Set the last x chosen value to be the caret x position\&.
.RE
.LP
.nf

.B
setXCaretPolicy(This, CaretPolicy, CaretSlop) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CaretPolicy = CaretSlop = integer()
.br
.RE
.RE
.RS
.LP
Set the way the caret is kept visible when going sideways\&.
.LP
The exclusion zone is given in pixels\&.
.LP
The first argument should be a bit list containing one or more of the ?wxSTC_CARET_* constants\&.
.RE
.LP
.nf

.B
setYCaretPolicy(This, CaretPolicy, CaretSlop) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
CaretPolicy = CaretSlop = integer()
.br
.RE
.RE
.RS
.LP
Set the way the line the caret is on is kept visible\&.
.LP
The exclusion zone is given in lines\&.
.LP
The first argument should be a bit list containing one or more of the ?wxSTC_CARET_* constants\&.
.RE
.LP
.nf

.B
getPrintWrapMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Is printing line wrapped?
.LP
The return value will be one of the ?wxSTC_WRAP_* constants\&.
.RE
.LP
.nf

.B
setHotspotActiveForeground(This, UseSetting, Fore) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Fore = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set a fore colour for active hotspots\&.
.RE
.LP
.nf

.B
setHotspotActiveBackground(This, UseSetting, Back) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseSetting = boolean()
.br
Back = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Set a back colour for active hotspots\&.
.RE
.LP
.nf

.B
setHotspotActiveUnderline(This, Underline) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Underline = boolean()
.br
.RE
.RE
.RS
.LP
Enable / Disable underlining active hotspots\&.
.RE
.LP
.nf

.B
setHotspotSingleLine(This, SingleLine) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SingleLine = boolean()
.br
.RE
.RE
.RS
.LP
Limit hotspots to single line so hotspots on two lines don\&'t merge\&.
.RE
.LP
.nf

.B
paraDownExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Extend selection down one paragraph (delimited by empty lines)\&.
.RE
.LP
.nf

.B
paraUp(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret up one paragraph (delimited by empty lines)\&.
.RE
.LP
.nf

.B
paraUpExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Extend selection up one paragraph (delimited by empty lines)\&.
.RE
.LP
.nf

.B
positionBefore(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Given a valid document position, return the previous position taking code page into account\&.
.LP
Returns 0 if passed 0\&.
.RE
.LP
.nf

.B
positionAfter(This, Pos) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Given a valid document position, return the next position taking code page into account\&.
.LP
Maximum value returned is the last position in the document\&.
.RE
.LP
.nf

.B
copyRange(This, Start, End) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Start = End = integer()
.br
.RE
.RE
.RS
.LP
Copy a range of text to the clipboard\&.
.LP
Positions are clipped into the document\&.
.RE
.LP
.nf

.B
copyText(This, Length, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Length = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Copy argument text to the clipboard\&.
.RE
.LP
.nf

.B
setSelectionMode(This, SelectionMode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
SelectionMode = integer()
.br
.RE
.RE
.RS
.LP
Set the selection mode to stream (wxSTC_SEL_STREAM) or rectangular (wxSTC_SEL_RECTANGLE/wxSTC_SEL_THIN) or by lines (wxSTC_SEL_LINES)\&.
.RE
.LP
.nf

.B
getSelectionMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the mode of the current selection\&.
.LP
The return value will be one of the ?wxSTC_SEL_* constants\&.
.RE
.LP
.nf

.B
lineDownRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret down one line, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
lineUpRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret up one line, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
charLeftRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one character, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
charRightRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one character, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
homeRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to first position on line, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
vCHomeRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to before first visible character on line\&.
.LP
If already there move to first character on line\&. In either case, extend rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
lineEndRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to last position on line, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
pageUpRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret one page up, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
pageDownRectExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret one page down, extending rectangular selection to new caret position\&.
.RE
.LP
.nf

.B
stutteredPageUp(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to top of page, or one page up if already at top of page\&.
.RE
.LP
.nf

.B
stutteredPageUpExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to top of page, or one page up if already at top of page, extending selection to new caret position\&.
.RE
.LP
.nf

.B
stutteredPageDown(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to bottom of page, or one page down if already at bottom of page\&.
.RE
.LP
.nf

.B
stutteredPageDownExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position\&.
.RE
.LP
.nf

.B
wordLeftEnd(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one word, position cursor at end of word\&.
.RE
.LP
.nf

.B
wordLeftEndExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret left one word, position cursor at end of word, extending selection to new caret position\&.
.RE
.LP
.nf

.B
wordRightEnd(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one word, position cursor at end of word\&.
.RE
.LP
.nf

.B
wordRightEndExtend(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Move caret right one word, position cursor at end of word, extending selection to new caret position\&.
.RE
.LP
.nf

.B
setWhitespaceChars(This, Characters) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Characters = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Set the set of characters making up whitespace for when moving or selecting by word\&.
.LP
Should be called after SetWordChars\&.
.RE
.LP
.nf

.B
setCharsDefault(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Reset the set of characters for whitespace and word characters to the defaults\&.
.RE
.LP
.nf

.B
autoCompGetCurrent(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get currently selected item position in the auto-completion list\&.
.RE
.LP
.nf

.B
allocate(This, Bytes) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Bytes = integer()
.br
.RE
.RE
.RS
.LP
Enlarge the document to a particular size of text bytes\&.
.RE
.LP
.nf

.B
findColumn(This, Line, Column) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = Column = integer()
.br
.RE
.RE
.RS
.LP
Find the position of a column on a line taking into account tabs and multi-byte characters\&.
.LP
If beyond end of line, return line end position\&.
.RE
.LP
.nf

.B
getCaretSticky(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Can the caret preferred x position only be changed by explicit movement commands?
.LP
The return value will be one of the ?wxSTC_CARETSTICKY_* constants\&.
.RE
.LP
.nf

.B
setCaretSticky(This, UseCaretStickyBehaviour) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
UseCaretStickyBehaviour = integer()
.br
.RE
.RE
.RS
.LP
Stop the caret preferred x position changing when the user types\&.
.LP
The input should be one of the ?wxSTC_CARETSTICKY_* constants\&.
.RE
.LP
.nf

.B
toggleCaretSticky(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Switch between sticky and non-sticky: meant to be bound to a key\&.
.RE
.LP
.nf

.B
setPasteConvertEndings(This, Convert) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Convert = boolean()
.br
.RE
.RE
.RS
.LP
Enable/Disable convert-on-paste for line endings\&.
.RE
.LP
.nf

.B
getPasteConvertEndings(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get convert-on-paste setting\&.
.RE
.LP
.nf

.B
selectionDuplicate(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Duplicate the selection\&.
.LP
If selection empty duplicate the line containing the caret\&.
.RE
.LP
.nf

.B
setCaretLineBackAlpha(This, Alpha) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Alpha = integer()
.br
.RE
.RE
.RS
.LP
Set background alpha of the caret line\&.
.RE
.LP
.nf

.B
getCaretLineBackAlpha(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Get the background alpha of the caret line\&.
.RE
.LP
.nf

.B
startRecord(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Start notifying the container of all key presses and commands\&.
.RE
.LP
.nf

.B
stopRecord(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Stop notifying the container of all key presses and commands\&.
.RE
.LP
.nf

.B
setLexer(This, Lexer) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Lexer = integer()
.br
.RE
.RE
.RS
.LP
Set the lexing language of the document\&.
.LP
The input should be one of the ?wxSTC_LEX_* constants\&.
.RE
.LP
.nf

.B
getLexer(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the lexing language of the document\&.
.LP
The return value will be one of the ?wxSTC_LEX_* constants\&.
.RE
.LP
.nf

.B
colourise(This, Start, End) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Start = End = integer()
.br
.RE
.RE
.RS
.LP
Colourise a segment of the document using the current lexing language\&.
.RE
.LP
.nf

.B
setProperty(This, Key, Value) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Key = Value = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Set up a value that may be used by a lexer for some optional feature\&.
.RE
.LP
.nf

.B
setKeyWords(This, KeyWordSet, KeyWords) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
KeyWordSet = integer()
.br
KeyWords = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Set up the key words used by the lexer\&.
.RE
.LP
.nf

.B
setLexerLanguage(This, Language) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Language = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Set the lexing language of the document based on string name\&.
.RE
.LP
.nf

.B
getProperty(This, Key) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Key = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Retrieve a "property" value previously set with SetProperty\&.
.RE
.LP
.nf

.B
getStyleBitsNeeded(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the number of bits the current lexer needs for styling\&.
.LP
Deprecated:
.RE
.LP
.nf

.B
getCurrentLine(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the line number of the line with the caret\&.
.RE
.LP
.nf

.B
styleSetSpec(This, StyleNum, Spec) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
StyleNum = integer()
.br
Spec = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Extract style settings from a spec-string which is composed of one or more of the following comma separated elements:
.LP
bold turns on bold italic turns on italics fore:[name or #RRGGBB] sets the foreground colour back:[name or #RRGGBB] sets the background colour face:[facename] sets the font face name to use size:[num] sets the font size in points eol turns on eol filling underline turns on underlining
.RE
.LP
.nf

.B
styleSetFont(This, StyleNum, Font) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
StyleNum = integer()
.br
Font = wxFont:wxFont()
.br
.RE
.RE
.RS
.LP
Set style size, face, bold, italic, and underline attributes from a \fIwxFont\fR\&\&'s attributes\&.
.RE
.LP
.nf

.B
styleSetFontAttr(This, StyleNum, Size, FaceName, Bold, Italic,
.B
                 Underline) ->
.B
                    ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
StyleNum = Size = integer()
.br
FaceName = unicode:chardata()
.br
Bold = Italic = Underline = boolean()
.br
.RE
.RE
.LP
.nf

.B
styleSetFontAttr(This, StyleNum, Size, FaceName, Bold, Italic,
.B
                 Underline,
.B
                 Options :: [Option]) ->
.B
                    ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
StyleNum = Size = integer()
.br
FaceName = unicode:chardata()
.br
Bold = Italic = Underline = boolean()
.br
Option = {encoding, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
Set all font style attributes at once\&.
.RE
.LP
.nf

.B
styleSetCharacterSet(This, Style, CharacterSet) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = CharacterSet = integer()
.br
.RE
.RE
.RS
.LP
Set the character set of the font in a style\&.
.LP
Converts the Scintilla character set values to a wxFontEncoding\&.
.RE
.LP
.nf

.B
styleSetFontEncoding(This, Style, Encoding) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Style = integer()
.br
Encoding = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Set the font encoding to be used by a style\&.
.RE
.LP
.nf

.B
cmdKeyExecute(This, Cmd) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Cmd = integer()
.br
.RE
.RE
.RS
.LP
Perform one of the operations defined by the wxSTC_CMD_* constants\&.
.RE
.LP
.nf

.B
setMargins(This, Left, Right) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Left = Right = integer()
.br
.RE
.RE
.RS
.LP
Set the left and right margin in the edit area, measured in pixels\&.
.RE
.LP
.nf

.B
getSelection(This) -> {From :: integer(), To :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Gets the current selection span\&.
.LP
If the returned values are equal, there was no selection\&. Please note that the indices returned may be used with the other \fIwxTextCtrl\fR\& methods but don\&'t necessarily represent the correct indices into the string returned by \fIwxComboBox:getValue/1\fR\& for multiline controls under Windows (at least,) you should use \fIwxTextCtrl:getStringSelection/1\fR\& to get the selected text\&.
.RE
.LP
.nf

.B
pointFromPosition(This, Pos) -> {X :: integer(), Y :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the point in the window where a position is displayed\&.
.RE
.LP
.nf

.B
scrollToLine(This, Line) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Scroll enough to make the given line visible\&.
.RE
.LP
.nf

.B
scrollToColumn(This, Column) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Column = integer()
.br
.RE
.RE
.RS
.LP
Scroll enough to make the given column visible\&.
.RE
.LP
.nf

.B
setVScrollBar(This, Bar) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Bar = wxScrollBar:wxScrollBar()
.br
.RE
.RE
.RS
.LP
Set the vertical scrollbar to use instead of the one that\&'s built-in\&.
.RE
.LP
.nf

.B
setHScrollBar(This, Bar) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Bar = wxScrollBar:wxScrollBar()
.br
.RE
.RE
.RS
.LP
Set the horizontal scrollbar to use instead of the one that\&'s built-in\&.
.RE
.LP
.nf

.B
getLastKeydownProcessed(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Can be used to prevent the EVT_CHAR handler from adding the char\&.
.RE
.LP
.nf

.B
setLastKeydownProcessed(This, Val) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Val = boolean()
.br
.RE
.RE
.RS
.LP
Returns the line number of the line with the caret\&.
.RE
.LP
.nf

.B
saveFile(This, Filename) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Filename = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Write the contents of the editor to filename\&.
.RE
.LP
.nf

.B
loadFile(This, Filename) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Filename = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Load the contents of filename into the editor\&.
.RE
.LP
.nf

.B
doDragOver(This, X, Y, DefaultRes) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
X = Y = integer()
.br
DefaultRes = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Allow for simulating a DnD DragOver\&.
.RE
.LP
.nf

.B
doDropText(This, X, Y, Data) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
X = Y = integer()
.br
Data = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Allow for simulating a DnD DropText\&.
.RE
.LP
.nf

.B
getUseAntiAliasing(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Returns the current UseAntiAliasing setting\&.
.RE
.LP
.nf

.B
addTextRaw(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = binary()
.br
.RE
.RE
.LP
.nf

.B
addTextRaw(This, Text, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = binary()
.br
Option = {length, integer()}
.br
.RE
.RE
.RS
.LP
Add text to the document at current position\&.
.RE
.LP
.nf

.B
insertTextRaw(This, Pos, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Pos = integer()
.br
Text = binary()
.br
.RE
.RE
.RS
.LP
Insert string at a position\&.
.RE
.LP
.nf

.B
getCurLineRaw(This) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = {Res :: binary(), LinePos :: integer()}
.br
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the text of the line containing the caret\&.
.LP
Returns the index of the caret on the line\&.
.RE
.LP
.nf

.B
getLineRaw(This, Line) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Line = integer()
.br
.RE
.RE
.RS
.LP
Retrieve the contents of a line\&.
.RE
.LP
.nf

.B
getSelectedTextRaw(This) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve the selected text\&.
.RE
.LP
.nf

.B
getTextRangeRaw(This, StartPos, EndPos) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
StartPos = EndPos = integer()
.br
.RE
.RE
.RS
.LP
Retrieve a range of text\&.
.RE
.LP
.nf

.B
setTextRaw(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = binary()
.br
.RE
.RE
.RS
.LP
Replace the contents of the document with the argument text\&.
.RE
.LP
.nf

.B
getTextRaw(This) -> binary()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
.RE
.RE
.RS
.LP
Retrieve all the text in the document\&.
.RE
.LP
.nf

.B
appendTextRaw(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = binary()
.br
.RE
.RE
.LP
.nf

.B
appendTextRaw(This, Text, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStyledTextCtrl()
.br
Text = binary()
.br
Option = {length, integer()}
.br
.RE
.RE
.RS
.LP
Append a string to the end of the document without changing the selection\&.
.RE