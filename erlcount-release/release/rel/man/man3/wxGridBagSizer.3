.TH wxGridBagSizer 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxGridBagSizer \- Functions for wxGridBagSizer class
.SH DESCRIPTION
.LP
A \fIwxSizer\fR\& that can lay out items in a virtual grid like a \fIwxFlexGridSizer\fR\& but in this case explicit positioning of the items is allowed using \fIwxGBPosition\fR\& (not implemented in wx), and items can optionally span more than one row and/or column using \fIwxGBSpan\fR\& (not implemented in wx)\&.
.LP
This class is derived (and can use functions) from: \fIwxFlexGridSizer\fR\& \fIwxGridSizer\fR\& \fIwxSizer\fR\&
.LP
wxWidgets docs: wxGridBagSizer
.SH DATA TYPES
.nf

\fBwxGridBagSizer()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxGridBagSizer()
.br
.fi
.br
.LP
.nf

.B
new(Options :: [Option]) -> wxGridBagSizer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Option = {vgap, integer()} | {hgap, integer()}
.br
.RE
.RE
.RS
.LP
Constructor, with optional parameters to specify the gap between the rows and columns\&.
.RE
.LP
.nf

.B
add(This, Item) -> wxSizerItem:wxSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Item = wxGBSizerItem:wxGBSizerItem()
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
add(This, Window, Pos) -> wxSizerItem:wxSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Window = wxWindow:wxWindow() | wxSizer:wxSizer()
.br
Pos = {R :: integer(), C :: integer()}
.br
.RE
.RE
.LP
.nf

.B
add(This, Width, Height, Pos) -> wxSizerItem:wxSizerItem()
.br
.fi
.br
.nf

.B
add(This, Window, Pos, Pos :: [Option]) ->
.B
       wxSizerItem:wxSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Window = wxWindow:wxWindow() | wxSizer:wxSizer()
.br
Pos = {R :: integer(), C :: integer()}
.br
Option = 
.br
    {span, {RS :: integer(), CS :: integer()}} |
.br
    {flag, integer()} |
.br
    {border, integer()} |
.br
    {userData, wx:wx_object()}
.br
.RE
.RE
.RS
.LP
Adds the given item to the given position\&.
.LP
Return: A valid pointer if the item was successfully placed at the given position, or NULL if something was already there\&.
.RE
.LP
.nf

.B
add(This, Width, Height, Pos, Options :: [Option]) ->
.B
       wxSizerItem:wxSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Width = Height = integer()
.br
Pos = {R :: integer(), C :: integer()}
.br
Option = 
.br
    {span, {RS :: integer(), CS :: integer()}} |
.br
    {flag, integer()} |
.br
    {border, integer()} |
.br
    {userData, wx:wx_object()}
.br
.RE
.RE
.RS
.LP
Adds a spacer to the given position\&.
.LP
\fIwidth\fR\& and \fIheight\fR\& specify the dimension of the spacer to be added\&.
.LP
Return: A valid pointer if the spacer was successfully placed at the given position, or NULL if something was already there\&.
.RE
.LP
.nf

.B
calcMin(This) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
.RE
.RE
.RS
.LP
Called when the managed size of the sizer is needed or when layout needs done\&.
.RE
.LP
.nf

.B
checkForIntersection(This, Item) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Item = wxGBSizerItem:wxGBSizerItem()
.br
.RE
.RE
.LP
.nf

.B
checkForIntersection(This, Pos, Span) -> boolean()
.br
.fi
.br
.nf

.B
checkForIntersection(This, Item, Span :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Item = wxGBSizerItem:wxGBSizerItem()
.br
Option = {excludeItem, wxGBSizerItem:wxGBSizerItem()}
.br
.RE
.RE
.RS
.LP
Look at all items and see if any intersect (or would overlap) the given item\&.
.LP
Returns true if so, false if there would be no overlap\&. If an \fIexcludeItem\fR\& is given then it will not be checked for intersection, for example it may be the item we are checking the position of\&.
.RE
.LP
.nf

.B
checkForIntersection(This, Pos, Span, Options :: [Option]) ->
.B
                        boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Pos = {R :: integer(), C :: integer()}
.br
Span = {RS :: integer(), CS :: integer()}
.br
Option = {excludeItem, wxGBSizerItem:wxGBSizerItem()}
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
findItem(This, Window) -> wxGBSizerItem:wxGBSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Window = wxWindow:wxWindow() | wxSizer:wxSizer()
.br
.RE
.RE
.RS
.LP
Find the sizer item for the given window or subsizer, returns NULL if not found\&.
.LP
(non-recursive)
.RE
.LP
.nf

.B
findItemAtPoint(This, Pt) -> wxGBSizerItem:wxGBSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Return the sizer item located at the point given in pt, or NULL if there is no item at that point\&.
.LP
The (x,y) coordinates in \fIpt\fR\& correspond to the client coordinates of the window using the sizer for layout\&. (non-recursive)
.RE
.LP
.nf

.B
findItemAtPosition(This, Pos) -> wxGBSizerItem:wxGBSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Pos = {R :: integer(), C :: integer()}
.br
.RE
.RE
.RS
.LP
Return the sizer item for the given grid cell, or NULL if there is no item at that position\&.
.LP
(non-recursive)
.RE
.LP
.nf

.B
findItemWithData(This, UserData) -> wxGBSizerItem:wxGBSizerItem()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
UserData = wx:wx_object()
.br
.RE
.RE
.RS
.LP
Return the sizer item that has a matching user data (it only compares pointer values) or NULL if not found\&.
.LP
(non-recursive)
.RE
.LP
.nf

.B
getCellSize(This, Row, Col) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Row = Col = integer()
.br
.RE
.RE
.RS
.LP
Get the size of the specified cell, including hgap and vgap\&.
.LP
Only valid after window layout has been performed\&.
.RE
.LP
.nf

.B
getEmptyCellSize(This) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
.RE
.RE
.RS
.LP
Get the size used for cells in the grid with no item\&.
.RE
.LP
.nf

.B
getItemPosition(This, Window) -> {R :: integer(), C :: integer()}
.br
.fi
.br
.nf

.B
getItemPosition(This, Index) -> {R :: integer(), C :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Index = integer()
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
getItemSpan(This, Window) -> {RS :: integer(), CS :: integer()}
.br
.fi
.br
.nf

.B
getItemSpan(This, Index) -> {RS :: integer(), CS :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Index = integer()
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
setEmptyCellSize(This, Sz) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Sz = {W :: integer(), H :: integer()}
.br
.RE
.RE
.RS
.LP
Set the size used for cells in the grid with no item\&.
.RE
.LP
.nf

.B
setItemPosition(This, Window, Pos) -> boolean()
.br
.fi
.br
.nf

.B
setItemPosition(This, Index, Pos) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Index = integer()
.br
Pos = {R :: integer(), C :: integer()}
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
setItemSpan(This, Window, Span) -> boolean()
.br
.fi
.br
.nf

.B
setItemSpan(This, Index, Span) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGridBagSizer()
.br
Index = integer()
.br
Span = {RS :: integer(), CS :: integer()}
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
destroy(This :: wxGridBagSizer()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the object\&.
.RE