.TH glu 3 "wx 2.2.2" "Ericsson AB" "Erlang Module Definition"
.SH NAME
glu \- Erlang wrapper functions for OpenGL
.SH DESCRIPTION
.LP
Standard OpenGL API
.LP
This documents the functions as a brief version of the complete OpenGL reference pages\&.
.SH DATA TYPES
.nf

\fBvertex()\fR\& = {float(), float(), float()}
.br
.fi
.nf

\fBi()\fR\& = integer()
.br
.fi
.nf

\fBf()\fR\& = float()
.br
.fi
.nf

\fBenum()\fR\& = integer() >= 0
.br
.fi
.nf

\fBmatrix()\fR\& = m12() | m16()
.br
.fi
.nf

\fBm12()\fR\& = 
.br
    {f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f(), f()}
.br
.fi
.nf

\fBm16()\fR\& = 
.br
    {f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f(),
.br
     f()}
.br
.fi
.nf

\fBmem()\fR\& = binary() | tuple()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
build1DMipmapLevels(Target, InternalFormat, Width, Format, Type,
.B
                    Level, Base, Max, Data) ->
.B
                       i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Target = enum()
.br
InternalFormat = Width = i()
.br
Format = Type = enum()
.br
Level = Base = Max = i()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
\fIglu:build1DMipmapLevels/9\fR\& builds a subset of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
build1DMipmaps(Target, InternalFormat, Width, Format, Type, Data) ->
.B
                  i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Target = enum()
.br
InternalFormat = Width = i()
.br
Format = Type = enum()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
\fIglu:build1DMipmaps/6\fR\& builds a series of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
build2DMipmapLevels(Target, InternalFormat, Width, Height, Format,
.B
                    Type, Level, Base, Max, Data) ->
.B
                       i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Target = enum()
.br
InternalFormat = Width = Height = i()
.br
Format = Type = enum()
.br
Level = Base = Max = i()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
\fIglu:build2DMipmapLevels/10\fR\& builds a subset of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
build2DMipmaps(Target, InternalFormat, Width, Height, Format,
.B
               Type, Data) ->
.B
                  i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Target = enum()
.br
InternalFormat = Width = Height = i()
.br
Format = Type = enum()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
\fIglu:build2DMipmaps/7\fR\& builds a series of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture-mapped primitives\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
build3DMipmapLevels(Target, InternalFormat, Width, Height, Depth,
.B
                    Format, Type, Level, Base, Max, Data) ->
.B
                       i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Target = enum()
.br
InternalFormat = Width = Height = Depth = i()
.br
Format = Type = enum()
.br
Level = Base = Max = i()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
\fIglu:build3DMipmapLevels/11\fR\& builds a subset of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
build3DMipmaps(Target, InternalFormat, Width, Height, Depth,
.B
               Format, Type, Data) ->
.B
                  i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Target = enum()
.br
InternalFormat = Width = Height = Depth = i()
.br
Format = Type = enum()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
\fIglu:build3DMipmaps/8\fR\& builds a series of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture-mapped primitives\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
checkExtension(ExtName :: string(), ExtString :: string()) ->
.B
                  0 | 1
.br
.fi
.br
.RS
.LP
\fIglu:checkExtension/2\fR\& returns \fI?GLU_TRUE\fR\& if \fIExtName\fR\& is supported otherwise \fI?GLU_FALSE\fR\& is returned\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
cylinder(Quad :: i(),
.B
         Base :: f(),
.B
         Top :: f(),
.B
         Height :: f(),
.B
         Slices :: i(),
.B
         Stacks :: i()) ->
.B
            ok
.br
.fi
.br
.RS
.LP
\fIglu:cylinder/6\fR\& draws a cylinder oriented along the \fIz\fR\& axis\&. The base of the cylinder is placed at \fIz\fR\& = 0 and the top at z=height\&. Like a sphere, a cylinder is subdivided around the \fIz\fR\& axis into slices and along the \fIz\fR\& axis into stacks\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
deleteQuadric(Quad :: i()) -> ok
.br
.fi
.br
.RS
.LP
\fIglu:deleteQuadric/1\fR\& destroys the quadrics object (created with \fIglu:newQuadric/0\fR\&) and frees any memory it uses\&. Once \fIglu:deleteQuadric/1\fR\& has been called, \fIQuad\fR\& cannot be used again\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
disk(Quad :: i(),
.B
     Inner :: f(),
.B
     Outer :: f(),
.B
     Slices :: i(),
.B
     Loops :: i()) ->
.B
        ok
.br
.fi
.br
.RS
.LP
\fIglu:disk/5\fR\& renders a disk on the \fIz\fR\& = 0 plane\&. The disk has a radius of \fIOuter\fR\& and contains a concentric circular hole with a radius of \fIInner\fR\&\&. If \fIInner\fR\& is 0, then no hole is generated\&. The disk is subdivided around the \fIz\fR\& axis into slices (like pizza slices) and also about the \fIz\fR\& axis into rings (as specified by \fISlices\fR\& and \fILoops\fR\&, respectively)\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
errorString(Error :: enum()) -> string()
.br
.fi
.br
.RS
.LP
\fIglu:errorString/1\fR\& produces an error string from a GL or GLU error code\&. The string is in ISO Latin 1 format\&. For example, \fIglu:errorString/1\fR\&(\fI?GLU_OUT_OF_MEMORY\fR\&) returns the string \fIout of memory\fR\&\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
getString(Name :: enum()) -> string()
.br
.fi
.br
.RS
.LP
\fIglu:getString/1\fR\& returns a pointer to a static string describing the GLU version or the GLU extensions that are supported\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
lookAt(EyeX, EyeY, EyeZ, CenterX, CenterY, CenterZ, UpX, UpY, UpZ) ->
.B
          ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EyeX = EyeY = EyeZ = CenterX = CenterY = CenterZ = UpX = UpY = UpZ = f()
.br
.RE
.RE
.RS
.LP
\fIglu:lookAt/9\fR\& creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an \fIUP\fR\& vector\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
newQuadric() -> i()
.br
.fi
.br
.RS
.LP
\fIglu:newQuadric/0\fR\& creates and returns a pointer to a new quadrics object\&. This object must be referred to when calling quadrics rendering and control functions\&. A return value of 0 means that there is not enough memory to allocate the object\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
ortho2D(Left :: f(), Right :: f(), Bottom :: f(), Top :: f()) ->
.B
           ok
.br
.fi
.br
.RS
.LP
\fIglu:ortho2D/4\fR\& sets up a two-dimensional orthographic viewing region\&. This is equivalent to calling \fIgl:ortho/6\fR\& with near=-1 and far=1\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
partialDisk(Quad, Inner, Outer, Slices, Loops, Start, Sweep) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Quad = i()
.br
Inner = Outer = f()
.br
Slices = Loops = i()
.br
Start = Sweep = f()
.br
.RE
.RE
.RS
.LP
\fIglu:partialDisk/7\fR\& renders a partial disk on the z=0 plane\&. A partial disk is similar to a full disk, except that only the subset of the disk from \fIStart\fR\& through \fIStart\fR\& + \fISweep\fR\& is included (where 0 degrees is along the +f2yf axis, 90 degrees along the +\fIx\fR\& axis, 180 degrees along the -\fIy\fR\& axis, and 270 degrees along the -\fIx\fR\& axis)\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
perspective(Fovy :: f(), Aspect :: f(), ZNear :: f(), ZFar :: f()) ->
.B
               ok
.br
.fi
.br
.RS
.LP
\fIglu:perspective/4\fR\& specifies a viewing frustum into the world coordinate system\&. In general, the aspect ratio in \fIglu:perspective/4\fR\& should match the aspect ratio of the associated viewport\&. For example, aspect=2\&.0 means the viewer\&'s angle of view is twice as wide in \fIx\fR\& as it is in \fIy\fR\&\&. If the viewport is twice as wide as it is tall, it displays the image without distortion\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
pickMatrix(X :: f(),
.B
           Y :: f(),
.B
           DelX :: f(),
.B
           DelY :: f(),
.B
           Viewport :: {i(), i(), i(), i()}) ->
.B
              ok
.br
.fi
.br
.RS
.LP
\fIglu:pickMatrix/5\fR\& creates a projection matrix that can be used to restrict drawing to a small region of the viewport\&. This is typically useful to determine what objects are being drawn near the cursor\&. Use \fIglu:pickMatrix/5\fR\& to restrict drawing to a small region around the cursor\&. Then, enter selection mode (with \fIgl:renderMode/1\fR\&) and rerender the scene\&. All primitives that would have been drawn near the cursor are identified and stored in the selection buffer\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
project(ObjX, ObjY, ObjZ, Model, Proj, View) ->
.B
           {i(), WinX :: f(), WinY :: f(), WinZ :: f()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
ObjX = ObjY = ObjZ = f()
.br
Model = Proj = matrix()
.br
View = {i(), i(), i(), i()}
.br
.RE
.RE
.RS
.LP
\fIglu:project/6\fR\& transforms the specified object coordinates into window coordinates using \fIModel\fR\&, \fIProj\fR\&, and \fIView\fR\&\&. The result is stored in \fIWinX\fR\&, \fIWinY\fR\&, and \fIWinZ\fR\&\&. A return value of \fI?GLU_TRUE\fR\& indicates success, a return value of \fI?GLU_FALSE\fR\& indicates failure\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
quadricDrawStyle(Quad :: i(), Draw :: enum()) -> ok
.br
.fi
.br
.RS
.LP
\fIglu:quadricDrawStyle/2\fR\& specifies the draw style for quadrics rendered with \fIQuad\fR\&\&. The legal values are as follows:
.LP
External documentation\&.
.RE
.LP
.nf

.B
quadricNormals(Quad :: i(), Normal :: enum()) -> ok
.br
.fi
.br
.RS
.LP
\fIglu:quadricNormals/2\fR\& specifies what kind of normals are desired for quadrics rendered with \fIQuad\fR\&\&. The legal values are as follows:
.LP
External documentation\&.
.RE
.LP
.nf

.B
quadricOrientation(Quad :: i(), Orientation :: enum()) -> ok
.br
.fi
.br
.RS
.LP
\fIglu:quadricOrientation/2\fR\& specifies what kind of orientation is desired for quadrics rendered with \fIQuad\fR\&\&. The \fIOrientation\fR\& values are as follows:
.LP
External documentation\&.
.RE
.LP
.nf

.B
quadricTexture(Quad :: i(), Texture :: 0 | 1) -> ok
.br
.fi
.br
.RS
.LP
\fIglu:quadricTexture/2\fR\& specifies if texture coordinates should be generated for quadrics rendered with \fIQuad\fR\&\&. If the value of \fITexture\fR\& is \fI?GLU_TRUE\fR\&, then texture coordinates are generated, and if \fITexture\fR\& is \fI?GLU_FALSE\fR\&, they are not\&. The initial value is \fI?GLU_FALSE\fR\&\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
scaleImage(Format, WIn, HIn, TypeIn, DataIn, WOut, HOut, TypeOut,
.B
           DataOut) ->
.B
              i()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Format = enum()
.br
WIn = HIn = i()
.br
TypeIn = enum()
.br
DataIn = binary()
.br
WOut = HOut = i()
.br
TypeOut = enum()
.br
DataOut = mem()
.br
.RE
.RE
.RS
.LP
\fIglu:scaleImage/9\fR\& scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
sphere(Quad :: i(), Radius :: f(), Slices :: i(), Stacks :: i()) ->
.B
          ok
.br
.fi
.br
.RS
.LP
\fIglu:sphere/4\fR\& draws a sphere of the given radius centered around the origin\&. The sphere is subdivided around the \fIz\fR\& axis into slices and along the \fIz\fR\& axis into stacks (similar to lines of longitude and latitude)\&.
.LP
External documentation\&.
.RE
.LP
.nf

.B
tesselate(Normal, Vs :: [Vs]) -> {Triangles, VertexPos}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Normal = Vs = vertex()
.br
Triangles = [integer()]
.br
VertexPos = binary()
.br
.RE
.RE
.RS
.LP
Triangulates a polygon, the polygon is specified by a \fINormal\fR\& and \fIVs\fR\& a list of vertex positions\&.
.LP
The function returns a list of indices of the vertices and a binary (64bit native float) containing an array of vertex positions, it starts with the vertices in \fIVs\fR\& and may contain newly created vertices in the end\&.
.RE
.LP
.nf

.B
unProject(WinX, WinY, WinZ, Model, Proj, View) ->
.B
             {i(), ObjX :: f(), ObjY :: f(), ObjZ :: f()}
.br
.fi
.br
.nf

.B
unProject4(WinX, WinY, WinZ, ClipW, Model, Proj, View, NearVal,
.B
           FarVal) ->
.B
              {i(),
.B
               ObjX :: f(),
.B
               ObjY :: f(),
.B
               ObjZ :: f(),
.B
               ObjW :: f()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
WinX = WinY = WinZ = ClipW = f()
.br
Model = Proj = matrix()
.br
View = {i(), i(), i(), i()}
.br
NearVal = FarVal = f()
.br
.RE
.RE
.RS
.LP
\fIglu:unProject/6\fR\& maps the specified window coordinates into object coordinates using \fIModel\fR\&, \fIProj\fR\&, and \fIView\fR\&\&. The result is stored in \fIObjX\fR\&, \fIObjY\fR\&, and \fIObjZ\fR\&\&. A return value of \fI?GLU_TRUE\fR\& indicates success; a return value of \fI?GLU_FALSE\fR\& indicates failure\&.
.LP
External documentation\&.
.RE