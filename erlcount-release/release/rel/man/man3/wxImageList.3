.TH wxImageList 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxImageList \- Functions for wxImageList class
.SH DESCRIPTION
.LP
A \fIwxImageList\fR\& contains a list of images, which are stored in an unspecified form\&. Images can have masks for transparent drawing, and can be made from a variety of sources including bitmaps and icons\&.
.LP
\fIwxImageList\fR\& is used principally in conjunction with \fIwxTreeCtrl\fR\& and \fIwxListCtrl\fR\& classes\&.
.LP
See: \fIwxTreeCtrl\fR\&, \fIwxListCtrl\fR\& 
.LP
wxWidgets docs: wxImageList
.SH DATA TYPES
.nf

\fBwxImageList()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxImageList()
.br
.fi
.br
.RS
.LP
Default ctor\&.
.RE
.LP
.nf

.B
new(Width, Height) -> wxImageList()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Width = Height = integer()
.br
.RE
.RE
.LP
.nf

.B
new(Width, Height, Options :: [Option]) -> wxImageList()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Width = Height = integer()
.br
Option = {mask, boolean()} | {initialCount, integer()}
.br
.RE
.RE
.RS
.LP
Constructor specifying the image size, whether image masks should be created, and the initial size of the list\&.
.LP
See: \fIcreate/4\fR\& 
.RE
.LP
.nf

.B
add(This, Icon) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Icon = wxIcon:wxIcon() | wxBitmap:wxBitmap()
.br
.RE
.RE
.RS
.LP
Adds a new image using an icon\&.
.LP
Return: The new zero-based image index\&.
.LP
Remark: The original bitmap or icon is not affected by the \fIadd/3\fR\& operation, and can be deleted afterwards\&. If the bitmap is wider than the images in the list, then the bitmap will automatically be split into smaller images, each matching the dimensions of the image list\&. This does not apply when adding icons\&.
.LP
Only for:wxmsw,wxosx
.RE
.LP
.nf

.B
add(This, Bitmap, Mask) -> integer()
.br
.fi
.br
.nf

.B
add(This, Bitmap, MaskColour) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Bitmap = wxBitmap:wxBitmap()
.br
MaskColour = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Adds a new image or images using a bitmap and mask colour\&.
.LP
Return: The new zero-based image index\&.
.LP
Remark: The original bitmap or icon is not affected by the \fIadd/3\fR\& operation, and can be deleted afterwards\&. If the bitmap is wider than the images in the list, then the bitmap will automatically be split into smaller images, each matching the dimensions of the image list\&. This does not apply when adding icons\&.
.RE
.LP
.nf

.B
create(This, Width, Height) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Width = Height = integer()
.br
.RE
.RE
.LP
.nf

.B
create(This, Width, Height, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Width = Height = integer()
.br
Option = {mask, boolean()} | {initialCount, integer()}
.br
.RE
.RE
.RS
.LP
Initializes the list\&.
.LP
See \fInew/3\fR\& for details\&.
.RE
.LP
.nf

.B
draw(This, Index, Dc, X, Y) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
Dc = wxDC:wxDC()
.br
X = Y = integer()
.br
.RE
.RE
.LP
.nf

.B
draw(This, Index, Dc, X, Y, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
Dc = wxDC:wxDC()
.br
X = Y = integer()
.br
Option = {flags, integer()} | {solidBackground, boolean()}
.br
.RE
.RE
.RS
.LP
Draws a specified image onto a device context\&.
.RE
.LP
.nf

.B
getBitmap(This, Index) -> wxBitmap:wxBitmap()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
.RE
.RE
.RS
.LP
Returns the bitmap corresponding to the given index\&.
.RE
.LP
.nf

.B
getIcon(This, Index) -> wxIcon:wxIcon()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
.RE
.RE
.RS
.LP
Returns the icon corresponding to the given index\&.
.RE
.LP
.nf

.B
getImageCount(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
.RE
.RE
.RS
.LP
Returns the number of images in the list\&.
.RE
.LP
.nf

.B
getSize(This, Index) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = 
.br
    {Res :: boolean(), Width :: integer(), Height :: integer()}
.br
This = wxImageList()
.br
Index = integer()
.br
.RE
.RE
.RS
.LP
Retrieves the size of the images in the list\&.
.LP
Currently, the \fIindex\fR\& parameter is ignored as all images in the list have the same size\&.
.LP
Return: true if the function succeeded, false if it failed (for example, if the image list was not yet initialized)\&.
.RE
.LP
.nf

.B
remove(This, Index) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
.RE
.RE
.RS
.LP
Removes the image at the given position\&.
.RE
.LP
.nf

.B
removeAll(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
.RE
.RE
.RS
.LP
Removes all the images in the list\&.
.RE
.LP
.nf

.B
replace(This, Index, Icon) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
Icon = wxIcon:wxIcon() | wxBitmap:wxBitmap()
.br
.RE
.RE
.RS
.LP
Replaces the existing image with the new image\&.
.LP
Return: true if the replacement was successful, false otherwise\&.
.LP
Remark: The original bitmap or icon is not affected by the \fIreplace/4\fR\& operation, and can be deleted afterwards\&.
.LP
Only for:wxmsw,wxosx
.RE
.LP
.nf

.B
replace(This, Index, Bitmap, Mask) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxImageList()
.br
Index = integer()
.br
Bitmap = Mask = wxBitmap:wxBitmap()
.br
.RE
.RE
.RS
.LP
Replaces the existing image with the new image\&.
.LP
Windows only\&.
.LP
Return: true if the replacement was successful, false otherwise\&.
.LP
Remark: The original bitmap or icon is not affected by the \fIreplace/4\fR\& operation, and can be deleted afterwards\&.
.RE
.LP
.nf

.B
destroy(This :: wxImageList()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the object\&.
.RE