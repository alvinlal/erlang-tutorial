.TH wxSplitterWindow 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxSplitterWindow \- Functions for wxSplitterWindow class
.SH DESCRIPTION
.LP
This class manages up to two subwindows\&. The current view can be split into two programmatically (perhaps from a menu command), and unsplit either programmatically or via the \fIwxSplitterWindow\fR\& user interface\&.
.LP
Styles
.LP
This class supports the following styles:
.LP
See: \fIwxSplitterEvent\fR\&, Overview splitterwindow 
.LP
This class is derived (and can use functions) from: \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxSplitterWindow
.SH "EVENTS"

.LP
Event types emitted from this class: \fIcommand_splitter_sash_pos_changing\fR\&, \fIcommand_splitter_sash_pos_changed\fR\&, \fIcommand_splitter_unsplit\fR\&
.SH DATA TYPES
.nf

\fBwxSplitterWindow()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxSplitterWindow()
.br
.fi
.br
.RS
.LP
Default constructor\&.
.RE
.LP
.nf

.B
new(Parent) -> wxSplitterWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Options :: [Option]) -> wxSplitterWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Constructor for creating the window\&.
.LP
Remark: After using this constructor, you must create either one or two subwindows with the splitter window as parent, and then call one of \fIinitialize/2\fR\&, \fIsplitVertically/4\fR\& and \fIsplitHorizontally/4\fR\& in order to set the pane(s)\&. You can create two windows, with one hidden when not being shown; or you can create and delete the second pane on demand\&.
.LP
See: \fIinitialize/2\fR\&, \fIsplitVertically/4\fR\&, \fIsplitHorizontally/4\fR\&, \fIcreate/3\fR\& 
.RE
.LP
.nf

.B
destroy(This :: wxSplitterWindow()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the \fIwxSplitterWindow\fR\& and its children\&.
.RE
.LP
.nf

.B
create(This, Parent) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Creation function, for two-step construction\&.
.LP
See \fInew/2\fR\& for details\&.
.RE
.LP
.nf

.B
getMinimumPaneSize(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Returns the current minimum pane size (defaults to zero)\&.
.LP
See: \fIsetMinimumPaneSize/2\fR\& 
.RE
.LP
.nf

.B
getSashGravity(This) -> number()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Returns the current sash gravity\&.
.LP
See: \fIsetSashGravity/2\fR\& 
.RE
.LP
.nf

.B
getSashPosition(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Returns the current sash position\&.
.LP
See: \fIsetSashPosition/3\fR\& 
.RE
.LP
.nf

.B
getSplitMode(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Gets the split mode\&.
.LP
See: \fIsetSplitMode/2\fR\&, \fIsplitVertically/4\fR\&, \fIsplitHorizontally/4\fR\& 
.RE
.LP
.nf

.B
getWindow1(This) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Returns the left/top or only pane\&.
.RE
.LP
.nf

.B
getWindow2(This) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Returns the right/bottom pane\&.
.RE
.LP
.nf

.B
initialize(This, Window) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Window = wxWindow:wxWindow()
.br
.RE
.RE
.RS
.LP
Initializes the splitter window to have one pane\&.
.LP
The child window is shown if it is currently hidden\&.
.LP
Remark: This should be called if you wish to initially view only a single pane in the splitter window\&.
.LP
See: \fIsplitVertically/4\fR\&, \fIsplitHorizontally/4\fR\& 
.RE
.LP
.nf

.B
isSplit(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Returns true if the window is split, false otherwise\&.
.RE
.LP
.nf

.B
replaceWindow(This, WinOld, WinNew) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
WinOld = WinNew = wxWindow:wxWindow()
.br
.RE
.RE
.RS
.LP
This function replaces one of the windows managed by the \fIwxSplitterWindow\fR\& with another one\&.
.LP
It is in general better to use it instead of calling \fIunsplit/2\fR\& and then resplitting the window back because it will provoke much less flicker (if any)\&. It is valid to call this function whether the splitter has two windows or only one\&.
.LP
Both parameters should be non-NULL and \fIwinOld\fR\& must specify one of the windows managed by the splitter\&. If the parameters are incorrect or the window couldn\&'t be replaced, false is returned\&. Otherwise the function will return true, but please notice that it will not delete the replaced window and you may wish to do it yourself\&.
.LP
See: \fIgetMinimumPaneSize/1\fR\& 
.RE
.LP
.nf

.B
setSashGravity(This, Gravity) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Gravity = number()
.br
.RE
.RE
.RS
.LP
Sets the sash gravity\&.
.LP
Remark: Gravity is real factor which controls position of sash while resizing \fIwxSplitterWindow\fR\&\&. Gravity tells \fIwxSplitterWindow\fR\& how much will left/top window grow while resizing\&. Example values:
.LP
Notice that when sash gravity for a newly created splitter window, it is often necessary to explicitly set the splitter size using \fIwxWindow:setSize/6\fR\& to ensure that is big enough for its initial sash position\&. Otherwise, i\&.e\&. if the window is created with the default tiny size and only resized to its correct size later, the initial sash position will be affected by the gravity and typically result in sash being at the rightmost position for the gravity of 1\&. See the example code creating \fIwxSplitterWindow\fR\& in the splitter sample for more details\&.
.LP
See: \fIgetSashGravity/1\fR\& 
.RE
.LP
.nf

.B
setSashPosition(This, Position) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Position = integer()
.br
.RE
.RE
.LP
.nf

.B
setSashPosition(This, Position, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Position = integer()
.br
Option = {redraw, boolean()}
.br
.RE
.RE
.RS
.LP
Sets the sash position\&.
.LP
Remark: Does not currently check for an out-of-range value\&.
.LP
See: \fIgetSashPosition/1\fR\& 
.RE
.LP
.nf

.B
setMinimumPaneSize(This, PaneSize) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
PaneSize = integer()
.br
.RE
.RE
.RS
.LP
Sets the minimum pane size\&.
.LP
Remark: The default minimum pane size is zero, which means that either pane can be reduced to zero by dragging the sash, thus removing one of the panes\&. To prevent this behaviour (and veto out-of-range sash dragging), set a minimum size, for example 20 pixels\&. If the wxSP_PERMIT_UNSPLIT style is used when a splitter window is created, the window may be unsplit even if minimum size is non-zero\&.
.LP
See: \fIgetMinimumPaneSize/1\fR\& 
.RE
.LP
.nf

.B
setSplitMode(This, Mode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Mode = integer()
.br
.RE
.RE
.RS
.LP
Sets the split mode\&.
.LP
Remark: Only sets the internal variable; does not update the display\&.
.LP
See: \fIgetSplitMode/1\fR\&, \fIsplitVertically/4\fR\&, \fIsplitHorizontally/4\fR\& 
.RE
.LP
.nf

.B
splitHorizontally(This, Window1, Window2) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Window1 = Window2 = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
splitHorizontally(This, Window1, Window2, Options :: [Option]) ->
.B
                     boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Window1 = Window2 = wxWindow:wxWindow()
.br
Option = {sashPosition, integer()}
.br
.RE
.RE
.RS
.LP
Initializes the top and bottom panes of the splitter window\&.
.LP
The child windows are shown if they are currently hidden\&.
.LP
Return: true if successful, false otherwise (the window was already split)\&.
.LP
Remark: This should be called if you wish to initially view two panes\&. It can also be called at any subsequent time, but the application should check that the window is not currently split using \fIisSplit/1\fR\&\&.
.LP
See: \fIsplitVertically/4\fR\&, \fIisSplit/1\fR\&, \fIunsplit/2\fR\& 
.RE
.LP
.nf

.B
splitVertically(This, Window1, Window2) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Window1 = Window2 = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
splitVertically(This, Window1, Window2, Options :: [Option]) ->
.B
                   boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Window1 = Window2 = wxWindow:wxWindow()
.br
Option = {sashPosition, integer()}
.br
.RE
.RE
.RS
.LP
Initializes the left and right panes of the splitter window\&.
.LP
The child windows are shown if they are currently hidden\&.
.LP
Return: true if successful, false otherwise (the window was already split)\&.
.LP
Remark: This should be called if you wish to initially view two panes\&. It can also be called at any subsequent time, but the application should check that the window is not currently split using \fIisSplit/1\fR\&\&.
.LP
See: \fIsplitHorizontally/4\fR\&, \fIisSplit/1\fR\&, \fIunsplit/2\fR\& 
.RE
.LP
.nf

.B
unsplit(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.LP
.nf

.B
unsplit(This, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
Option = {toRemove, wxWindow:wxWindow()}
.br
.RE
.RE
.RS
.LP
Unsplits the window\&.
.LP
Return: true if successful, false otherwise (the window was not split)\&.
.LP
Remark: This call will not actually delete the pane being removed; it calls \fIOnUnsplit()\fR\& (not implemented in wx) which can be overridden for the desired behaviour\&. By default, the pane being removed is hidden\&.
.LP
See: \fIsplitHorizontally/4\fR\&, \fIsplitVertically/4\fR\&, \fIisSplit/1\fR\&, \fIOnUnsplit()\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
updateSize(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxSplitterWindow()
.br
.RE
.RE
.RS
.LP
Causes any pending sizing of the sash and child panes to take place immediately\&.
.LP
Such resizing normally takes place in idle time, in order to wait for layout to be completed\&. However, this can cause unacceptable flicker as the panes are resized after the window has been shown\&. To work around this, you can perform window layout (for example by sending a size event to the parent window), and then call this function, before showing the top-level window\&.
.RE