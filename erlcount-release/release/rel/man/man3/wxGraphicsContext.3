.TH wxGraphicsContext 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxGraphicsContext \- Functions for wxGraphicsContext class
.SH DESCRIPTION
.LP
A \fIwxGraphicsContext\fR\& instance is the object that is drawn upon\&. It is created by a renderer using \fIwxGraphicsRenderer:createContext/2\fR\&\&. This can be either directly using a renderer instance, or indirectly using the static convenience \fIcreate/1\fR\& functions of \fIwxGraphicsContext\fR\& that always delegate the task to the default renderer\&.
.LP
Remark: For some renderers (like Direct2D or Cairo) processing of drawing operations may be deferred (Direct2D render target normally builds up a batch of rendering commands but defers processing of these commands, Cairo operates on a separate surface) so to make drawing results visible you need to update the content of the context by calling \fIwxGraphicsContext::Flush()\fR\& (not implemented in wx) or by destroying the context\&.
.LP
See: \fIwxGraphicsRenderer:createContext/2\fR\&, \fIwxGCDC\fR\&, \fIwxDC\fR\& 
.LP
This class is derived (and can use functions) from: \fIwxGraphicsObject\fR\&
.LP
wxWidgets docs: wxGraphicsContext
.SH DATA TYPES
.nf

\fBwxGraphicsContext()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
destroy(This :: wxGraphicsContext()) -> ok
.br
.fi
.br
.RS
.LP
Creates a \fIwxGraphicsContext\fR\& from a \fIwxWindow\fR\&\&.
.LP
See: \fIwxGraphicsRenderer:createContext/2\fR\& 
.RE
.LP
.nf

.B
create() -> wxGraphicsContext()
.br
.fi
.br
.RS
.LP
Create a lightweight context that can be used only for measuring text\&.
.RE
.LP
.nf

.B
create(WindowDC) -> wxGraphicsContext()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
WindowDC = 
.br
    wxWindowDC:wxWindowDC() |
.br
    wxWindow:wxWindow() |
.br
    wxMemoryDC:wxMemoryDC() |
.br
    wxImage:wxImage()
.br
.RE
.RE
.RS
.LP
Creates a \fIwxGraphicsContext\fR\& from a \fIwxWindowDC\fR\&\&.
.LP
See: \fIwxGraphicsRenderer:createContext/2\fR\& 
.RE
.LP
.nf

.B
createPen(This, Pen) -> wxGraphicsPen:wxGraphicsPen()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Pen = wxPen:wxPen()
.br
.RE
.RE
.RS
.LP
Creates a native pen from a \fIwxPen\fR\&\&.
.LP
Prefer to use the overload taking \fIwxGraphicsPenInfo\fR\& (not implemented in wx) unless you already have a \fIwxPen\fR\& as constructing one only to pass it to this method is wasteful\&.
.RE
.LP
.nf

.B
createBrush(This, Brush) -> wxGraphicsBrush:wxGraphicsBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Brush = wxBrush:wxBrush()
.br
.RE
.RE
.RS
.LP
Creates a native brush from a \fIwxBrush\fR\&\&.
.RE
.LP
.nf

.B
createRadialGradientBrush(This, StartX, StartY, EndX, EndY,
.B
                          Radius, Stops) ->
.B
                             wxGraphicsBrush:wxGraphicsBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
StartX = StartY = EndX = EndY = Radius = number()
.br
Stops = wxGraphicsGradientStops:wxGraphicsGradientStops()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
createRadialGradientBrush(This, StartX, StartY, EndX, EndY,
.B
                          Radius, OColor, CColor) ->
.B
                             wxGraphicsBrush:wxGraphicsBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
StartX = StartY = EndX = EndY = Radius = number()
.br
OColor = CColor = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
\fI Creates a native brush with a radial gradient\&. The brush originates at (@a startX, @a startY) and ends on a circle around (@a endX, @a endY) with the given @a radius\&. The gradient may be specified either by its start and end colours @a oColor and @a cColor or by a full set of gradient @a stops\&. The version taking wxGraphicsGradientStops is new in wxWidgets 2\&.9\&.1\&. \fR\& 
.LP
The ability to apply a transformation matrix to the gradient was added in 3\&.1\&.3
.RE
.LP
.nf

.B
createLinearGradientBrush(This, X1, Y1, X2, Y2, Stops) ->
.B
                             wxGraphicsBrush:wxGraphicsBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X1 = Y1 = X2 = Y2 = number()
.br
Stops = wxGraphicsGradientStops:wxGraphicsGradientStops()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
createLinearGradientBrush(This, X1, Y1, X2, Y2, C1, C2) ->
.B
                             wxGraphicsBrush:wxGraphicsBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X1 = Y1 = X2 = Y2 = number()
.br
C1 = C2 = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
\fI Creates a native brush with a linear gradient\&. The brush starts at (@a x1, @a y1) and ends at (@a x2, @a y2)\&. Either just the start and end gradient colours (@a c1 and @a c2) or full set of gradient @a stops can be specified\&. The version taking wxGraphicsGradientStops is new in wxWidgets 2\&.9\&.1\&. \fR\& 
.LP
The \fImatrix\fR\& parameter was added in wxWidgets 3\&.1\&.3
.RE
.LP
.nf

.B
createFont(This, Font) -> wxGraphicsFont:wxGraphicsFont()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Font = wxFont:wxFont()
.br
.RE
.RE
.LP
.nf

.B
createFont(This, SizeInPixels, Facename) ->
.B
              wxGraphicsFont:wxGraphicsFont()
.br
.fi
.br
.nf

.B
createFont(This, Font, Facename :: [Option]) ->
.B
              wxGraphicsFont:wxGraphicsFont()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Font = wxFont:wxFont()
.br
Option = {col, wx:wx_colour()}
.br
.RE
.RE
.RS
.LP
Creates a native graphics font from a \fIwxFont\fR\& and a text colour\&.
.LP
Remark: For Direct2D graphics fonts can be created from TrueType fonts only\&.
.RE
.LP
.nf

.B
createFont(This, SizeInPixels, Facename, Options :: [Option]) ->
.B
              wxGraphicsFont:wxGraphicsFont()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
SizeInPixels = number()
.br
Facename = unicode:chardata()
.br
Option = {flags, integer()} | {col, wx:wx_colour()}
.br
.RE
.RE
.RS
.LP
Creates a font object with the specified attributes\&.
.LP
The use of overload taking \fIwxFont\fR\& is preferred, see \fIwxGraphicsRenderer:createFont/4\fR\& for more details\&.
.LP
Remark: For Direct2D graphics fonts can be created from TrueType fonts only\&.
.LP
Since: 2\&.9\&.3
.RE
.LP
.nf

.B
createMatrix(This) -> wxGraphicsMatrix:wxGraphicsMatrix()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
.RE
.RE
.LP
.nf

.B
createMatrix(This, Options :: [Option]) ->
.B
                wxGraphicsMatrix:wxGraphicsMatrix()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Option = 
.br
    {a, number()} |
.br
    {b, number()} |
.br
    {c, number()} |
.br
    {d, number()} |
.br
    {tx, number()} |
.br
    {ty, number()}
.br
.RE
.RE
.RS
.LP
Creates a native affine transformation matrix from the passed in values\&.
.LP
The default parameters result in an identity matrix\&.
.RE
.LP
.nf

.B
createPath(This) -> wxGraphicsPath:wxGraphicsPath()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
.RE
.RE
.RS
.LP
Creates a native graphics path which is initially empty\&.
.RE
.LP
.nf

.B
clip(This, Region) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Region = wxRegion:wxRegion()
.br
.RE
.RE
.RS
.LP
Sets the clipping region to the intersection of the given region and the previously set clipping region\&.
.LP
The clipping region is an area to which drawing is restricted\&.
.LP
Remark:
.RE
.LP
.nf

.B
clip(This, X, Y, W, H) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X = Y = W = H = number()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
resetClip(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
.RE
.RE
.RS
.LP
Resets the clipping to original shape\&.
.RE
.LP
.nf

.B
drawBitmap(This, Bmp, X, Y, W, H) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Bmp = wxBitmap:wxBitmap()
.br
X = Y = W = H = number()
.br
.RE
.RE
.RS
.LP
Draws the bitmap\&.
.LP
In case of a mono bitmap, this is treated as a mask and the current brushed is used for filling\&.
.RE
.LP
.nf

.B
drawEllipse(This, X, Y, W, H) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X = Y = W = H = number()
.br
.RE
.RE
.RS
.LP
Draws an ellipse\&.
.RE
.LP
.nf

.B
drawIcon(This, Icon, X, Y, W, H) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Icon = wxIcon:wxIcon()
.br
X = Y = W = H = number()
.br
.RE
.RE
.RS
.LP
Draws the icon\&.
.RE
.LP
.nf

.B
drawLines(This, Points) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Points = [{X :: float(), Y :: float()}]
.br
.RE
.RE
.LP
.nf

.B
drawLines(This, Points, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Points = [{X :: float(), Y :: float()}]
.br
Option = {fillStyle, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
Draws a polygon\&.
.RE
.LP
.nf

.B
drawPath(This, Path) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Path = wxGraphicsPath:wxGraphicsPath()
.br
.RE
.RE
.LP
.nf

.B
drawPath(This, Path, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Path = wxGraphicsPath:wxGraphicsPath()
.br
Option = {fillStyle, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
Draws the path by first filling and then stroking\&.
.RE
.LP
.nf

.B
drawRectangle(This, X, Y, W, H) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X = Y = W = H = number()
.br
.RE
.RE
.RS
.LP
Draws a rectangle\&.
.RE
.LP
.nf

.B
drawRoundedRectangle(This, X, Y, W, H, Radius) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X = Y = W = H = Radius = number()
.br
.RE
.RE
.RS
.LP
Draws a rounded rectangle\&.
.RE
.LP
.nf

.B
drawText(This, Str, X, Y) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Str = unicode:chardata()
.br
X = Y = number()
.br
.RE
.RE
.RS
.LP
Draws text at the defined position\&.
.RE
.LP
.nf

.B
drawText(This, Str, X, Y, Angle) -> ok
.br
.fi
.br
.nf

.B
drawText(This, Str, X, Y, BackgroundBrush) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Str = unicode:chardata()
.br
X = Y = number()
.br
BackgroundBrush = wxGraphicsBrush:wxGraphicsBrush()
.br
.RE
.RE
.RS
.LP
Draws text at the defined position\&.
.RE
.LP
.nf

.B
drawText(This, Str, X, Y, Angle, BackgroundBrush) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Str = unicode:chardata()
.br
X = Y = Angle = number()
.br
BackgroundBrush = wxGraphicsBrush:wxGraphicsBrush()
.br
.RE
.RE
.RS
.LP
Draws text at the defined position\&.
.RE
.LP
.nf

.B
fillPath(This, Path) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Path = wxGraphicsPath:wxGraphicsPath()
.br
.RE
.RE
.LP
.nf

.B
fillPath(This, Path, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Path = wxGraphicsPath:wxGraphicsPath()
.br
Option = {fillStyle, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
Fills the path with the current brush\&.
.RE
.LP
.nf

.B
strokePath(This, Path) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Path = wxGraphicsPath:wxGraphicsPath()
.br
.RE
.RE
.RS
.LP
Strokes along a path with the current pen\&.
.RE
.LP
.nf

.B
getPartialTextExtents(This, Text) -> [number()]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Fills the \fIwidths\fR\& array with the widths from the beginning of \fItext\fR\& to the corresponding character of \fItext\fR\&\&.
.RE
.LP
.nf

.B
getTextExtent(This, Text) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = 
.br
    {Width :: number(),
.br
     Height :: number(),
.br
     Descent :: number(),
.br
     ExternalLeading :: number()}
.br
This = wxGraphicsContext()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Gets the dimensions of the string using the currently selected font\&.
.RE
.LP
.nf

.B
rotate(This, Angle) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Angle = number()
.br
.RE
.RE
.RS
.LP
Rotates the current transformation matrix (in radians)\&.
.RE
.LP
.nf

.B
scale(This, XScale, YScale) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
XScale = YScale = number()
.br
.RE
.RE
.RS
.LP
Scales the current transformation matrix\&.
.RE
.LP
.nf

.B
translate(This, Dx, Dy) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Dx = Dy = number()
.br
.RE
.RE
.RS
.LP
Translates the current transformation matrix\&.
.RE
.LP
.nf

.B
getTransform(This) -> wxGraphicsMatrix:wxGraphicsMatrix()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
.RE
.RE
.RS
.LP
Gets the current transformation matrix of this context\&.
.RE
.LP
.nf

.B
setTransform(This, Matrix) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Matrix = wxGraphicsMatrix:wxGraphicsMatrix()
.br
.RE
.RE
.RS
.LP
Sets the current transformation matrix of this context\&.
.RE
.LP
.nf

.B
concatTransform(This, Matrix) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Matrix = wxGraphicsMatrix:wxGraphicsMatrix()
.br
.RE
.RE
.RS
.LP
Concatenates the passed in transform with the current transform of this context\&.
.RE
.LP
.nf

.B
setBrush(This, Brush) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Brush = wxGraphicsBrush:wxGraphicsBrush() | wxBrush:wxBrush()
.br
.RE
.RE
.RS
.LP
Sets the brush for filling paths\&.
.RE
.LP
.nf

.B
setFont(This, Font) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Font = wxGraphicsFont:wxGraphicsFont()
.br
.RE
.RE
.RS
.LP
Sets the font for drawing text\&.
.RE
.LP
.nf

.B
setFont(This, Font, Colour) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Font = wxFont:wxFont()
.br
Colour = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Sets the font for drawing text\&.
.LP
Remark: For Direct2D only TrueType fonts can be used\&.
.RE
.LP
.nf

.B
setPen(This, Pen) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Pen = wxPen:wxPen() | wxGraphicsPen:wxGraphicsPen()
.br
.RE
.RE
.RS
.LP
Sets the pen used for stroking\&.
.RE
.LP
.nf

.B
strokeLine(This, X1, Y1, X2, Y2) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
X1 = Y1 = X2 = Y2 = number()
.br
.RE
.RE
.RS
.LP
Strokes a single line\&.
.RE
.LP
.nf

.B
strokeLines(This, Points) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGraphicsContext()
.br
Points = [{X :: float(), Y :: float()}]
.br
.RE
.RE
.RS
.LP
Stroke lines connecting all the points\&.
.LP
Unlike the other overload of this function, this method draws a single polyline and not a number of disconnected lines\&.
.RE