.TH wxStaticText 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxStaticText \- Functions for wxStaticText class
.SH DESCRIPTION
.LP
A static text control displays one or more lines of read-only text\&. \fIwxStaticText\fR\& supports the three classic text alignments, label ellipsization i\&.e\&. replacing parts of the text with the ellipsis ("\&.\&.\&.") if the label doesn\&'t fit into the provided space and also formatting markup with \fIwxControl::SetLabelMarkup()\fR\& (not implemented in wx)\&.
.LP
Styles
.LP
This class supports the following styles:
.LP
See: \fIwxStaticBitmap\fR\&, \fIwxStaticBox\fR\& 
.LP
This class is derived (and can use functions) from: \fIwxControl\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxStaticText
.SH DATA TYPES
.nf

\fBwxStaticText()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxStaticText()
.br
.fi
.br
.RS
.LP
Default constructor\&.
.RE
.LP
.nf

.B
new(Parent, Id, Label) -> wxStaticText()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Label = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Id, Label, Options :: [Option]) -> wxStaticText()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Label = unicode:chardata()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Constructor, creating and showing a text control\&.
.LP
See: \fIcreate/5\fR\& 
.RE
.LP
.nf

.B
create(This, Parent, Id, Label) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStaticText()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Label = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Id, Label, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStaticText()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Label = unicode:chardata()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Creation function, for two-step construction\&.
.LP
For details see \fInew/4\fR\&\&.
.RE
.LP
.nf

.B
getLabel(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStaticText()
.br
.RE
.RE
.RS
.LP
Returns the control\&'s label, as it was passed to \fIwxControl:setLabel/2\fR\&\&.
.LP
Note that the returned string may contains mnemonics ("&" characters) if they were passed to the \fIwxControl:setLabel/2\fR\& function; use \fIGetLabelText()\fR\& (not implemented in wx) if they are undesired\&.
.LP
Also note that the returned string is always the string which was passed to \fIwxControl:setLabel/2\fR\& but may be different from the string passed to \fISetLabelText()\fR\& (not implemented in wx) (since this last one escapes mnemonic characters)\&.
.RE
.LP
.nf

.B
setLabel(This, Label) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStaticText()
.br
Label = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Change the label shown in the control\&.
.LP
Notice that since wxWidgets 3\&.1\&.1 this function is guaranteed not to do anything if the label didn\&'t really change, so there is no benefit to checking if the new label is different from the current one in the application code\&.
.LP
See: \fIwxControl:setLabel/2\fR\& 
.RE
.LP
.nf

.B
wrap(This, Width) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxStaticText()
.br
Width = integer()
.br
.RE
.RE
.RS
.LP
This functions wraps the controls label so that each of its lines becomes at most \fIwidth\fR\& pixels wide if possible (the lines are broken at words boundaries so it might not be the case if words are too long)\&.
.LP
If \fIwidth\fR\& is negative, no wrapping is done\&. Note that this width is not necessarily the total width of the control, since a few pixels for the border (depending on the controls border style) may be added\&.
.LP
Since: 2\&.6\&.2
.RE
.LP
.nf

.B
destroy(This :: wxStaticText()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the object\&.
.RE