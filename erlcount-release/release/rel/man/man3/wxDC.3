.TH wxDC 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxDC \- Functions for wxDC class
.SH DESCRIPTION
.LP
A \fIwxDC\fR\& is a \fI"device context"\fR\& onto which graphics and text can be drawn\&. It is intended to represent different output devices and offers a common abstract API for drawing on any of them\&.
.LP
wxWidgets offers an alternative drawing API based on the modern drawing backends GDI+, CoreGraphics, Cairo and Direct2D\&. See \fIwxGraphicsContext\fR\&, \fIwxGraphicsRenderer\fR\& and related classes\&. There is also a \fIwxGCDC\fR\& linking the APIs by offering the \fIwxDC\fR\& API on top of a \fIwxGraphicsContext\fR\&\&.
.LP
\fIwxDC\fR\& is an abstract base class and cannot be created directly\&. Use \fIwxPaintDC\fR\&, \fIwxClientDC\fR\&, \fIwxWindowDC\fR\&, \fIwxScreenDC\fR\&, \fIwxMemoryDC\fR\& or \fIwxPrinterDC\fR\& (not implemented in wx)\&. Notice that device contexts which are associated with windows (i\&.e\&. \fIwxClientDC\fR\&, \fIwxWindowDC\fR\& and \fIwxPaintDC\fR\&) use the window font and colours by default (starting with wxWidgets 2\&.9\&.0) but the other device context classes use system-default values so you always must set the appropriate fonts and colours before using them\&.
.LP
In addition to the versions of the methods documented below, there are also versions which accept single {X,Y} parameter instead of the two wxCoord ones or {X,Y} and {Width,Height} instead of the four wxCoord parameters\&.
.LP
Beginning with wxWidgets 2\&.9\&.0 the entire \fIwxDC\fR\& code has been reorganized\&. All platform dependent code (actually all drawing code) has been moved into backend classes which derive from a common wxDCImpl class\&. The user-visible classes such as \fIwxClientDC\fR\& and \fIwxPaintDC\fR\& merely forward all calls to the backend implementation\&.
.LP
Device and logical units
.LP
In the \fIwxDC\fR\& context there is a distinction between \fIlogical\fR\& units and \fIdevice\fR\& units\&.
.LP
\fIDevice\fR\& units are the units native to the particular device; e\&.g\&. for a screen, a device unit is a \fIpixel\fR\&\&. For a printer, the device unit is defined by the resolution of the printer (usually given in \fIDPI:\fR\& dot-per-inch)\&.
.LP
All \fIwxDC\fR\& functions use instead \fIlogical\fR\& units, unless where explicitly stated\&. Logical units are arbitrary units mapped to device units using the current mapping mode (see \fIsetMapMode/2\fR\&)\&.
.LP
This mechanism allows reusing the same code which prints on e\&.g\&. a window on the screen to print on e\&.g\&. a paper\&.
.LP
Support for Transparency / Alpha Channel
.LP
In general \fIwxDC\fR\& methods don\&'t support alpha transparency and the alpha component of \fIwx_color()\fR\& is simply ignored and you need to use \fIwxGraphicsContext\fR\& for full transparency support\&. There are, however, a few exceptions: first, under macOS and GTK+ 3 colours with alpha channel are supported in all the normal wxDC-derived classes as they use \fIwxGraphicsContext\fR\& internally\&. Second, under all platforms \fIwxSVGFileDC\fR\& (not implemented in wx) also fully supports alpha channel\&. In both of these cases the instances of \fIwxPen\fR\& or \fIwxBrush\fR\& that are built from \fIwx_color()\fR\& use the colour\&'s alpha values when stroking or filling\&.
.LP
Support for Transformation Matrix
.LP
On some platforms (currently under MSW, GTK+ 3, macOS) \fIwxDC\fR\& has support for applying an arbitrary affine transformation matrix to its coordinate system (since 3\&.1\&.1 this feature is also supported by \fIwxGCDC\fR\& in all ports)\&. Call \fICanUseTransformMatrix()\fR\& (not implemented in wx) to check if this support is available and then call \fISetTransformMatrix()\fR\& (not implemented in wx) if it is\&. If the transformation matrix is not supported, \fISetTransformMatrix()\fR\& (not implemented in wx) always simply returns \fIfalse\fR\& and doesn\&'t do anything\&.
.LP
This feature is only available when \fIwxUSE_DC_TRANSFORM_MATRIX\fR\& build option is enabled\&.
.LP
See: Overview dc, \fIwxGraphicsContext\fR\&, \fIwxDCFontChanger\fR\& (not implemented in wx), \fIwxDCTextColourChanger\fR\& (not implemented in wx), \fIwxDCPenChanger\fR\& (not implemented in wx), \fIwxDCBrushChanger\fR\& (not implemented in wx), \fIwxDCClipper\fR\& (not implemented in wx)
.LP
wxWidgets docs: wxDC
.SH DATA TYPES
.nf

\fBwxDC()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
blit(This, Dest, Size, Source, Src) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Dest = {X :: integer(), Y :: integer()}
.br
Size = {W :: integer(), H :: integer()}
.br
Source = wxDC()
.br
Src = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.LP
.nf

.B
blit(This, Dest, Size, Source, Src, Options :: [Option]) ->
.B
        boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Dest = {X :: integer(), Y :: integer()}
.br
Size = {W :: integer(), H :: integer()}
.br
Source = wxDC()
.br
Src = {X :: integer(), Y :: integer()}
.br
Option = 
.br
    {rop, wx:wx_enum()} |
.br
    {useMask, boolean()} |
.br
    {srcPtMask, {X :: integer(), Y :: integer()}}
.br
.RE
.RE
.RS
.LP
Copy from a source DC to this DC\&.
.LP
With this method you can specify the destination coordinates and the size of area to copy which will be the same for both the source and target DCs\&. If you need to apply scaling while copying, use \fIStretchBlit()\fR\& (not implemented in wx)\&.
.LP
Notice that source DC coordinates \fIxsrc\fR\& and \fIysrc\fR\& are interpreted using the current source DC coordinate system, i\&.e\&. the scale, origin position and axis directions are taken into account when transforming them to physical (pixel) coordinates\&.
.LP
Remark: There is partial support for \fIblit/6\fR\& in \fIwxPostScriptDC\fR\&, under X\&.
.LP
See: \fIStretchBlit()\fR\& (not implemented in wx), \fIwxMemoryDC\fR\&, \fIwxBitmap\fR\&, \fIwxMask\fR\& 
.RE
.LP
.nf

.B
calcBoundingBox(This, X, Y) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = Y = integer()
.br
.RE
.RE
.RS
.LP
Adds the specified point to the bounding box which can be retrieved with \fIminX/1\fR\&, \fImaxX/1\fR\& and \fIminY/1\fR\&, \fImaxY/1\fR\& functions\&.
.LP
See: \fIresetBoundingBox/1\fR\& 
.RE
.LP
.nf

.B
clear(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Clears the device context using the current background brush\&.
.LP
Note that \fIsetBackground/2\fR\& method must be used to set the brush used by \fIclear/1\fR\&, the brush used for filling the shapes set by \fIsetBrush/2\fR\& is ignored by it\&.
.LP
If no background brush was set, solid white brush is used to clear the device context\&.
.RE
.LP
.nf

.B
crossHair(This, Pt) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
destroyClippingRegion(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Destroys the current clipping region so that none of the DC is clipped\&.
.LP
See: \fIsetClippingRegion/3\fR\& 
.RE
.LP
.nf

.B
deviceToLogicalX(This, X) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
Convert \fIdevice\fR\& X coordinate to logical coordinate, using the current mapping mode, user scale factor, device origin and axis orientation\&.
.RE
.LP
.nf

.B
deviceToLogicalXRel(This, X) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
Convert \fIdevice\fR\& X coordinate to relative logical coordinate, using the current mapping mode and user scale factor but ignoring the axis orientation\&.
.LP
Use this for converting a width, for example\&.
.RE
.LP
.nf

.B
deviceToLogicalY(This, Y) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
Converts \fIdevice\fR\& Y coordinate to logical coordinate, using the current mapping mode, user scale factor, device origin and axis orientation\&.
.RE
.LP
.nf

.B
deviceToLogicalYRel(This, Y) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
Convert \fIdevice\fR\& Y coordinate to relative logical coordinate, using the current mapping mode and user scale factor but ignoring the axis orientation\&.
.LP
Use this for converting a height, for example\&.
.RE
.LP
.nf

.B
drawArc(This, PtStart, PtEnd, Centre) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
PtStart = PtEnd = Centre = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawBitmap(This, Bmp, Pt) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Bmp = wxBitmap:wxBitmap()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.LP
.nf

.B
drawBitmap(This, Bmp, Pt, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Bmp = wxBitmap:wxBitmap()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Option = {useMask, boolean()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawCheckMark(This, Rect) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawCircle(This, Pt, Radius) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Radius = integer()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawEllipse(This, Rect) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawEllipse(This, Pt, Size) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Size = {W :: integer(), H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawEllipticArc(This, Pt, Sz, Sa, Ea) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Sz = {W :: integer(), H :: integer()}
.br
Sa = Ea = number()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawIcon(This, Icon, Pt) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Icon = wxIcon:wxIcon()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawLabel(This, Text, Rect) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = unicode:chardata()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
.RE
.RE
.LP
.nf

.B
drawLabel(This, Text, Rect, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = unicode:chardata()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
Option = {alignment, integer()} | {indexAccel, integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawLine(This, Pt1, Pt2) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt1 = Pt2 = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawLines(This, Points) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X :: integer(), Y :: integer()}]
.br
.RE
.RE
.LP
.nf

.B
drawLines(This, Points, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X :: integer(), Y :: integer()}]
.br
Option = {xoffset, integer()} | {yoffset, integer()}
.br
.RE
.RE
.RS
.LP
Draws lines using an array of points of size \fIn\fR\& adding the optional offset coordinate\&.
.LP
The current pen is used for drawing the lines\&.
.RE
.LP
.nf

.B
drawPolygon(This, Points) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X :: integer(), Y :: integer()}]
.br
.RE
.RE
.LP
.nf

.B
drawPolygon(This, Points, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Points = [{X :: integer(), Y :: integer()}]
.br
Option = 
.br
    {xoffset, integer()} |
.br
    {yoffset, integer()} |
.br
    {fillStyle, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
Draws a filled polygon using an array of points of size \fIn\fR\&, adding the optional offset coordinate\&.
.LP
The first and last points are automatically closed\&.
.LP
The last argument specifies the fill rule: \fIwxODDEVEN_RULE\fR\& (the default) or \fIwxWINDING_RULE\fR\&\&.
.LP
The current pen is used for drawing the outline, and the current brush for filling the shape\&. Using a transparent brush suppresses filling\&.
.RE
.LP
.nf

.B
drawPoint(This, Pt) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawRectangle(This, Rect) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawRectangle(This, Pt, Sz) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Sz = {W :: integer(), H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawRotatedText(This, Text, Point, Angle) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = unicode:chardata()
.br
Point = {X :: integer(), Y :: integer()}
.br
Angle = number()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawRoundedRectangle(This, Rect, Radius) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
Radius = number()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawRoundedRectangle(This, Pt, Sz, Radius) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Sz = {W :: integer(), H :: integer()}
.br
Radius = number()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
drawText(This, Text, Pt) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Text = unicode:chardata()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
endDoc(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Ends a document (only relevant when outputting to a printer)\&.
.RE
.LP
.nf

.B
endPage(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Ends a document page (only relevant when outputting to a printer)\&.
.RE
.LP
.nf

.B
floodFill(This, Pt, Col) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Col = wx:wx_colour()
.br
.RE
.RE
.LP
.nf

.B
floodFill(This, Pt, Col, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Col = wx:wx_colour()
.br
Option = {style, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
getBackground(This) -> wxBrush:wxBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the brush used for painting the background\&.
.LP
See: \fIsetBackground/2\fR\& 
.RE
.LP
.nf

.B
getBackgroundMode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Returns the current background mode: \fIwxPENSTYLE_SOLID\fR\& or \fIwxPENSTYLE_TRANSPARENT\fR\&\&.
.LP
See: \fIsetBackgroundMode/2\fR\& 
.RE
.LP
.nf

.B
getBrush(This) -> wxBrush:wxBrush()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current brush\&.
.LP
See: \fIsetBrush/2\fR\& 
.RE
.LP
.nf

.B
getCharHeight(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the character height of the currently set font\&.
.RE
.LP
.nf

.B
getCharWidth(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the average character width of the currently set font\&.
.RE
.LP
.nf

.B
getClippingBox(This) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     Width :: integer(),
.br
     Height :: integer()}
.br
This = wxDC()
.br
.RE
.RE
.RS
.LP
\fI Gets the rectangle surrounding the current clipping region\&. If no clipping region is set this function returns the extent of the device context\&. @remarks Clipping region is given in logical coordinates\&. @param x If non-<span class=\&'literal\&'>NULL</span>, filled in with the logical horizontal coordinate of the top left corner of the clipping region if the function returns true or 0 otherwise\&. @param y If non-<span class=\&'literal\&'>NULL</span>, filled in with the logical vertical coordinate of the top left corner of the clipping region if the function returns true or 0 otherwise\&. @param width If non-<span class=\&'literal\&'>NULL</span>, filled in with the width of the clipping region if the function returns true or the device context width otherwise\&. @param height If non-<span class=\&'literal\&'>NULL</span>, filled in with the height of the clipping region if the function returns true or the device context height otherwise\&. \fR\& 
.LP
Return: true if there is a clipping region or false if there is no active clipping region (note that this return value is available only since wxWidgets 3\&.1\&.2, this function didn\&'t return anything in the previous versions)\&.
.RE
.LP
.nf

.B
getFont(This) -> wxFont:wxFont()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current font\&.
.LP
Notice that even although each device context object has some default font after creation, this method would return a ?wxNullFont initially and only after calling \fIsetFont/2\fR\& a valid font is returned\&.
.RE
.LP
.nf

.B
getLayoutDirection(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current layout direction of the device context\&.
.LP
On platforms where RTL layout is supported, the return value will either be \fIwxLayout_LeftToRight\fR\& or \fIwxLayout_RightToLeft\fR\&\&. If RTL layout is not supported, the return value will be \fIwxLayout_Default\fR\&\&.
.LP
See: \fIsetLayoutDirection/2\fR\& 
.RE
.LP
.nf

.B
getLogicalFunction(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current logical function\&.
.LP
See: \fIsetLogicalFunction/2\fR\& 
.RE
.LP
.nf

.B
getMapMode(This) -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current mapping mode for the device context\&.
.LP
See: \fIsetMapMode/2\fR\& 
.RE
.LP
.nf

.B
getMultiLineTextExtent(This, String) ->
.B
                          {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
String = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Gets the dimensions of the string using the currently selected font\&.
.LP
\fIstring\fR\& is the text string to measure\&.
.LP
Return: The text extent as a {Width,Height} object\&.
.LP
Note: This function works with both single-line and multi-line strings\&.
.LP
See: \fIwxFont\fR\&, \fIsetFont/2\fR\&, \fIgetPartialTextExtents/2\fR\&, \fIgetTextExtent/3\fR\& 
.RE
.LP
.nf

.B
getMultiLineTextExtent(This, String, Options :: [Option]) ->
.B
                          {W :: integer(),
.B
                           H :: integer(),
.B
                           HeightLine :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
String = unicode:chardata()
.br
Option = {font, wxFont:wxFont()}
.br
.RE
.RE
.RS
.LP
Gets the dimensions of the string using the currently selected font\&.
.LP
\fIstring\fR\& is the text string to measure, \fIheightLine\fR\&, if non NULL, is where to store the height of a single line\&.
.LP
The text extent is set in the given \fIw\fR\& and \fIh\fR\& pointers\&.
.LP
If the optional parameter \fIfont\fR\& is specified and valid, then it is used for the text extent calculation, otherwise the currently selected font is used\&.
.LP
If \fIstring\fR\& is empty, its horizontal extent is 0 but, for convenience when using this function for allocating enough space for a possibly multi-line string, its vertical extent is the same as the height of an empty line of text\&. Please note that this behaviour differs from that of \fIgetTextExtent/3\fR\&\&.
.LP
Note: This function works with both single-line and multi-line strings\&.
.LP
See: \fIwxFont\fR\&, \fIsetFont/2\fR\&, \fIgetPartialTextExtents/2\fR\&, \fIgetTextExtent/3\fR\& 
.RE
.LP
.nf

.B
getPartialTextExtents(This, Text) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = {Res :: boolean(), Widths :: [integer()]}
.br
This = wxDC()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Fills the \fIwidths\fR\& array with the widths from the beginning of \fItext\fR\& to the corresponding character of \fItext\fR\&\&.
.LP
The generic version simply builds a running total of the widths of each character using \fIgetTextExtent/3\fR\&, however if the various platforms have a native API function that is faster or more accurate than the generic implementation then it should be used instead\&.
.LP
See: \fIgetMultiLineTextExtent/3\fR\&, \fIgetTextExtent/3\fR\& 
.RE
.LP
.nf

.B
getPen(This) -> wxPen:wxPen()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current pen\&.
.LP
See: \fIsetPen/2\fR\& 
.RE
.LP
.nf

.B
getPixel(This, Pos) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = {Res :: boolean(), Colour :: wx:wx_colour4()}
.br
This = wxDC()
.br
Pos = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Gets in \fIcolour\fR\& the colour at the specified location\&.
.LP
This method isn\&'t available for \fIwxPostScriptDC\fR\& or \fIwxMetafileDC\fR\& (not implemented in wx) nor for any DC in wxOSX port and simply returns false there\&.
.LP
Note: Setting a pixel can be done using \fIdrawPoint/2\fR\&\&.
.LP
Note: This method shouldn\&'t be used with \fIwxPaintDC\fR\& as accessing the DC while drawing can result in unexpected results, notably in wxGTK\&.
.RE
.LP
.nf

.B
getPPI(This) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Returns the resolution of the device in pixels per inch\&.
.RE
.LP
.nf

.B
getSize(This) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
getSizeMM(This) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
getTextBackground(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current text background colour\&.
.LP
See: \fIsetTextBackground/2\fR\& 
.RE
.LP
.nf

.B
getTextExtent(This, String) -> {W :: integer(), H :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
String = unicode:chardata()
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
getTextExtent(This, String, Options :: [Option]) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = 
.br
    {W :: integer(),
.br
     H :: integer(),
.br
     Descent :: integer(),
.br
     ExternalLeading :: integer()}
.br
This = wxDC()
.br
String = unicode:chardata()
.br
Option = {theFont, wxFont:wxFont()}
.br
.RE
.RE
.RS
.LP
Gets the dimensions of the string using the currently selected font\&.
.LP
\fIstring\fR\& is the text string to measure, \fIdescent\fR\& is the dimension from the baseline of the font to the bottom of the descender, and \fIexternalLeading\fR\& is any extra vertical space added to the font by the font designer (usually is zero)\&.
.LP
The text extent is returned in \fIw\fR\& and \fIh\fR\& pointers or as a {Width,Height} object depending on which version of this function is used\&.
.LP
If the optional parameter \fIfont\fR\& is specified and valid, then it is used for the text extent calculation\&. Otherwise the currently selected font is\&.
.LP
If \fIstring\fR\& is empty, its extent is 0 in both directions, as expected\&.
.LP
Note: This function only works with single-line strings\&.
.LP
See: \fIwxFont\fR\&, \fIsetFont/2\fR\&, \fIgetPartialTextExtents/2\fR\&, \fIgetMultiLineTextExtent/3\fR\& 
.RE
.LP
.nf

.B
getTextForeground(This) -> wx:wx_colour4()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current text foreground colour\&.
.LP
See: \fIsetTextForeground/2\fR\& 
.RE
.LP
.nf

.B
getUserScale(This) -> {X :: number(), Y :: number()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the current user scale factor\&.
.LP
See: \fIsetUserScale/3\fR\& 
.RE
.LP
.nf

.B
gradientFillConcentric(This, Rect, InitialColour, DestColour) ->
.B
                          ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
InitialColour = DestColour = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Fill the area specified by rect with a radial gradient, starting from \fIinitialColour\fR\& at the centre of the circle and fading to \fIdestColour\fR\& on the circle outside\&.
.LP
The circle is placed at the centre of \fIrect\fR\&\&.
.LP
Note: Currently this function is very slow, don\&'t use it for real-time drawing\&.
.RE
.LP
.nf

.B
gradientFillConcentric(This, Rect, InitialColour, DestColour,
.B
                       CircleCenter) ->
.B
                          ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
InitialColour = DestColour = wx:wx_colour()
.br
CircleCenter = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Fill the area specified by rect with a radial gradient, starting from \fIinitialColour\fR\& at the centre of the circle and fading to \fIdestColour\fR\& on the circle outside\&.
.LP
\fIcircleCenter\fR\& are the relative coordinates of centre of the circle in the specified \fIrect\fR\&\&.
.LP
Note: Currently this function is very slow, don\&'t use it for real-time drawing\&.
.RE
.LP
.nf

.B
gradientFillLinear(This, Rect, InitialColour, DestColour) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
InitialColour = DestColour = wx:wx_colour()
.br
.RE
.RE
.LP
.nf

.B
gradientFillLinear(This, Rect, InitialColour, DestColour,
.B
                   Options :: [Option]) ->
.B
                      ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
InitialColour = DestColour = wx:wx_colour()
.br
Option = {nDirection, wx:wx_enum()}
.br
.RE
.RE
.RS
.LP
Fill the area specified by \fIrect\fR\& with a linear gradient, starting from \fIinitialColour\fR\& and eventually fading to \fIdestColour\fR\&\&.
.LP
The \fInDirection\fR\& specifies the direction of the colour change, default is to use \fIinitialColour\fR\& on the left part of the rectangle and \fIdestColour\fR\& on the right one\&.
.RE
.LP
.nf

.B
logicalToDeviceX(This, X) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
Converts logical X coordinate to device coordinate, using the current mapping mode, user scale factor, device origin and axis orientation\&.
.RE
.LP
.nf

.B
logicalToDeviceXRel(This, X) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = integer()
.br
.RE
.RE
.RS
.LP
Converts logical X coordinate to relative device coordinate, using the current mapping mode and user scale factor but ignoring the axis orientation\&.
.LP
Use this for converting a width, for example\&.
.RE
.LP
.nf

.B
logicalToDeviceY(This, Y) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
Converts logical Y coordinate to device coordinate, using the current mapping mode, user scale factor, device origin and axis orientation\&.
.RE
.LP
.nf

.B
logicalToDeviceYRel(This, Y) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Y = integer()
.br
.RE
.RE
.RS
.LP
Converts logical Y coordinate to relative device coordinate, using the current mapping mode and user scale factor but ignoring the axis orientation\&.
.LP
Use this for converting a height, for example\&.
.RE
.LP
.nf

.B
maxX(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the maximum horizontal extent used in drawing commands so far\&.
.RE
.LP
.nf

.B
maxY(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the maximum vertical extent used in drawing commands so far\&.
.RE
.LP
.nf

.B
minX(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the minimum horizontal extent used in drawing commands so far\&.
.RE
.LP
.nf

.B
minY(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Gets the minimum vertical extent used in drawing commands so far\&.
.RE
.LP
.nf

.B
isOk(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Returns true if the DC is ok to use\&.
.RE
.LP
.nf

.B
resetBoundingBox(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Resets the bounding box: after a call to this function, the bounding box doesn\&'t contain anything\&.
.LP
See: \fIcalcBoundingBox/3\fR\& 
.RE
.LP
.nf

.B
setAxisOrientation(This, XLeftRight, YBottomUp) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
XLeftRight = YBottomUp = boolean()
.br
.RE
.RE
.RS
.LP
Sets the x and y axis orientation (i\&.e\&. the direction from lowest to highest values on the axis)\&.
.LP
The default orientation is x axis from left to right and y axis from top down\&.
.RE
.LP
.nf

.B
setBackground(This, Brush) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Brush = wxBrush:wxBrush()
.br
.RE
.RE
.RS
.LP
Sets the current background brush for the DC\&.
.RE
.LP
.nf

.B
setBackgroundMode(This, Mode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Mode = integer()
.br
.RE
.RE
.RS
.LP
\fImode\fR\& may be one of \fIwxPENSTYLE_SOLID\fR\& and \fIwxPENSTYLE_TRANSPARENT\fR\&\&.
.LP
This setting determines whether text will be drawn with a background colour or not\&.
.RE
.LP
.nf

.B
setBrush(This, Brush) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Brush = wxBrush:wxBrush()
.br
.RE
.RE
.RS
.LP
Sets the current brush for the DC\&.
.LP
If the argument is ?wxNullBrush (or another invalid brush; see \fIwxBrush:isOk/1\fR\&), the current brush is selected out of the device context (leaving \fIwxDC\fR\& without any valid brush), allowing the current brush to be destroyed safely\&.
.LP
See: \fIwxBrush\fR\&, \fIwxMemoryDC\fR\&, (for the interpretation of colours when drawing into a monochrome bitmap)
.RE
.LP
.nf

.B
setClippingRegion(This, Rect) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Rect = 
.br
    {X :: integer(),
.br
     Y :: integer(),
.br
     W :: integer(),
.br
     H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
setClippingRegion(This, Pt, Sz) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pt = {X :: integer(), Y :: integer()}
.br
Sz = {W :: integer(), H :: integer()}
.br
.RE
.RE
.RS
.LP
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE
.LP
.nf

.B
setDeviceOrigin(This, X, Y) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
X = Y = integer()
.br
.RE
.RE
.RS
.LP
Sets the device origin (i\&.e\&. the origin in pixels after scaling has been applied)\&.
.LP
This function may be useful in Windows printing operations for placing a graphic on a page\&.
.RE
.LP
.nf

.B
setFont(This, Font) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Font = wxFont:wxFont()
.br
.RE
.RE
.RS
.LP
Sets the current font for the DC\&.
.LP
If the argument is ?wxNullFont (or another invalid font; see \fIwxFont:isOk/1\fR\&), the current font is selected out of the device context (leaving \fIwxDC\fR\& without any valid font), allowing the current font to be destroyed safely\&.
.LP
See: \fIwxFont\fR\& 
.RE
.LP
.nf

.B
setLayoutDirection(This, Dir) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Dir = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the current layout direction for the device context\&.
.LP
See: \fIgetLayoutDirection/1\fR\& 
.RE
.LP
.nf

.B
setLogicalFunction(This, Function) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Function = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Sets the current logical function for the device context\&.
.LP
Note: This function is not fully supported in all ports, due to the limitations of the underlying drawing model\&. Notably, \fIwxINVERT\fR\& which was commonly used for drawing rubber bands or other moving outlines in the past, is not, and will not, be supported by wxGTK3 and wxMac\&. The suggested alternative is to draw temporarily objects normally and refresh the (affected part of the) window to remove them later\&.
.LP
It determines how a \fIsource\fR\& pixel (from a pen or brush colour, or source device context if using \fIblit/6\fR\&) combines with a \fIdestination\fR\& pixel in the current device context\&. Text drawing is not affected by this function\&.
.LP
See ?wxRasterOperationMode enumeration values for more info\&.
.LP
The default is \fIwxCOPY\fR\&, which simply draws with the current colour\&. The others combine the current colour and the background using a logical operation\&.
.RE
.LP
.nf

.B
setMapMode(This, Mode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Mode = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
The mapping mode of the device context defines the unit of measurement used to convert \fIlogical\fR\& units to \fIdevice\fR\& units\&.
.LP
Note that in X, text drawing isn\&'t handled consistently with the mapping mode; a font is always specified in point size\&. However, setting the user scale (see \fIsetUserScale/3\fR\&) scales the text appropriately\&. In Windows, scalable TrueType fonts are always used; in X, results depend on availability of fonts, but usually a reasonable match is found\&.
.LP
The coordinate origin is always at the top left of the screen/printer\&.
.LP
Drawing to a Windows printer device context uses the current mapping mode, but mapping mode is currently ignored for PostScript output\&.
.RE
.LP
.nf

.B
setPalette(This, Palette) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Palette = wxPalette:wxPalette()
.br
.RE
.RE
.RS
.LP
If this is a window DC or memory DC, assigns the given palette to the window or bitmap associated with the DC\&.
.LP
If the argument is ?wxNullPalette, the current palette is selected out of the device context, and the original palette restored\&.
.LP
See: \fIwxPalette\fR\& 
.RE
.LP
.nf

.B
setPen(This, Pen) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Pen = wxPen:wxPen()
.br
.RE
.RE
.RS
.LP
Sets the current pen for the DC\&.
.LP
If the argument is ?wxNullPen (or another invalid pen; see \fIwxPen:isOk/1\fR\&), the current pen is selected out of the device context (leaving \fIwxDC\fR\& without any valid pen), allowing the current pen to be destroyed safely\&.
.LP
See: \fIwxMemoryDC\fR\&, for the interpretation of colours when drawing into a monochrome bitmap
.RE
.LP
.nf

.B
setTextBackground(This, Colour) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Colour = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Sets the current text background colour for the DC\&.
.RE
.LP
.nf

.B
setTextForeground(This, Colour) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Colour = wx:wx_colour()
.br
.RE
.RE
.RS
.LP
Sets the current text foreground colour for the DC\&.
.LP
See: \fIwxMemoryDC\fR\&, for the interpretation of colours when drawing into a monochrome bitmap
.RE
.LP
.nf

.B
setUserScale(This, XScale, YScale) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
XScale = YScale = number()
.br
.RE
.RE
.RS
.LP
Sets the user scaling factor, useful for applications which require \&'zooming\&'\&.
.RE
.LP
.nf

.B
startDoc(This, Message) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
Message = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Starts a document (only relevant when outputting to a printer)\&.
.LP
\fImessage\fR\& is a message to show while printing\&.
.RE
.LP
.nf

.B
startPage(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDC()
.br
.RE
.RE
.RS
.LP
Starts a document page (only relevant when outputting to a printer)\&.
.RE