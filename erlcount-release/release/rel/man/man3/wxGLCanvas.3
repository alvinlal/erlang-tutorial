.TH wxGLCanvas 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxGLCanvas \- Functions for wxGLCanvas class
.SH DESCRIPTION
.LP
\fIwxGLCanvas\fR\& is a class for displaying OpenGL graphics\&. It is always used in conjunction with \fIwxGLContext\fR\& as the context can only be made current (i\&.e\&. active for the OpenGL commands) when it is associated to a \fIwxGLCanvas\fR\&\&.
.LP
More precisely, you first need to create a \fIwxGLCanvas\fR\& window and then create an instance of a \fIwxGLContext\fR\& that is initialized with this \fIwxGLCanvas\fR\& and then later use either \fIsetCurrent/2\fR\& with the instance of the \fIwxGLContext\fR\& or \fIwxGLContext:setCurrent/2\fR\& with the instance of the \fIwxGLCanvas\fR\& (which might be not the same as was used for the creation of the context) to bind the OpenGL state that is represented by the rendering context to the canvas, and then finally call \fIswapBuffers/1\fR\& to swap the buffers of the OpenGL canvas and thus show your current output\&.
.LP
Please note that \fIwxGLContext\fR\& always uses physical pixels, even on the platforms where \fIwxWindow\fR\& uses logical pixels, affected by the coordinate scaling, on high DPI displays\&. Thus, if you want to set the OpenGL view port to the size of entire window, you must multiply the result returned by \fIwxWindow:getClientSize/1\fR\& by \fIwxWindow:getContentScaleFactor/1\fR\& before passing it to \fIglViewport()\fR\&\&. Same considerations apply to other OpenGL functions and other coordinates, notably those retrieved from \fIwxMouseEvent\fR\& in the event handlers\&.
.LP
Notice that versions of wxWidgets previous to 2\&.9 used to implicitly create a \fIwxGLContext\fR\& inside \fIwxGLCanvas\fR\& itself\&. This is still supported in the current version but is deprecated now and will be removed in the future, please update your code to create the rendering contexts explicitly\&.
.LP
To set up the attributes for the canvas (number of bits for the depth buffer, number of bits for the stencil buffer and so on) you pass them in the constructor using a \fIwxGLAttributes\fR\& (not implemented in wx) instance\&. You can still use the way before 3\&.1\&.0 (setting up the correct values of the \fIattribList\fR\& parameter) but it\&'s discouraged\&.
.LP
Note: On those platforms which use a configure script (e\&.g\&. Linux and macOS) OpenGL support is automatically enabled if the relative headers and libraries are found\&. To switch it on under the other platforms (e\&.g\&. Windows), you need to edit the \fIsetup\&.h\fR\& file and set \fIwxUSE_GLCANVAS\fR\& to \fI1\fR\& and then also pass \fIUSE_OPENGL=1\fR\& to the make utility\&. You may also need to add \fIopengl32\&.lib\fR\& (and \fIglu32\&.lib\fR\& for old OpenGL versions) to the list of the libraries your program is linked with\&.
.LP
See: \fIwxGLContext\fR\&, \fIwxGLAttributes\fR\& (not implemented in wx), \fIwxGLContextAttrs\fR\& (not implemented in wx)
.LP
This class is derived (and can use functions) from: \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxGLCanvas
.SH DATA TYPES
.nf

\fBwxGLCanvas()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new(Parent) -> wxGLCanvas()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Options :: [Option]) -> wxGLCanvas()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {attribList, [integer()]} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()} |
.br
    {name, unicode:chardata()} |
.br
    {palette, wxPalette:wxPalette()}
.br
.RE
.RE
.RS
.LP
This constructor is still available only for compatibility reasons\&.
.LP
Please use the constructor with \fIwxGLAttributes\fR\& (not implemented in wx) instead\&.
.LP
If \fIattribList\fR\& is not specified, \fIwxGLAttributes::PlatformDefaults()\fR\& (not implemented in wx) is used, plus some other attributes (see below)\&.
.RE
.LP
.nf

.B
setCurrent(This, Context) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGLCanvas()
.br
Context = wxGLContext:wxGLContext()
.br
.RE
.RE
.RS
.LP
Makes the OpenGL state that is represented by the OpenGL rendering context \fIcontext\fR\& current, i\&.e\&.
.LP
it will be used by all subsequent OpenGL calls\&.
.LP
This is equivalent to \fIwxGLContext:setCurrent/2\fR\& called with this window as parameter\&.
.LP
Note: This function may only be called when the window is shown on screen, in particular it can\&'t usually be called from the constructor as the window isn\&'t yet shown at this moment\&.
.LP
Return: false if an error occurred\&.
.RE
.LP
.nf

.B
createSurface(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGLCanvas()
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
isDisplaySupported(AttribList) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
AttribList = [integer()]
.br
.RE
.RE
.RS
.LP
Determines if a canvas having the specified attributes is available\&.
.LP
This only applies for visual attributes, not rendering context attributes\&. Please, use the new form of this method, using \fIwxGLAttributes\fR\& (not implemented in wx)\&.
.LP
Return: true if attributes are supported\&.
.RE
.LP
.nf

.B
swapBuffers(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxGLCanvas()
.br
.RE
.RE
.RS
.LP
Swaps the double-buffer of this window, making the back-buffer the front-buffer and vice versa, so that the output of the previous OpenGL commands is displayed on the window\&.
.LP
Return: false if an error occurred\&.
.RE
.LP
.nf

.B
destroy(This :: wxGLCanvas()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the object\&.
.RE