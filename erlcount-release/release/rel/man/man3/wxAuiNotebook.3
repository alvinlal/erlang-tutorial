.TH wxAuiNotebook 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxAuiNotebook \- Functions for wxAuiNotebook class
.SH DESCRIPTION
.LP
\fIwxAuiNotebook\fR\& is part of the wxAUI class framework, which represents a notebook control, managing multiple windows with associated tabs\&.
.LP
See also overview_aui\&.
.LP
\fIwxAuiNotebook\fR\& is a notebook control which implements many features common in applications with dockable panes\&. Specifically, \fIwxAuiNotebook\fR\& implements functionality which allows the user to rearrange tab order via drag-and-drop, split the tab window into many different splitter configurations, and toggle through different themes to customize the control\&'s look and feel\&.
.LP
The default theme that is used is \fIwxAuiDefaultTabArt\fR\& (not implemented in wx), which provides a modern, glossy look and feel\&. The theme can be changed by calling \fIsetArtProvider/2\fR\&\&.
.LP
Styles
.LP
This class supports the following styles:
.LP
This class is derived (and can use functions) from: \fIwxControl\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxAuiNotebook
.SH "EVENTS"

.LP
Event types emitted from this class: \fIcommand_auinotebook_page_close\fR\&, \fIcommand_auinotebook_page_closed\fR\&, \fIcommand_auinotebook_page_changed\fR\&, \fIcommand_auinotebook_page_changing\fR\&, \fIcommand_auinotebook_button\fR\&, \fIcommand_auinotebook_begin_drag\fR\&, \fIcommand_auinotebook_end_drag\fR\&, \fIcommand_auinotebook_drag_motion\fR\&, \fIcommand_auinotebook_allow_dnd\fR\&, \fIcommand_auinotebook_drag_done\fR\&, \fIcommand_auinotebook_tab_middle_down\fR\&, \fIcommand_auinotebook_tab_middle_up\fR\&, \fIcommand_auinotebook_tab_right_down\fR\&, \fIcommand_auinotebook_tab_right_up\fR\&, \fIcommand_auinotebook_bg_dclick\fR\&
.SH DATA TYPES
.nf

\fBwxAuiNotebook()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxAuiNotebook()
.br
.fi
.br
.RS
.LP
Default ctor\&.
.RE
.LP
.nf

.B
new(Parent) -> wxAuiNotebook()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Options :: [Option]) -> wxAuiNotebook()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Constructor\&.
.LP
Creates a wxAuiNotebok control\&.
.RE
.LP
.nf

.B
addPage(This, Page, Caption) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = wxWindow:wxWindow()
.br
Caption = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
addPage(This, Page, Caption, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = wxWindow:wxWindow()
.br
Caption = unicode:chardata()
.br
Option = {select, boolean()} | {bitmap, wxBitmap:wxBitmap()}
.br
.RE
.RE
.RS
.LP
Adds a page\&.
.LP
If the \fIselect\fR\& parameter is true, calling this will generate a page change event\&.
.RE
.LP
.nf

.B
addPage(This, Page, Text, Select, ImageId) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Select = boolean()
.br
ImageId = integer()
.br
.RE
.RE
.RS
.LP
Adds a new page\&.
.LP
The page must have the book control itself as the parent and must not have been added to this control previously\&.
.LP
The call to this function may generate the page changing events\&.
.LP
Return: true if successful, false otherwise\&.
.LP
Remark: Do not delete the page, it will be deleted by the book control\&.
.LP
See: \fIinsertPage/6\fR\& 
.LP
Since: 2\&.9\&.3
.RE
.LP
.nf

.B
create(This, Parent) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Parent = wxWindow:wxWindow()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Winid) -> boolean()
.br
.fi
.br
.nf

.B
create(This, Parent, Winid :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Parent = wxWindow:wxWindow()
.br
Option = 
.br
    {id, integer()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Creates the notebook window\&.
.RE
.LP
.nf

.B
create(This, Parent, Winid, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Parent = wxWindow:wxWindow()
.br
Winid = integer()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Constructs the book control with the given parameters\&.
.RE
.LP
.nf

.B
deletePage(This, Page) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Deletes a page at the given index\&.
.LP
Calling this method will generate a page change event\&.
.RE
.LP
.nf

.B
getArtProvider(This) -> wxAuiTabArt:wxAuiTabArt()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
.RE
.RE
.RS
.LP
Returns the associated art provider\&.
.RE
.LP
.nf

.B
getPage(This, Page_idx) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page_idx = integer()
.br
.RE
.RE
.RS
.LP
Returns the page specified by the given index\&.
.RE
.LP
.nf

.B
getPageBitmap(This, Page) -> wxBitmap:wxBitmap()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Returns the tab bitmap for the page\&.
.RE
.LP
.nf

.B
getPageCount(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
.RE
.RE
.RS
.LP
Returns the number of pages in the notebook\&.
.RE
.LP
.nf

.B
getPageIndex(This, Page_wnd) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page_wnd = wxWindow:wxWindow()
.br
.RE
.RE
.RS
.LP
Returns the page index for the specified window\&.
.LP
If the window is not found in the notebook, wxNOT_FOUND is returned\&.
.RE
.LP
.nf

.B
getPageText(This, Page) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Returns the tab label for the page\&.
.RE
.LP
.nf

.B
getSelection(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
.RE
.RE
.RS
.LP
Returns the currently selected page\&.
.RE
.LP
.nf

.B
insertPage(This, Page_idx, Page, Caption) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page_idx = integer()
.br
Page = wxWindow:wxWindow()
.br
Caption = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
insertPage(This, Page_idx, Page, Caption, Options :: [Option]) ->
.B
              boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page_idx = integer()
.br
Page = wxWindow:wxWindow()
.br
Caption = unicode:chardata()
.br
Option = {select, boolean()} | {bitmap, wxBitmap:wxBitmap()}
.br
.RE
.RE
.RS
.LP
\fIinsertPage/6\fR\& is similar to AddPage, but allows the ability to specify the insert location\&.
.LP
If the \fIselect\fR\& parameter is true, calling this will generate a page change event\&.
.RE
.LP
.nf

.B
insertPage(This, Index, Page, Text, Select, ImageId) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Index = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Select = boolean()
.br
ImageId = integer()
.br
.RE
.RE
.RS
.LP
Inserts a new page at the specified position\&.
.LP
Return: true if successful, false otherwise\&.
.LP
Remark: Do not delete the page, it will be deleted by the book control\&.
.LP
See: \fIaddPage/5\fR\& 
.LP
Since: 2\&.9\&.3
.RE
.LP
.nf

.B
removePage(This, Page) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Removes a page, without deleting the window pointer\&.
.RE
.LP
.nf

.B
setArtProvider(This, Art) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Art = wxAuiTabArt:wxAuiTabArt()
.br
.RE
.RE
.RS
.LP
Sets the art provider to be used by the notebook\&.
.RE
.LP
.nf

.B
setFont(This, Font) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Font = wxFont:wxFont()
.br
.RE
.RE
.RS
.LP
Sets the font for drawing the tab labels, using a bold version of the font for selected tab labels\&.
.RE
.LP
.nf

.B
setPageBitmap(This, Page, Bitmap) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = integer()
.br
Bitmap = wxBitmap:wxBitmap()
.br
.RE
.RE
.RS
.LP
Sets the bitmap for the page\&.
.LP
To remove a bitmap from the tab caption, pass wxNullBitmap\&.
.RE
.LP
.nf

.B
setPageText(This, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Page = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Sets the tab label for the page\&.
.RE
.LP
.nf

.B
setSelection(This, New_page) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
New_page = integer()
.br
.RE
.RE
.RS
.LP
Sets the page selection\&.
.LP
Calling this method will generate a page change event\&.
.RE
.LP
.nf

.B
setTabCtrlHeight(This, Height) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Height = integer()
.br
.RE
.RE
.RS
.LP
Sets the tab height\&.
.LP
By default, the tab control height is calculated by measuring the text height and bitmap sizes on the tab captions\&. Calling this method will override that calculation and set the tab control to the specified height parameter\&. A call to this method will override any call to \fIsetUniformBitmapSize/2\fR\&\&.
.LP
Specifying -1 as the height will return the control to its default auto-sizing behaviour\&.
.RE
.LP
.nf

.B
setUniformBitmapSize(This, Size) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxAuiNotebook()
.br
Size = {W :: integer(), H :: integer()}
.br
.RE
.RE
.RS
.LP
Ensure that all tabs have the same height, even if some of them don\&'t have bitmaps\&.
.LP
Passing ?wxDefaultSize as \fIsize\fR\& undoes the effect of a previous call to this function and instructs the control to use dynamic tab height\&.
.RE
.LP
.nf

.B
destroy(This :: wxAuiNotebook()) -> ok
.br
.fi
.br
.RS
.LP
Destroys the object\&.
.RE