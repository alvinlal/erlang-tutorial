.TH wx_misc 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wx_misc \- Miscellaneous functions.
.SH DESCRIPTION
.LP
Miscellaneous functions\&.
.SH EXPORTS
.LP
.nf

.B
displaySize() -> {Width :: integer(), Height :: integer()}
.br
.fi
.br
.RS
.LP
Returns the display size in pixels\&.
.LP
Note: Use of this function is not recommended in the new code as it only works for the primary display\&. Use \fIwxDisplay:getGeometry/1\fR\& to retrieve the size of the appropriate display instead\&.
.LP
Either of output pointers can be NULL if the caller is not interested in the corresponding value\&.
.LP
See: \fIwxGetDisplaySize()\fR\& (not implemented in wx), \fIwxDisplay\fR\& 
.RE
.LP
.nf

.B
setCursor(Cursor) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cursor = wxCursor:wxCursor()
.br
.RE
.RE
.RS
.LP
Globally sets the cursor; only has an effect on Windows, Mac and GTK+\&.
.LP
You should call this function with wxNullCursor to restore the system cursor\&.
.LP
See: \fIwxCursor\fR\&, \fIwxWindow:setCursor/2\fR\& 
.RE
.LP
.nf

.B
getKeyState(Key) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
For normal keys, returns true if the specified key is currently down\&.
.LP
For togglable keys (Caps Lock, Num Lock and Scroll Lock), returns true if the key is toggled such that its LED indicator is lit\&. There is currently no way to test whether togglable keys are up or down\&.
.LP
Even though there are virtual key codes defined for mouse buttons, they cannot be used with this function currently\&.
.LP
In wxGTK, this function can be only used with modifier keys (\fIWXK_ALT\fR\&, \fIWXK_CONTROL\fR\& and \fIWXK_SHIFT\fR\&) when not using X11 backend currently\&.
.RE
.LP
.nf

.B
getMousePosition() -> {X :: integer(), Y :: integer()}
.br
.fi
.br
.RS
.LP
Returns the mouse position in screen coordinates\&.
.RE
.LP
.nf

.B
getMouseState() -> wx:wx_wxMouseState()
.br
.fi
.br
.RS
.LP
Returns the current state of the mouse\&.
.LP
Returns a \fIwx_wxMouseState()\fR\& instance that contains the current position of the mouse pointer in screen coordinates, as well as boolean values indicating the up/down status of the mouse buttons and the modifier keys\&.
.RE
.LP
.nf

.B
setDetectableAutoRepeat(Flag) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Flag = boolean()
.br
.RE
.RE
.RS
.LP
Don\&'t synthesize KeyUp events holding down a key and producing KeyDown events with autorepeat\&.
.LP
On by default and always on in wxMSW\&.
.RE
.LP
.nf

.B
bell() -> ok
.br
.fi
.br
.RS
.LP
Ring the system bell\&.
.LP
Note: This function is categorized as a GUI one and so is not thread-safe\&.
.RE
.LP
.nf

.B
findMenuItemId(Frame, MenuString, ItemString) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Frame = wxFrame:wxFrame()
.br
MenuString = ItemString = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Find a menu item identifier associated with the given frame\&'s menu bar\&.
.RE
.LP
.nf

.B
findWindowAtPoint(Pt) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Find the deepest window at the given mouse position in screen coordinates, returning the window if found, or NULL if not\&.
.LP
This function takes child windows at the given position into account even if they are disabled\&. The hidden children are however skipped by it\&.
.RE
.LP
.nf

.B
beginBusyCursor() -> ok
.br
.fi
.br
.LP
.nf

.B
beginBusyCursor(Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Option = {cursor, wxCursor:wxCursor()}
.br
.RE
.RE
.RS
.LP
Changes the cursor to the given cursor for all windows in the application\&.
.LP
Use \fIendBusyCursor/0\fR\& to revert the cursor back to its previous state\&. These two calls can be nested, and a counter ensures that only the outer calls take effect\&.
.LP
See: \fIisBusy/0\fR\&, \fIwxBusyCursor\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
endBusyCursor() -> ok
.br
.fi
.br
.RS
.LP
Changes the cursor back to the original cursor, for all windows in the application\&.
.LP
Use with \fIbeginBusyCursor/1\fR\&\&.
.LP
See: \fIisBusy/0\fR\&, \fIwxBusyCursor\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
isBusy() -> boolean()
.br
.fi
.br
.RS
.LP
Returns true if between two \fIbeginBusyCursor/1\fR\& and \fIendBusyCursor/0\fR\& calls\&.
.LP
See: \fIwxBusyCursor\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
shutdown() -> boolean()
.br
.fi
.br
.LP
.nf

.B
shutdown(Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Option = {flags, integer()}
.br
.RE
.RE
.RS
.LP
This function shuts down or reboots the computer depending on the value of the \fIflags\fR\&\&.
.LP
Note: Note that performing the shutdown requires the corresponding access rights (superuser under Unix, SE_SHUTDOWN privilege under Windows) and that this function is only implemented under Unix and MSW\&.
.LP
Return: true on success, false if an error occurred\&.
.RE
.LP
.nf

.B
shell() -> boolean()
.br
.fi
.br
.LP
.nf

.B
shell(Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Option = {command, unicode:chardata()}
.br
.RE
.RE
.RS
.LP
Executes a command in an interactive shell window\&.
.LP
If no command is specified, then just the shell is spawned\&.
.LP
See: \fIwxExecute()\fR\& (not implemented in wx), Examples 
.RE
.LP
.nf

.B
launchDefaultBrowser(Url) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Url = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
launchDefaultBrowser(Url, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Url = unicode:chardata()
.br
Option = {flags, integer()}
.br
.RE
.RE
.RS
.LP
Opens the \fIurl\fR\& in user\&'s default browser\&.
.LP
If the \fIflags\fR\& parameter contains \fIwxBROWSER_NEW_WINDOW\fR\& flag, a new window is opened for the URL (currently this is only supported under Windows)\&.
.LP
And unless the \fIflags\fR\& parameter contains \fIwxBROWSER_NOBUSYCURSOR\fR\& flag, a busy cursor is shown while the browser is being launched (using \fIwxBusyCursor\fR\& (not implemented in wx))\&.
.LP
The parameter \fIurl\fR\& is interpreted as follows:
.LP
Returns true if the application was successfully launched\&.
.LP
Note: For some configurations of the running user, the application which is launched to open the given URL may be URL-dependent (e\&.g\&. a browser may be used for local URLs while another one may be used for remote URLs)\&.
.LP
See: \fIwxLaunchDefaultApplication()\fR\& (not implemented in wx), \fIwxExecute()\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
getEmailAddress() -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Copies the user\&'s email address into the supplied buffer, by concatenating the values returned by \fIwxGetFullHostName()\fR\& (not implemented in wx) and \fIgetUserId/0\fR\&\&.
.LP
Return: true if successful, false otherwise\&.
.RE
.LP
.nf

.B
getUserId() -> unicode:charlist()
.br
.fi
.br
.RS
.LP
This function returns the "user id" also known as "login name" under Unix (i\&.e\&.
.LP
something like "jsmith")\&. It uniquely identifies the current user (on this system)\&. Under Windows or NT, this function first looks in the environment variables USER and LOGNAME; if neither of these is found, the entry \fIUserId\fR\& in the \fIwxWidgets\fR\& section of the WIN\&.INI file is tried\&.
.LP
Return: The login name if successful or an empty string otherwise\&.
.LP
See: \fIwxGetUserName()\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
getHomeDir() -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Return the (current) user\&'s home directory\&.
.LP
See: \fIwxGetUserHome()\fR\& (not implemented in wx), \fIwxStandardPaths\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
newId() -> integer()
.br
.fi
.br
.RS
.LP
Deprecated: Ids generated by it can conflict with the Ids defined by the user code, use \fIwxID_ANY\fR\& to assign ids which are guaranteed to not conflict with the user-defined ids for the controls and menu items you create instead of using this function\&.
.LP
Generates an integer identifier unique to this run of the program\&.
.RE
.LP
.nf

.B
registerId(Id) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Id = integer()
.br
.RE
.RE
.RS
.LP
Ensures that Ids subsequently generated by \fInewId/0\fR\& do not clash with the given \fIid\fR\&\&.
.RE
.LP
.nf

.B
getCurrentId() -> integer()
.br
.fi
.br
.RS
.LP
Returns the current id\&.
.RE
.LP
.nf

.B
getOsDescription() -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Returns the string containing the description of the current platform in a user-readable form\&.
.LP
For example, this function may return strings like "Windows 10 (build 10240), 64-bit edition" or "Linux 4\&.1\&.4 i386"\&.
.LP
See: \fIwxGetOsVersion()\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
isPlatformLittleEndian() -> boolean()
.br
.fi
.br
.RS
.LP
Returns true if the current platform is little endian (instead of big endian)\&.
.LP
The check is performed at run-time\&.
.RE
.LP
.nf

.B
isPlatform64Bit() -> boolean()
.br
.fi
.br
.RS
.LP
Returns true if the operating system the program is running under is 64 bit\&.
.LP
The check is performed at run-time and may differ from the value available at compile-time (at compile-time you can just check if \fIsizeof(void*) == 8\fR\&) since the program could be running in emulation mode or in a mixed 32/64 bit system (bi-architecture operating system)\&.
.LP
Note: This function is not 100% reliable on some systems given the fact that there isn\&'t always a standard way to do a reliable check on the OS architecture\&.
.RE