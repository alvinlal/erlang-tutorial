.TH crypto 3 "crypto 5.1.4" "Ericsson AB" "Erlang Module Definition"
.SH NAME
crypto \- Crypto Functions
.SH DESCRIPTION
.LP
This module provides a set of cryptographic functions\&.
.RS 2
.TP 2
.B
Hash functions:

.RS 2
.TP 2
.B
SHA1, SHA2:
 Secure Hash Standard [FIPS PUB 180-4] 
.TP 2
.B
SHA3:
 SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [FIPS PUB 202] 
.TP 2
.B
BLAKE2:
BLAKE2 â€” fast secure hashing
.TP 2
.B
MD5:
The MD5 Message Digest Algorithm [RFC 1321]
.TP 2
.B
MD4:
The MD4 Message Digest Algorithm [RFC 1320]
.RE
.RS 2
.LP

.RE
.TP 2
.B
MACs - Message Authentication Codes:

.RS 2
.TP 2
.B
Hmac functions:
 Keyed-Hashing for Message Authentication [RFC 2104] 
.TP 2
.B
Cmac functions:
 The AES-CMAC Algorithm [RFC 4493] 
.TP 2
.B
POLY1305:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Symmetric Ciphers:

.RS 2
.TP 2
.B
DES, 3DES and AES:
Block Cipher Techniques [NIST]
.TP 2
.B
Blowfish:
 Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp\&. 191-204\&. 
.TP 2
.B
Chacha20:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.TP 2
.B
Chacha20_poly1305:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Modes:

.RS 2
.TP 2
.B
ECB, CBC, CFB, OFB and CTR:
 Recommendation for Block Cipher Modes of Operation: Methods and Techniques [NIST SP 800-38A] 
.TP 2
.B
GCM:
 Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC [NIST SP 800-38D] 
.TP 2
.B
CCM:
 Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality [NIST SP 800-38C] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Asymmetric Ciphers - Public Key Techniques:

.RS 2
.TP 2
.B
RSA:
 PKCS #1: RSA Cryptography Specifications [RFC 3447] 
.TP 2
.B
DSS:
 Digital Signature Standard (DSS) [FIPS 186-4] 
.TP 2
.B
ECDSA:
 Elliptic Curve Digital Signature Algorithm [ECDSA] 
.TP 2
.B
SRP:
 The SRP Authentication and Key Exchange System [RFC 2945] 
.RE
.RS 2
.LP

.RE
.RE
.LP

.RS -4
.B
Note:
.RE
The actual supported algorithms and features depends on their availability in the actual libcrypto used\&. See the crypto (App) about dependencies\&.
.LP
Enabling FIPS mode will also disable algorithms and features\&.

.LP
The CRYPTO User\&'s Guide has more information on FIPS, Engines and Algorithm Details like key lengths\&.
.SH DATA TYPES
.SS Ciphers
.nf

\fBcipher()\fR\& = cipher_no_iv() | cipher_iv() | cipher_aead()
.br
.fi
.RS
.RE
.nf

\fBcipher_no_iv()\fR\& = 
.br
    aes_128_ecb | aes_192_ecb | aes_256_ecb | aes_ecb |
.br
    blowfish_ecb | des_ecb | rc4
.br
.fi
.RS
.RE
.nf

\fBcipher_iv()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_cbc |
.br
    aes_128_ofb | aes_192_ofb | aes_256_ofb | aes_128_cfb128 |
.br
    aes_192_cfb128 | aes_256_cfb128 | aes_cfb128 | aes_128_cfb8 |
.br
    aes_192_cfb8 | aes_256_cfb8 | aes_cfb8 | aes_128_ctr |
.br
    aes_192_ctr | aes_256_ctr | aes_ctr | blowfish_cbc |
.br
    blowfish_cfb64 | blowfish_ofb64 | chacha20 | des_ede3_cbc |
.br
    des_ede3_cfb | des_cbc | des_cfb | rc2_cbc
.br
.fi
.RS
.RE
.nf

\fBcipher_aead()\fR\& = 
.br
    aes_128_ccm | aes_192_ccm | aes_256_ccm | aes_ccm |
.br
    aes_128_gcm | aes_192_gcm | aes_256_gcm | aes_gcm |
.br
    chacha20_poly1305
.br
.fi
.RS
.LP
Ciphers known by the CRYPTO application\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.nf

\fBcrypto_opts()\fR\& = boolean() | [crypto_opt()]
.br
.fi
.nf

\fBcrypto_opt()\fR\& = {encrypt, boolean()} | {padding, padding()}
.br
.fi
.RS
.LP
Selects encryption (\fI{encrypt,true}\fR\&) or decryption (\fI{encrypt,false}\fR\&)\&.
.RE
.nf

\fBpadding()\fR\& = cryptolib_padding() | otp_padding()
.br
.fi
.RS
.LP
This option handles padding in the last block\&. If not set, no padding is done and any bytes in the last unfilled block is silently discarded\&.
.RE
.nf

\fBcryptolib_padding()\fR\& = none | pkcs_padding
.br
.fi
.RS
.LP
The \fIcryptolib_padding\fR\& are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app\&.
.LP
For OpenSSL, see the OpenSSL documentation\&. and find \fIEVP_CIPHER_CTX_set_padding()\fR\& in cryptolib for your linked version\&.
.RE
.nf

\fBotp_padding()\fR\& = zero | random
.br
.fi
.RS
.LP
Erlang/OTP adds a either padding of zeroes or padding with random bytes\&.
.RE
.SS Digests and hash
.nf

\fBhash_algorithm()\fR\& = 
.br
    sha1() |
.br
    sha2() |
.br
    sha3() |
.br
    blake2() |
.br
    ripemd160 |
.br
    compatibility_only_hash()
.br
.fi
.RS
.RE
.nf

\fBhmac_hash_algorithm()\fR\& = 
.br
    sha1() | sha2() | sha3() | compatibility_only_hash()
.br
.fi
.RS
.RE
.nf

\fBcmac_cipher_algorithm()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_cbc |
.br
    aes_128_cfb128 | aes_192_cfb128 | aes_256_cfb128 |
.br
    aes_cfb128 | aes_128_cfb8 | aes_192_cfb8 | aes_256_cfb8 |
.br
    aes_cfb8 | blowfish_cbc | des_cbc | des_ede3_cbc | rc2_cbc
.br
.fi
.RS
.RE
.nf

\fBrsa_digest_type()\fR\& = sha1() | sha2() | md5 | ripemd160
.br
.fi
.RS
.RE
.nf

\fBdss_digest_type()\fR\& = sha1() | sha2()
.br
.fi
.RS
.RE
.nf

\fBecdsa_digest_type()\fR\& = sha1() | sha2()
.br
.fi
.RS
.RE
.nf

\fBsha1()\fR\& = sha
.br
.fi
.nf

\fBsha2()\fR\& = sha224 | sha256 | sha384 | sha512
.br
.fi
.nf

\fBsha3()\fR\& = sha3_224 | sha3_256 | sha3_384 | sha3_512
.br
.fi
.nf

\fBblake2()\fR\& = blake2b | blake2s
.br
.fi
.RS
.RE
.nf

\fBcompatibility_only_hash()\fR\& = md5 | md4
.br
.fi
.RS
.LP
The \fIcompatibility_only_hash()\fR\& algorithms are recommended only for compatibility with existing applications\&.
.RE
.SS Elliptic Curves
.nf

\fBec_named_curve()\fR\& = 
.br
    brainpoolP160r1 | brainpoolP160t1 | brainpoolP192r1 |
.br
    brainpoolP192t1 | brainpoolP224r1 | brainpoolP224t1 |
.br
    brainpoolP256r1 | brainpoolP256t1 | brainpoolP320r1 |
.br
    brainpoolP320t1 | brainpoolP384r1 | brainpoolP384t1 |
.br
    brainpoolP512r1 | brainpoolP512t1 | c2pnb163v1 | c2pnb163v2 |
.br
    c2pnb163v3 | c2pnb176v1 | c2pnb208w1 | c2pnb272w1 |
.br
    c2pnb304w1 | c2pnb368w1 | c2tnb191v1 | c2tnb191v2 |
.br
    c2tnb191v3 | c2tnb239v1 | c2tnb239v2 | c2tnb239v3 |
.br
    c2tnb359v1 | c2tnb431r1 | ipsec3 | ipsec4 | prime192v1 |
.br
    prime192v2 | prime192v3 | prime239v1 | prime239v2 |
.br
    prime239v3 | prime256v1 | secp112r1 | secp112r2 | secp128r1 |
.br
    secp128r2 | secp160k1 | secp160r1 | secp160r2 | secp192k1 |
.br
    secp192r1 | secp224k1 | secp224r1 | secp256k1 | secp256r1 |
.br
    secp384r1 | secp521r1 | sect113r1 | sect113r2 | sect131r1 |
.br
    sect131r2 | sect163k1 | sect163r1 | sect163r2 | sect193r1 |
.br
    sect193r2 | sect233k1 | sect233r1 | sect239k1 | sect283k1 |
.br
    sect283r1 | sect409k1 | sect409r1 | sect571k1 | sect571r1 |
.br
    wtls1 | wtls10 | wtls11 | wtls12 | wtls3 | wtls4 | wtls5 |
.br
    wtls6 | wtls7 | wtls8 | wtls9
.br
.fi
.nf

\fBedwards_curve_dh()\fR\& = x25519 | x448
.br
.fi
.nf

\fBedwards_curve_ed()\fR\& = ed25519 | ed448
.br
.fi
.RS
.LP
Note that some curves are disabled if FIPS is enabled\&.
.RE
.nf

\fBec_explicit_curve()\fR\& = 
.br
    {Field :: ec_field(),
.br
     Curve :: ec_curve(),
.br
     BasePoint :: binary(),
.br
     Order :: binary(),
.br
     CoFactor :: none | binary()}
.br
.fi
.nf

\fBec_field()\fR\& = ec_prime_field() | ec_characteristic_two_field()
.br
.fi
.nf

\fBec_curve()\fR\& = 
.br
    {A :: binary(), B :: binary(), Seed :: none | binary()}
.br
.fi
.RS
.LP
Parametric curve definition\&.
.RE
.nf

\fBec_prime_field()\fR\& = {prime_field, Prime :: integer()}
.br
.fi
.nf

\fBec_characteristic_two_field()\fR\& = 
.br
    {characteristic_two_field,
.br
     M :: integer(),
.br
     Basis :: ec_basis()}
.br
.fi
.nf

\fBec_basis()\fR\& = 
.br
    {tpbasis, K :: integer() >= 0} |
.br
    {ppbasis,
.br
     K1 :: integer() >= 0,
.br
     K2 :: integer() >= 0,
.br
     K3 :: integer() >= 0} |
.br
    onbasis
.br
.fi
.RS
.LP
Curve definition details\&.
.RE
.SS Keys
.nf

\fBkey_integer()\fR\& = integer() | binary()
.br
.fi
.RS
.LP
Always \fIbinary()\fR\& when used as return value
.RE
.SS Public/Private Keys
.nf

\fBrsa_public()\fR\& = [key_integer()]
.br
.fi
.nf

\fBrsa_private()\fR\& = [key_integer()]
.br
.fi
.nf

\fBrsa_params()\fR\& = 
.br
    {ModulusSizeInBits :: integer(),
.br
     PublicExponent :: key_integer()}
.br
.fi
.RS
.LP
.nf
rsa_public() = [E, N]
.fi
.LP
.nf
rsa_private() = [E, N, D] | [E, N, D, P1, P2, E1, E2, C]
.fi
.LP
Where E is the public exponent, N is public modulus and D is the private exponent\&. The longer key format contains redundant information that will make the calculation faster\&. P1 and P2 are first and second prime factors\&. E1 and E2 are first and second exponents\&. C is the CRT coefficient\&. The terminology is taken from  RFC 3447\&.
.RE
.nf

\fBdss_public()\fR\& = [key_integer()]
.br
.fi
.nf

\fBdss_private()\fR\& = [key_integer()]
.br
.fi
.RS
.LP
.nf
dss_public() = [P, Q, G, Y] 
.fi
.LP
Where P, Q and G are the dss parameters and Y is the public key\&.
.LP
.nf
dss_private() = [P, Q, G, X] 
.fi
.LP
Where P, Q and G are the dss parameters and X is the private key\&.
.RE
.nf

\fBecdsa_public()\fR\& = key_integer()
.br
.fi
.nf

\fBecdsa_private()\fR\& = key_integer()
.br
.fi
.nf

\fBecdsa_params()\fR\& = ec_named_curve() | ec_explicit_curve()
.br
.fi
.RS
.RE
.nf

\fBeddsa_public()\fR\& = key_integer()
.br
.fi
.nf

\fBeddsa_private()\fR\& = key_integer()
.br
.fi
.nf

\fBeddsa_params()\fR\& = edwards_curve_ed()
.br
.fi
.RS
.RE
.nf

\fBsrp_public()\fR\& = key_integer()
.br
.fi
.nf

\fBsrp_private()\fR\& = key_integer()
.br
.fi
.RS
.LP
.nf
srp_public() = key_integer() 
.fi
.LP
Where is \fIA\fR\& or \fIB\fR\& from SRP design
.LP
.nf
srp_private() = key_integer() 
.fi
.LP
Where is \fIa\fR\& or \fIb\fR\& from SRP design
.RE
.nf

\fBsrp_gen_params()\fR\& = 
.br
    {user, srp_user_gen_params()} | {host, srp_host_gen_params()}
.br
.fi
.nf

\fBsrp_comp_params()\fR\& = 
.br
    {user, srp_user_comp_params()} |
.br
    {host, srp_host_comp_params()}
.br
.fi
.nf

.B
srp_user_gen_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom()]
.br
.fi
.nf

.B
srp_host_gen_params() = [Verifier::binary(), Prime::binary(), Version::atom() ]
.br
.fi
.nf

.B
srp_user_comp_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | ScramblerArg::list()]
.br
.fi
.nf

.B
srp_host_comp_params() = [Verifier::binary(), Prime::binary(), Version::atom() | ScramblerArg::list()]
.br
.fi
.RS
.LP
Where Verifier is \fIv\fR\&, Generator is \fIg\fR\& and Prime is\fI N\fR\&, DerivedKey is \fIX\fR\&, and Scrambler is \fIu\fR\& (optional will be generated if not provided) from SRP design Version = \&'3\&' | \&'6\&' | \&'6a\&'
.RE
.SS Public Key Ciphers
.nf

\fBpk_encrypt_decrypt_algs()\fR\& = rsa
.br
.fi
.RS
.LP
Algorithms for public key encrypt/decrypt\&. Only RSA is supported\&.
.RE
.nf

\fBpk_encrypt_decrypt_opts()\fR\& = [rsa_opt()] | rsa_compat_opts()
.br
.fi
.nf

\fBrsa_opt()\fR\& = 
.br
    {rsa_padding, rsa_padding()} |
.br
    {signature_md, atom()} |
.br
    {rsa_mgf1_md, sha} |
.br
    {rsa_oaep_label, binary()} |
.br
    {rsa_oaep_md, sha}
.br
.fi
.nf

\fBrsa_padding()\fR\& = 
.br
    rsa_pkcs1_padding | rsa_pkcs1_oaep_padding |
.br
    rsa_sslv23_padding | rsa_x931_padding | rsa_no_padding
.br
.fi
.RS
.LP
Options for public key encrypt/decrypt\&. Only RSA is supported\&.
.LP

.RS -4
.B
Warning:
.RE
.LP
The RSA options are experimental\&.
.LP
The exact set of options and there syntax \fImay\fR\& be changed without prior notice\&.

.RE
.nf

\fBrsa_compat_opts()\fR\& = [{rsa_pad, rsa_padding()}] | rsa_padding()
.br
.fi
.RS
.LP
Those option forms are kept only for compatibility and should not be used in new code\&.
.RE
.SS Public Key Sign and Verify
.nf

\fBpk_sign_verify_algs()\fR\& = rsa | dss | ecdsa | eddsa
.br
.fi
.RS
.LP
Algorithms for sign and verify\&.
.RE
.nf

\fBpk_sign_verify_opts()\fR\& = [rsa_sign_verify_opt()]
.br
.fi
.nf

\fBrsa_sign_verify_opt()\fR\& = 
.br
    {rsa_padding, rsa_sign_verify_padding()} |
.br
    {rsa_pss_saltlen, integer()} |
.br
    {rsa_mgf1_md, sha2()}
.br
.fi
.nf

\fBrsa_sign_verify_padding()\fR\& = 
.br
    rsa_pkcs1_padding | rsa_pkcs1_pss_padding | rsa_x931_padding |
.br
    rsa_no_padding
.br
.fi
.RS
.LP
Options for sign and verify\&.
.LP

.RS -4
.B
Warning:
.RE
.LP
The RSA options are experimental\&.
.LP
The exact set of options and there syntax \fImay\fR\& be changed without prior notice\&.

.RE
.SS Diffie-Hellman Keys and parameters
.nf

\fBdh_public()\fR\& = key_integer()
.br
.fi
.nf

\fBdh_private()\fR\& = key_integer()
.br
.fi
.RS
.RE
.nf

\fBdh_params()\fR\& = [key_integer()]
.br
.fi
.RS
.LP
.nf
dh_params() = [P, G] | [P, G, PrivateKeyBitLength]
.fi
.RE
.nf

\fBecdh_public()\fR\& = key_integer()
.br
.fi
.nf

\fBecdh_private()\fR\& = key_integer()
.br
.fi
.nf

\fBecdh_params()\fR\& = 
.br
    ec_named_curve() | edwards_curve_dh() | ec_explicit_curve()
.br
.fi
.RS
.RE
.SS Types for Engines
.nf

\fBengine_key_ref()\fR\& = 
.br
    #{engine := engine_ref(),
.br
      key_id := key_id(),
.br
      password => password(),
.br
      term() => term()}
.br
.fi
.nf

\fBengine_ref()\fR\& = term()
.br
.fi
.RS
.LP
The result of a call to engine_load/3\&.
.RE
.nf

\fBkey_id()\fR\& = string() | binary()
.br
.fi
.RS
.LP
Identifies the key to be used\&. The format depends on the loaded engine\&. It is passed to the \fIENGINE_load_(private|public)_key\fR\& functions in libcrypto\&.
.RE
.nf

\fBpassword()\fR\& = string() | binary()
.br
.fi
.RS
.LP
The password of the key stored in an engine\&.
.RE
.nf

\fBengine_method_type()\fR\& = 
.br
    engine_method_rsa | engine_method_dsa | engine_method_dh |
.br
    engine_method_rand | engine_method_ecdh |
.br
    engine_method_ecdsa | engine_method_ciphers |
.br
    engine_method_digests | engine_method_store |
.br
    engine_method_pkey_meths | engine_method_pkey_asn1_meths |
.br
    engine_method_ec
.br
.fi
.nf

\fBengine_cmnd()\fR\& = {unicode:chardata(), unicode:chardata()}
.br
.fi
.RS
.LP
Pre and Post commands for engine_load/3 and /4\&.
.RE
.SS Internal data types
.nf

\fBcrypto_state()\fR\&
.br
.fi
.nf

\fBhash_state()\fR\&
.br
.fi
.nf

\fBmac_state()\fR\&
.br
.fi
.RS
.LP
Contexts with an internal state that should not be manipulated but passed between function calls\&.
.RE
.SH "EXCEPTIONS"

.SS "Atoms - the older style"

.LP
The exception \fIerror:badarg\fR\& signifies that one or more arguments are of wrong data type, or are otherwise badly formed\&.
.LP
The exception \fIerror:notsup\fR\& signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that\&.
.LP
For a list of supported algorithms, see supports(ciphers)\&.
.SS "3-tuples - the new style"

.LP
The exception is:
.LP
.nf

error:{Tag, C_FileInfo, Description}

Tag = badarg | notsup | error
C_FileInfo = term()    % Usually only useful for the OTP maintainer
Description = string() % Clear text, sometimes only useful for the OTP maintainer
      
.fi
.LP
The exception tags are:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
Signifies that one or more arguments are of wrong data type or are otherwise badly formed\&.
.TP 2
.B
\fInotsup\fR\&:
Signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that one\&.
.TP 2
.B
\fIerror\fR\&:
An error condition that should not occur, for example a memory allocation failed or the underlying cryptolib returned an error code, for example \fI"Can\&'t initialize context, step 1"\fR\&\&. Those text usually needs searching the C-code to be understood\&.
.RE
.LP
Usually there are more information in the call stack about which argument caused the exception and what the values where\&.
.LP
To catch the exception, use for example:
.LP
.nf

try crypto:crypto_init(Ciph, Key, IV, true)
    catch
        error:{Tag, _C_FileInfo, Description} ->
            do_something(......)
         .....
end
	
.fi
.SH EXPORTS
.LP
.nf

.B
crypto_init(Cipher, Key, FlagOrOptions) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_no_iv()
.br
Key = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
State = crypto_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Equivalent to the call \fIcrypto_init(Cipher, Key, <<>>, FlagOrOptions)\fR\&\&. It is intended for ciphers without an IV (nounce)\&.
.RE
.LP
.nf

.B
crypto_init(Cipher, Key, IV, FlagOrOptions) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_iv()
.br
Key = IV = iodata()
.br
FlagOrOptions = crypto_opts()
.br
State = crypto_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Initializes a series of encryptions or decryptions and creates an internal state with a reference that is returned\&.
.LP
If \fIIV = <<>>\fR\&, no IV is used\&. This is intended for ciphers without an IV (nounce)\&. See crypto_init/3\&.
.LP
If \fIIV = undefined\fR\&, the IV must be added by calls to crypto_dyn_iv_update/3\&. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption\&. See crypto_dyn_iv_init/3\&.
.LP
The actual encryption or decryption is done by crypto_update/2 (or crypto_dyn_iv_update/3 )\&.
.LP
For encryption, set the \fIFlagOrOptions\fR\& to \fItrue\fR\& or \fI[{encrypt,true}]\fR\&\&. For decryption, set it to \fIfalse\fR\& or \fI[{encrypt,false}]\fR\&\&.
.LP
Padding could be enabled with the option {padding,Padding}\&. The cryptolib_padding enables \fIpkcs_padding\fR\& or no padding (\fInone\fR\&)\&. The paddings \fIzero\fR\& or \fIrandom\fR\& fills the last part of the last block with zeroes or random bytes\&. If the last block is already full, nothing is added\&.
.LP
In decryption, the cryptolib_padding removes such padding, if present\&. The otp_padding is not removed - it has to be done elsewhere\&.
.LP
If padding is \fI{padding,none}\fR\& or not specified and the total data from all subsequent crypto_updates does not fill the last block fully, that last data is lost\&. In case of \fI{padding,none}\fR\& there will be an error in this case\&. If padding is not specified, the bytes of the unfilled block is silently discarded\&.
.LP
The actual padding is performed by crypto_final/1\&.
.LP
For blocksizes call cipher_info/1\&.
.LP
See  examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
crypto_update(State, Data) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
Data = iodata()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
It does an actual crypto operation on a part of the full text\&. If the part is less than a number of full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining bytes are saved to the next \fIcrypto_update\fR\& operation\&. The \fIState\fR\& should be created with crypto_init/3 or crypto_init/4\&.
.LP
See  examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
crypto_dyn_iv_init(Cipher, Key, FlagOrOptions) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_iv()
.br
Key = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
State = crypto_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Initializes a series of encryptions or decryptions where the IV is provided later\&. The actual encryption or decryption is done by crypto_dyn_iv_update/3\&.
.LP
The function is equivalent to \fIcrypto_init(Cipher, Key, undefined, FlagOrOptions)\fR\&\&.
.RE
.LP
.nf

.B
crypto_final(State) -> FinalResult
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
FinalResult = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Finalizes a series of encryptions or decryptions and delivers the final bytes of the final block\&. The data returned from this function may be empty if no padding was enabled in crypto_init/3,4 or crypto_dyn_iv_init/3\&.
.RE
.LP
.nf

.B
crypto_get_data(State) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
Result = map()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Returns information about the State in the argument\&. The information is the form of a map, which currently contains at least:
.RS 2
.TP 2
.B
\fIsize\fR\&:
The number of bytes encrypted or decrypted so far\&. 
.TP 2
.B
\fIpadding_size\fR\&:
After a call to crypto_final/1 it contains the number of bytes padded\&. Otherwise 0\&. 
.TP 2
.B
\fIpadding_type\fR\&:
The type of the padding as provided in the call to crypto_init/3,4\&. 
.TP 2
.B
\fIencrypt\fR\&:
Is \fItrue\fR\& if encryption is performed\&. It is \fIfalse\fR\& otherwise\&. 
.RE
.RE
.LP
.nf

.B
crypto_dyn_iv_update(State, Data, IV) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
Data = IV = iodata()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Do an actual crypto operation on a part of the full text and the IV is supplied for each part\&. The \fIState\fR\& should be created with crypto_dyn_iv_init/3\&.
.RE
.LP
.nf

.B
crypto_one_time(Cipher, Key, Data, FlagOrOptions) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_no_iv()
.br
Key = Data = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
As crypto_one_time/5 but for ciphers without IVs\&.
.RE
.LP
.nf

.B
crypto_one_time(Cipher, Key, IV, Data, FlagOrOptions) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_iv()
.br
Key = IV = Data = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Do a complete encrypt or decrypt of the full text in the argument \fIData\fR\&\&.
.LP
For encryption, set the \fIFlagOrOptions\fR\& to \fItrue\fR\&\&. For decryption, set it to \fIfalse\fR\&\&. For setting other options, see crypto_init/4\&.
.LP
See examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
crypto_one_time_aead(Cipher, Key, IV, InText, AAD,
.B
                     EncFlag :: true) ->
.B
                        Result
.br
.fi
.br
.nf

.B
crypto_one_time_aead(Cipher, Key, IV, InText, AAD, TagOrTagLength,
.B
                     EncFlag) ->
.B
                        Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_aead()
.br
Key = IV = InText = AAD = iodata()
.br
TagOrTagLength = EncryptTagLength | DecryptTag
.br
EncryptTagLength = integer() >= 0
.br
DecryptTag = iodata()
.br
EncFlag = boolean()
.br
Result = EncryptResult | DecryptResult
.br
EncryptResult = {OutCryptoText, OutTag}
.br
DecryptResult = OutPlainText | error
.br
OutCryptoText = OutTag = OutPlainText = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Do a complete encrypt or decrypt with an AEAD cipher of the full text\&.
.LP
For encryption, set the \fIEncryptFlag\fR\& to \fItrue\fR\& and set the \fITagOrTagLength\fR\& to the wanted size (in bytes) of the tag, that is, the tag length\&. If the default length is wanted, the \fIcrypto_aead/6\fR\& form may be used\&.
.LP
For decryption, set the \fIEncryptFlag\fR\& to \fIfalse\fR\& and put the tag to be checked in the argument \fITagOrTagLength\fR\&\&.
.LP
See examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
supports(Type) -> Support
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hashs | ciphers | public_keys | macs | curves | rsa_opts
.br
Support = Hashs | Ciphers | PKs | Macs | Curves | RSAopts
.br
Hashs = 
.br
    [sha1() |
.br
     sha2() |
.br
     sha3() |
.br
     blake2() |
.br
     ripemd160 |
.br
     compatibility_only_hash()]
.br
Ciphers = [cipher()]
.br
PKs = [rsa | dss | ecdsa | dh | ecdh | eddh | ec_gf2m]
.br
Macs = [hmac | cmac | poly1305]
.br
Curves = 
.br
    [ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()]
.br
RSAopts = [rsa_sign_verify_opt() | rsa_opt()]
.br
.RE
.RE
.RS
.LP
Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library
.LP
See hash_info/1 and cipher_info/1 for information about the hash and cipher algorithms\&.
.RE
.LP
.nf

.B
mac(Type :: poly1305, Key, Data) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Data = iodata()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Short for mac(Type, undefined, Key, Data)\&.
.RE
.LP
.nf

.B
mac(Type, SubType, Key, Data) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
.br
Key = Data = iodata()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Computes a MAC (Message Authentication Code) of type \fIType\fR\& from \fIData\fR\&\&.
.LP
\fISubType\fR\& depends on the MAC \fIType\fR\&:
.RS 2
.TP 2
*
For \fIhmac\fR\& it is a hash algorithm, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIcmac\fR\& it is a cipher suitable for cmac, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIpoly1305\fR\& it should be set to \fIundefined\fR\& or the mac/2 function could be used instead, see Algorithm Details in the User\&'s Guide\&. 
.LP
.RE

.LP
\fIKey\fR\& is the authentication key with a length according to the \fIType\fR\& and \fISubType\fR\&\&. The key length could be found with the hash_info/1 (\fIhmac\fR\&) for and cipher_info/1 (\fIcmac\fR\&) functions\&. For \fIpoly1305\fR\& the key length is 32 bytes\&. Note that the cryptographic quality of the key is not checked\&.
.LP
The \fIMac\fR\& result will have a default length depending on the \fIType\fR\& and \fISubType\fR\&\&. To set a shorter length, use macN/4 or macN/5 instead\&. The default length is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
macN(Type :: poly1305, Key, Data, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Data = iodata()
.br
Mac = binary()
.br
MacLength = integer() >= 1
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Short for macN(Type, undefined, Key, Data, MacLength)\&.
.RE
.LP
.nf

.B
macN(Type, SubType, Key, Data, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
.br
Key = Data = iodata()
.br
Mac = binary()
.br
MacLength = integer() >= 1
.br
.RE
.RE
.RS
.LP
Computes a MAC (Message Authentication Code) as mac/3 and mac/4 but \fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\& to at most \fIMacLength\fR\& bytes\&. Note that if \fIMacLength\fR\& is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead\&.
.LP
The max \fIMacLength\fR\& is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
mac_init(Type :: poly1305, Key) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = iodata()
.br
State = mac_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Short for mac_init(Type, undefined, Key)\&.
.RE
.LP
.nf

.B
mac_init(Type, SubType, Key) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
.br
Key = iodata()
.br
State = mac_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Initializes the context for streaming MAC operations\&.
.LP
\fIType\fR\& determines which mac algorithm to use in the MAC operation\&.
.LP
\fISubType\fR\& depends on the MAC \fIType\fR\&:
.RS 2
.TP 2
*
For \fIhmac\fR\& it is a hash algorithm, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIcmac\fR\& it is a cipher suitable for cmac, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIpoly1305\fR\& it should be set to \fIundefined\fR\& or the mac/2 function could be used instead, see Algorithm Details in the User\&'s Guide\&. 
.LP
.RE

.LP
\fIKey\fR\& is the authentication key with a length according to the \fIType\fR\& and \fISubType\fR\&\&. The key length could be found with the hash_info/1 (\fIhmac\fR\&) for and cipher_info/1 (\fIcmac\fR\&) functions\&. For \fIpoly1305\fR\& the key length is 32 bytes\&. Note that the cryptographic quality of the key is not checked\&.
.LP
The returned \fIState\fR\& should be used in one or more subsequent calls to mac_update/2\&. The MAC value is finally returned by calling mac_final/1 or mac_finalN/2\&.
.LP
See  examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
mac_update(State0, Data) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
State0 = State = mac_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Updates the MAC represented by \fIState0\fR\& using the given \fIData\fR\& which could be of any length\&.
.LP
The \fIState0\fR\& is the State value originally from a MAC init function, that is mac_init/2, mac_init/3 or a previous call of \fImac_update/2\fR\&\&. The value \fIState0\fR\& is returned unchanged by the function as \fIState\fR\&\&.
.RE
.LP
.nf

.B
mac_final(State) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = mac_state()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Finalizes the MAC operation referenced by \fIState\fR\&\&. The \fIMac\fR\& result will have a default length depending on the \fIType\fR\& and \fISubType\fR\& in the mac_init/2,3 call\&. To set a shorter length, use mac_finalN/2 instead\&. The default length is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
mac_finalN(State, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = mac_state()
.br
MacLength = integer() >= 1
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Finalizes the MAC operation referenced by \fIState\fR\&\&.
.LP
\fIMac\fR\& will be a binary with at most \fIMacLength\fR\& bytes\&. Note that if \fIMacLength\fR\& is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead\&.
.LP
The max \fIMacLength\fR\& is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
bytes_to_integer(Bin :: binary()) -> integer()
.br
.fi
.br
.RS
.LP
Convert binary representation, of an integer, to an Erlang integer\&.
.RE
.LP
.nf

.B
compute_key(Type, OthersPublicKey, MyPrivateKey, Params) ->
.B
               SharedSecret
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = dh | ecdh | eddh | srp
.br
SharedSecret = binary()
.br
OthersPublicKey = dh_public() | ecdh_public() | srp_public()
.br
MyPrivateKey = 
.br
    dh_private() | ecdh_private() | {srp_public(), srp_private()}
.br
Params = dh_params() | ecdh_params() | srp_comp_params()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Computes the shared secret from the private key and the other party\&'s public key\&. See also public_key:compute_key/2 
.RE
.LP
.nf

.B
exor(Bin1 :: iodata(), Bin2 :: iodata()) -> binary()
.br
.fi
.br
.RS
.LP
Performs bit-wise XOR (exclusive or) on the data supplied\&.
.RE
.LP
.nf

.B
generate_key(Type, Params) -> {PublicKey, PrivKeyOut}
.br
.fi
.br
.nf

.B
generate_key(Type, Params, PrivKeyIn) -> {PublicKey, PrivKeyOut}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = dh | ecdh | eddh | eddsa | rsa | srp
.br
PublicKey = 
.br
    dh_public() | ecdh_public() | rsa_public() | srp_public()
.br
PrivKeyIn = 
.br
    undefined |
.br
    dh_private() |
.br
    ecdh_private() |
.br
    rsa_private() |
.br
    {srp_public(), srp_private()}
.br
PrivKeyOut = 
.br
    dh_private() |
.br
    ecdh_private() |
.br
    rsa_private() |
.br
    {srp_public(), srp_private()}
.br
Params = 
.br
    dh_params() |
.br
    ecdh_params() |
.br
    eddsa_params() |
.br
    rsa_params() |
.br
    srp_comp_params()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Generates a public key of type \fIType\fR\&\&. See also public_key:generate_key/1\&.
.LP

.RS -4
.B
Note:
.RE
If the linked version of cryptolib is OpenSSL 3\&.0
.RS 2
.TP 2
*
and the \fIType\fR\& is \fIdh\fR\& (diffie-hellman)
.LP
.TP 2
*
and the parameter \fIP\fR\& (in dh_params()) is one of the MODP groups (see RFC 3526)
.LP
.TP 2
*
and the optional \fIPrivateKeyBitLength\fR\& parameter (in dh_params()) is present,
.LP
.RE

.LP
then the optional key length parameter must be at least 224, 256, 302, 352 and 400 for group sizes of 2048, 3072, 4096, 6144 and 8192, respectively\&.

.LP

.RS -4
.B
Note:
.RE
RSA key generation is only available if the runtime was built with dirty scheduler support\&. Otherwise, attempting to generate an RSA key will raise the exception \fIerror:notsup\fR\&\&.

.RE
.LP
.nf

.B
hash(Type, Data) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hash_algorithm()
.br
Data = iodata()
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Computes a message digest of type \fIType\fR\& from \fIData\fR\&\&.
.RE
.LP
.nf

.B
hash_init(Type) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hash_algorithm()
.br
State = hash_state()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Initializes the context for streaming hash operations\&. \fIType\fR\& determines which digest to use\&. The returned context should be used as argument to hash_update\&.
.RE
.LP
.nf

.B
hash_update(State, Data) -> NewState
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = NewState = hash_state()
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Updates the digest represented by \fIContext\fR\& using the given \fIData\fR\&\&. \fIContext\fR\& must have been generated using hash_init or a previous call to this function\&. \fIData\fR\& can be any length\&. \fINewContext\fR\& must be passed into the next call to \fIhash_update\fR\& or hash_final\&.
.RE
.LP
.nf

.B
hash_final(State) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = hash_state()
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Finalizes the hash operation referenced by \fIContext\fR\& returned from a previous call to hash_update\&. The size of \fIDigest\fR\& is determined by the type of hash function used to generate it\&.
.RE
.LP
.nf

.B
info_fips() -> not_supported | not_enabled | enabled
.br
.fi
.br
.RS
.LP
Provides information about the FIPS operating status of crypto and the underlying libcrypto library\&. If crypto was built with FIPS support this can be either \fIenabled\fR\& (when running in FIPS mode) or \fInot_enabled\fR\&\&. For other builds this value is always \fInot_supported\fR\&\&.
.LP
See enable_fips_mode/1 about how to enable FIPS mode\&.
.LP

.RS -4
.B
Warning:
.RE
In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception \fIerror:notsup\fR\&\&. Check supports(ciphers) that in FIPS mode returns the restricted list of available algorithms\&.

.RE
.LP
.nf

.B
enable_fips_mode(Enable) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Enable = Result = boolean()
.br
.RE
.RE
.RS
.LP
Enables (\fIEnable = true\fR\&) or disables (\fIEnable = false\fR\&) FIPS mode\&. Returns \fItrue\fR\& if the operation was successful or \fIfalse\fR\& otherwise\&.
.LP
Note that to enable FIPS mode successfully, OTP must be built with the configure option \fI--enable-fips\fR\&, and the underlying libcrypto must also support FIPS\&.
.LP
See also info_fips/0\&.
.RE
.LP
.nf

.B
info() ->
.B
        #{compile_type := normal | debug | valgrind | asan,
.B
          cryptolib_version_compiled => string() | undefined,
.B
          cryptolib_version_linked := string(),
.B
          link_type := dynamic | static,
.B
          otp_crypto_version := string()}
.br
.fi
.br
.RS
.LP
Provides a map with information about the compilation and linking of crypto\&.
.LP
Example:
.LP
.nf

1> crypto:info().
#{compile_type => normal,
  cryptolib_version_compiled => "OpenSSL 3.0.0 7 sep 2021",
  cryptolib_version_linked => "OpenSSL 3.0.0 7 sep 2021",
  link_type => dynamic,
  otp_crypto_version => "5.0.2"}
2>
	
.fi
.LP
More association types than documented may be present in the map\&.
.RE
.LP
.nf

.B
info_lib() -> [{Name, VerNum, VerStr}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = binary()
.br
VerNum = integer()
.br
VerStr = binary()
.br
.RE
.RE
.RS
.LP
Provides the name and version of the libraries used by crypto\&.
.LP
\fIName\fR\& is the name of the library\&. \fIVerNum\fR\& is the numeric version according to the library\&'s own versioning scheme\&. \fIVerStr\fR\& contains a text variant of the version\&.
.LP
.nf

> info_lib()\&.
[{<<"OpenSSL">>,269484095,<<"OpenSSL 1.1.0c  10 Nov 2016"">>}]
        
.fi
.LP

.RS -4
.B
Note:
.RE
From OTP R16 the \fInumeric version\fR\& represents the version of the OpenSSL \fIheader files\fR\& (\fIopenssl/opensslv\&.h\fR\&) used when crypto was compiled\&. The text variant represents the libcrypto library used at runtime\&. In earlier OTP versions both numeric and text was taken from the library\&.

.RE
.LP
.nf

.B
hash_info(Type) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hash_algorithm()
.br
Result = 
.br
    #{size := integer(),
.br
      block_size := integer(),
.br
      type := integer()}
.br
.RE
.RE
.RS
.LP
Provides a map with information about block_size, size and possibly other properties of the hash algorithm in question\&.
.LP
For a list of supported hash algorithms, see supports(hashs)\&.
.RE
.LP
.nf

.B
cipher_info(Type) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = cipher()
.br
Result = 
.br
    #{key_length := integer(),
.br
      iv_length := integer(),
.br
      block_size := integer(),
.br
      mode := CipherModes,
.br
      type := undefined | integer(),
.br
      prop_aead := boolean()}
.br
CipherModes = 
.br
    undefined | cbc_mode | ccm_mode | cfb_mode | ctr_mode |
.br
    ecb_mode | gcm_mode | ige_mode | ocb_mode | ofb_mode |
.br
    wrap_mode | xts_mode
.br
.RE
.RE
.RS
.LP
Provides a map with information about block_size, key_length, iv_length, aead support and possibly other properties of the cipher algorithm in question\&.
.LP

.RS -4
.B
Note:
.RE
The ciphers \fIaes_cbc\fR\&, \fIaes_cfb8\fR\&, \fIaes_cfb128\fR\&, \fIaes_ctr\fR\&, \fIaes_ecb\fR\&, \fIaes_gcm\fR\& and \fIaes_ccm\fR\& has no keylength in the \fIType\fR\& as opposed to for example \fIaes_128_ctr\fR\&\&. They adapt to the length of the key provided in the encrypt and decrypt function\&. Therefore it is impossible to return a valid keylength in the map\&.
.LP
Always use a \fIType\fR\& with an explicit key length,

.LP
For a list of supported cipher algorithms, see supports(ciphers)\&.
.RE
.LP
.nf

.B
mod_pow(N, P, M) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
N = P = M = binary() | integer()
.br
Result = binary() | error
.br
.RE
.RE
.RS
.LP
Computes the function \fIN^P mod M\fR\&\&.
.RE
.LP
.nf

.B
private_decrypt(Algorithm, CipherText, PrivateKey, Options) ->
.B
                   PlainText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
CipherText = binary()
.br
PrivateKey = rsa_private() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
PlainText = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Decrypts the \fICipherText\fR\&, encrypted with public_encrypt/4 (or equivalent function) using the \fIPrivateKey\fR\&, and returns the plaintext (message digest)\&. This is a low level signature verification operation used for instance by older versions of the SSL protocol\&. See also public_key:decrypt_private/[2,3] 
.RE
.LP
.nf

.B
private_encrypt(Algorithm, PlainText, PrivateKey, Options) ->
.B
                   CipherText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
PlainText = binary()
.br
PrivateKey = rsa_private() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
CipherText = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Encrypts the \fIPlainText\fR\& using the \fIPrivateKey\fR\& and returns the ciphertext\&. This is a low level signature operation used for instance by older versions of the SSL protocol\&. See also public_key:encrypt_private/[2,3] 
.RE
.LP
.nf

.B
public_decrypt(Algorithm, CipherText, PublicKey, Options) ->
.B
                  PlainText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
CipherText = binary()
.br
PublicKey = rsa_public() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
PlainText = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Decrypts the \fICipherText\fR\&, encrypted with private_encrypt/4(or equivalent function) using the \fIPrivateKey\fR\&, and returns the plaintext (message digest)\&. This is a low level signature verification operation used for instance by older versions of the SSL protocol\&. See also public_key:decrypt_public/[2,3] 
.RE
.LP
.nf

.B
public_encrypt(Algorithm, PlainText, PublicKey, Options) ->
.B
                  CipherText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
PlainText = binary()
.br
PublicKey = rsa_public() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
CipherText = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Encrypts the \fIPlainText\fR\& (message digest) using the \fIPublicKey\fR\& and returns the \fICipherText\fR\&\&. This is a low level signature operation used for instance by older versions of the SSL protocol\&. See also public_key:encrypt_public/[2,3] 
.RE
.LP
.nf

.B
rand_seed(Seed :: binary()) -> ok
.br
.fi
.br
.RS
.LP
Set the seed for PRNG to the given binary\&. This calls the RAND_seed function from openssl\&. Only use this if the system you are running on does not have enough "randomness" built in\&. Normally this is when strong_rand_bytes/1 raises \fIerror:low_entropy\fR\&
.RE
.LP
.B
rand_uniform(Lo, Hi) -> N
.br
.RS
.LP
Types:

.RS 3
Lo, Hi, N = integer()
.br
.RE
.RE
.RS
.LP
Generate a random number \fIN, Lo =< N < Hi\&.\fR\& Uses the \fIcrypto\fR\& library pseudo-random number generator\&. \fIHi\fR\& must be larger than \fILo\fR\&\&.
.RE
.LP
.nf

.B
start() -> ok | {error, Reason :: term()}
.br
.fi
.br
.RS
.LP
Equivalent to application:start(crypto)\&.
.RE
.LP
.nf

.B
stop() -> ok | {error, Reason :: term()}
.br
.fi
.br
.RS
.LP
Equivalent to application:stop(crypto)\&.
.RE
.LP
.nf

.B
strong_rand_bytes(N :: integer() >= 0) -> binary()
.br
.fi
.br
.RS
.LP
Generates N bytes randomly uniform 0\&.\&.255, and returns the result in a binary\&. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy\&. By default this is the \fIRAND_bytes\fR\& method from OpenSSL\&.
.LP
May raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.RE
.LP
.nf

.B
rand_seed() -> rand:state()
.br
.fi
.br
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strong random numbers (based on OpenSSL\&'s \fIBN_rand_range\fR\&), and saves it in the process dictionary before returning it as well\&. See also rand:seed/1 and rand_seed_s/0\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed(),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[
.fi
.RE
.LP
.nf

.B
rand_seed_s() -> rand:state()
.br
.fi
.br
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strongly random numbers (based on OpenSSL\&'s \fIBN_rand_range\fR\&)\&. See also rand:seed_s/1\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP

.RS -4
.B
Note:
.RE
The state returned from this function cannot be used to get a reproducible random sequence as from the other rand functions, since reproducibility does not match cryptographically safe\&.
.LP
The only supported usage is to generate one distinct random sequence from this start state\&.

.RE
.LP
.B
rand_seed_alg(Alg) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto | crypto_cache
.br
.RE
.RE
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strong random numbers, and saves it in the process dictionary before returning it as well\&. See also rand:seed/1 and rand_seed_alg_s/1\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed_alg(crypto_cache),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[
.fi
.RE
.LP
.B
rand_seed_alg(Alg, Seed) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto_aes
.br
.RE
.RE
.RS
.LP
Creates a state object for random number generation, in order to generate cryptographically unpredictable random numbers, and saves it in the process dictionary before returning it as well\&. See also rand_seed_alg_s/2\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % [1; 42]
FloatValue = rand:uniform(),     % [0.0; 1.0[
_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % Same values
FloatValue = rand:uniform().     % again
	
.fi
.RE
.LP
.B
rand_seed_alg_s(Alg) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto | crypto_cache
.br
.RE
.RE
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strongly random numbers\&. See also rand:seed_s/1\&.
.LP
If \fIAlg\fR\& is \fIcrypto\fR\& this function behaves exactly like rand_seed_s/0\&.
.LP
If \fIAlg\fR\& is \fIcrypto_cache\fR\& this function fetches random data with OpenSSL\&'s \fIRAND_bytes\fR\& and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
The cache size can be changed from its default value using the  crypto app\&'s  configuration parameter \fIrand_cache_size\fR\&\&.
.LP
When using the state object from this function the rand functions using it may throw exception \fIlow_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP

.RS -4
.B
Note:
.RE
The state returned from this function cannot be used to get a reproducible random sequence as from the other rand functions, since reproducibility does not match cryptographically safe\&.
.LP
In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable\&.
.LP
The only supported usage is to generate one distinct random sequence from this start state\&.

.RE
.LP
.B
rand_seed_alg_s(Alg, Seed) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto_aes
.br
.RE
.RE
.RS
.LP
Creates a state object for random number generation, in order to generate cryptographically unpredictable random numbers\&. See also rand_seed_alg/1\&.
.LP
To get a long period the Xoroshiro928 generator from the rand module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values\&.
.LP
The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long\&. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule\&.
.RS 2
.TP 2
*
If you need cryptographically strong random numbers use rand_seed_alg_s/1 with \fIAlg =:= crypto\fR\& or \fIAlg =:= crypto_cache\fR\&\&.
.LP
.TP 2
*
If you need to be able to repeat the sequence use this function\&.
.LP
.TP 2
*
If you do not need the statistical quality of this function, there are faster algorithms in the rand module\&.
.LP
.RE

.LP
Thanks to the used generator the state object supports the \fIrand:jump/0,1\fR\& function with distance 2^512\&.
.LP
Numbers are generated in batches and cached for speed reasons\&. The cache size can be changed from its default value using the  crypto app\&'s  configuration parameter \fIrand_cache_size\fR\&\&.
.RE
.LP
.nf

.B
ec_curves() -> [EllipticCurve]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EllipticCurve = 
.br
    ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()
.br
.RE
.RE
.RS
.LP
Can be used to determine which named elliptic curves are supported\&.
.RE
.LP
.nf

.B
ec_curve(CurveName) -> ExplicitCurve
.br
.fi
.br
.RS
.LP
Types:

.RS 3
CurveName = ec_named_curve()
.br
ExplicitCurve = ec_explicit_curve()
.br
.RE
.RE
.RS
.LP
Return the defining parameters of a elliptic curve\&.
.RE
.LP
.nf

.B
sign(Algorithm, DigestType, Msg, Key) -> Signature
.br
.fi
.br
.nf

.B
sign(Algorithm, DigestType, Msg, Key, Options) -> Signature
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_sign_verify_algs()
.br
DigestType = 
.br
    rsa_digest_type() |
.br
    dss_digest_type() |
.br
    ecdsa_digest_type() |
.br
    none
.br
Msg = iodata() | {digest, iodata()}
.br
Key = 
.br
    rsa_private() |
.br
    dss_private() |
.br
    [ecdsa_private() | ecdsa_params()] |
.br
    [eddsa_private() | eddsa_params()] |
.br
    engine_key_ref()
.br
Options = pk_sign_verify_opts()
.br
Signature = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Creates a digital signature\&.
.LP
The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i\&.e\&. the digest (plaintext)\&.
.LP
Algorithm \fIdss\fR\& can only be used together with digest type \fIsha\fR\&\&.
.LP
See also public_key:sign/3\&.
.RE
.LP
.nf

.B
verify(Algorithm, DigestType, Msg, Signature, Key) -> Result
.br
.fi
.br
.nf

.B
verify(Algorithm, DigestType, Msg, Signature, Key, Options) ->
.B
          Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_sign_verify_algs()
.br
DigestType = 
.br
    rsa_digest_type() |
.br
    dss_digest_type() |
.br
    ecdsa_digest_type() |
.br
    none
.br
Msg = iodata() | {digest, iodata()}
.br
Signature = binary()
.br
Key = 
.br
    rsa_public() |
.br
    dss_public() |
.br
    [ecdsa_public() | ecdsa_params()] |
.br
    [eddsa_public() | eddsa_params()] |
.br
    engine_key_ref()
.br
Options = pk_sign_verify_opts()
.br
Result = boolean()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
Verifies a digital signature
.LP
The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i\&.e\&. the digest (plaintext)\&.
.LP
Algorithm \fIdss\fR\& can only be used together with digest type \fIsha\fR\&\&.
.LP
See also public_key:verify/4\&.
.RE
.SH "ENGINE API"

.SH EXPORTS
.LP
.nf

.B
privkey_to_pubkey(Type, EnginePrivateKeyRef) -> PublicKey
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = rsa | dss
.br
EnginePrivateKeyRef = engine_key_ref()
.br
PublicKey = rsa_public() | dss_public()
.br
.RE
.RE
.RS
.LP
Fetches the corresponding public key from a private key stored in an Engine\&. The key must be of the type indicated by the Type parameter\&.
.RE
.LP
.nf

.B
engine_get_all_methods() -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = [engine_method_type()]
.br
.RE
.RE
.RS
.LP
Returns a list of all possible engine methods\&.
.LP
May raise exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_load(EngineId, PreCmds, PostCmds) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = unicode:chardata()
.br
PreCmds = PostCmds = [engine_cmnd()]
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& if it is available and intialize it\&. Returns ok and an engine handle, if the engine can\&'t be loaded an error tuple is returned\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_unload(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads the OpenSSL engine given by \fIEngine\fR\&\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameter is in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_by_id(EngineId) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = unicode:chardata()
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Get a reference to an already loaded engine with \fIEngineId\fR\&\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameter is in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_ctrl_cmd_string(Engine, CmdName, CmdArg) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = term()
.br
CmdName = CmdArg = unicode:chardata()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Sends ctrl commands to the OpenSSL engine given by \fIEngine\fR\&\&. This function is the same as calling \fIengine_ctrl_cmd_string/4\fR\& with \fIOptional\fR\& set to \fIfalse\fR\&\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_ctrl_cmd_string(Engine, CmdName, CmdArg, Optional) ->
.B
                          Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = term()
.br
CmdName = CmdArg = unicode:chardata()
.br
Optional = boolean()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Sends ctrl commands to the OpenSSL engine given by \fIEngine\fR\&\&. \fIOptional\fR\& is a boolean argument that can relax the semantics of the function\&. If set to \fItrue\fR\& it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn\&'t support the command name it will simply return success without doing anything\&. In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to \fIfalse\fR\&\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_add(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Add the engine to OpenSSL\&'s internal list\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_remove(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Remove the engine from OpenSSL\&'s internal list\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_register(Engine, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineMethods = [engine_method_type()]
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Register engine to handle some type of methods, for example engine_method_digests\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_unregister(Engine, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineMethods = [engine_method_type()]
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unregister engine so it don\&'t handle some type of methods\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_get_id(Engine) -> EngineId
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineId = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Return the ID for the engine, or an empty binary if there is no id set\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_get_name(Engine) -> EngineName
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineName = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Return the name (eg a description) for the engine, or an empty binary if there is no name set\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_list() -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = [EngineId :: unicode:chardata()]
.br
.RE
.RE
.RS
.LP
List the id\&'s of all engines in OpenSSL\&'s internal list\&.
.LP
It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.LP
May raise exception \fIerror:notsup\fR\& in case engine functionality is not supported by the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
ensure_engine_loaded(EngineId, LibPath) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = LibPath = unicode:chardata()
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads an engine given by \fIEngineId\fR\& and the path to the dynamic library implementing the engine\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
This function differs from the normal engine_load in the sense that it also add the engine id to OpenSSL\&'s internal engine list\&. The difference between the first call and the following is that the first loads the engine with the dynamical engine and the following calls fetch it from the OpenSSL\&'s engine list\&. All references that is returned are equal\&.
.LP
Use \fIengine_unload/1\fR\& function to remove the references\&. But remember that \fIengine_unload/1\fR\& just removes the references to the engine and not the tag in OpenSSL\&'s engine list\&. That has to be done with the \fIengine_remove/1\fR\& function when needed (just called once, from any of the references you got)\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
hash_equals(BinA, BinB) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
BinA = BinB = binary()
.br
Result = boolean()
.br
.RE
.RE
.RS
.LP
Constant time memory comparison for fixed length binaries, such as results of HMAC computations\&.
.LP
Returns true if the binaries are identical, false if they are of the same length but not identical\&. The function raises an \fIerror:badarg\fR\& exception if the binaries are of different size\&.
.RE
.LP
.nf

.B
pbkdf2_hmac(Digest, Pass, Salt, Iter, KeyLen) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Digest = sha | sha224 | sha256 | sha384 | sha512
.br
Pass = Salt = binary()
.br
Iter = KeyLen = integer() >= 1
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Uses the 3-tuple style for error handling\&.
.LP
PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with HMAC\&.
.RE