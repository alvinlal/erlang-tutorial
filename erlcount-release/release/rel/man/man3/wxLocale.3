.TH wxLocale 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxLocale \- Functions for wxLocale class
.SH DESCRIPTION
.LP
\fIwxLocale\fR\& class encapsulates all language-dependent settings and is a generalization of the C locale concept\&.
.LP
In wxWidgets this class manages current locale\&. It also initializes and activates \fIwxTranslations\fR\& (not implemented in wx) object that manages message catalogs\&.
.LP
For a list of the supported languages, please see ?wxLanguage enum values\&. These constants may be used to specify the language in \fIinit/3\fR\& and are returned by \fIgetSystemLanguage/0\fR\&\&.
.LP
See: Overview i18n, Examples, \fIwxXLocale\fR\& (not implemented in wx), \fIwxTranslations\fR\& (not implemented in wx)
.LP
wxWidgets docs: wxLocale
.SH DATA TYPES
.nf

\fBwxLocale()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxLocale()
.br
.fi
.br
.RS
.LP
This is the default constructor and it does nothing to initialize the object: \fIinit/3\fR\& must be used to do that\&.
.RE
.LP
.nf

.B
new(Language) -> wxLocale()
.br
.fi
.br
.nf

.B
new(Name) -> wxLocale()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
new(Language, Options :: [Option]) -> wxLocale()
.br
.fi
.br
.nf

.B
new(Name, Options :: [Option]) -> wxLocale()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = unicode:chardata()
.br
Option = 
.br
    {shortName, unicode:chardata()} |
.br
    {locale, unicode:chardata()} |
.br
    {bLoadDefault, boolean()}
.br
.RE
.RE
.RS
.LP
See \fIinit/3\fR\& for parameters description\&.
.LP
The call of this function has several global side effects which you should understand: first of all, the application locale is changed - note that this will affect many of standard C library functions such as printf() or strftime()\&. Second, this \fIwxLocale\fR\& object becomes the new current global locale for the application and so all subsequent calls to ?wxGetTranslation() will try to translate the messages using the message catalogs for this locale\&.
.RE
.LP
.nf

.B
destroy(This :: wxLocale()) -> ok
.br
.fi
.br
.RS
.LP
The destructor, like the constructor, also has global side effects: the previously set locale is restored and so the changes described in \fIinit/3\fR\& documentation are rolled back\&.
.RE
.LP
.nf

.B
init(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.LP
.nf

.B
init(This, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Option = {language, integer()} | {flags, integer()}
.br
.RE
.RE
.RS
.LP
Initializes the \fIwxLocale\fR\& instance\&.
.LP
The call of this function has several global side effects which you should understand: first of all, the application locale is changed - note that this will affect many of standard C library functions such as printf() or strftime()\&. Second, this \fIwxLocale\fR\& object becomes the new current global locale for the application and so all subsequent calls to ?wxGetTranslation() will try to translate the messages using the message catalogs for this locale\&.
.LP
Return: true on success or false if the given locale couldn\&'t be set\&.
.RE
.LP
.nf

.B
init(This, Name, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Name = unicode:chardata()
.br
Option = 
.br
    {shortName, unicode:chardata()} |
.br
    {locale, unicode:chardata()} |
.br
    {bLoadDefault, boolean()}
.br
.RE
.RE
.RS
.LP
Deprecated: This form is deprecated, use the other one unless you know what you are doing\&.
.RE
.LP
.nf

.B
addCatalog(This, Domain) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Domain = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Calls wxTranslations::AddCatalog(const wxString&)\&.
.RE
.LP
.nf

.B
addCatalog(This, Domain, MsgIdLanguage) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Domain = unicode:chardata()
.br
MsgIdLanguage = wx:wx_enum()
.br
.RE
.RE
.RS
.LP
Calls \fIwxTranslations::AddCatalog(const wxString&, wxLanguage)\fR\& (not implemented in wx)\&.
.RE
.LP
.nf

.B
addCatalog(This, Domain, MsgIdLanguage, MsgIdCharset) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Domain = unicode:chardata()
.br
MsgIdLanguage = wx:wx_enum()
.br
MsgIdCharset = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Calls \fIwxTranslations::AddCatalog(const wxString&, wxLanguage, const wxString&)\fR\& (not implemented in wx)\&.
.RE
.LP
.nf

.B
addCatalogLookupPathPrefix(Prefix) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Prefix = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Calls \fIwxFileTranslationsLoader::AddCatalogLookupPathPrefix()\fR\& (not implemented in wx)\&.
.RE
.LP
.nf

.B
getCanonicalName(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.RS
.LP
Returns the canonical form of current locale name\&.
.LP
Canonical form is the one that is used on UNIX systems: it is a two- or five-letter string in xx or xx_YY format, where xx is ISO 639 code of language and YY is ISO 3166 code of the country\&. Examples are "en", "en_GB", "en_US" or "fr_FR"\&. This form is internally used when looking up message catalogs\&. Compare \fIgetSysName/1\fR\&\&.
.RE
.LP
.nf

.B
getLanguage(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.RS
.LP
Returns the ?wxLanguage constant of current language\&.
.LP
Note that you can call this function only if you used the form of \fIinit/3\fR\& that takes ?wxLanguage argument\&.
.RE
.LP
.nf

.B
getLanguageName(Lang) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Lang = integer()
.br
.RE
.RE
.RS
.LP
Returns English name of the given language or empty string if this language is unknown\&.
.LP
See \fIGetLanguageInfo()\fR\& (not implemented in wx) for a remark about special meaning of \fIwxLANGUAGE_DEFAULT\fR\&\&.
.RE
.LP
.nf

.B
getLocale(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.RS
.LP
Returns the locale name as passed to the constructor or \fIinit/3\fR\&\&.
.LP
This is a full, human-readable name, e\&.g\&. "English" or "French"\&.
.RE
.LP
.nf

.B
getName(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.RS
.LP
Returns the current short name for the locale (as given to the constructor or the \fIinit/3\fR\& function)\&.
.RE
.LP
.nf

.B
getString(This, OrigString) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
OrigString = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
getString(This, OrigString, Options :: [Option]) ->
.B
             unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
OrigString = unicode:chardata()
.br
Option = {szDomain, unicode:chardata()}
.br
.RE
.RE
.RS
.LP
Calls wxGetTranslation(const wxString&, const wxString&)\&.
.RE
.LP
.nf

.B
getString(This, OrigString, OrigString2, N) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
OrigString = OrigString2 = unicode:chardata()
.br
N = integer()
.br
.RE
.RE
.LP
.nf

.B
getString(This, OrigString, OrigString2, N, Options :: [Option]) ->
.B
             unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
OrigString = OrigString2 = unicode:chardata()
.br
N = integer()
.br
Option = {szDomain, unicode:chardata()}
.br
.RE
.RE
.RS
.LP
Calls wxGetTranslation(const wxString&, const wxString&, unsigned, const wxString&)\&.
.RE
.LP
.nf

.B
getHeaderValue(This, Header) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Header = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
getHeaderValue(This, Header, Options :: [Option]) ->
.B
                  unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Header = unicode:chardata()
.br
Option = {szDomain, unicode:chardata()}
.br
.RE
.RE
.RS
.LP
Calls \fIwxTranslations::GetHeaderValue()\fR\& (not implemented in wx)\&.
.RE
.LP
.nf

.B
getSysName(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.RS
.LP
Returns current platform-specific locale name as passed to setlocale()\&.
.LP
Compare \fIgetCanonicalName/1\fR\&\&.
.RE
.LP
.nf

.B
getSystemEncoding() -> wx:wx_enum()
.br
.fi
.br
.RS
.LP
Tries to detect the user\&'s default font encoding\&.
.LP
Returns ?wxFontEncoding() value or \fIwxFONTENCODING_SYSTEM\fR\& if it couldn\&'t be determined\&.
.RE
.LP
.nf

.B
getSystemEncodingName() -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Tries to detect the name of the user\&'s default font encoding\&.
.LP
This string isn\&'t particularly useful for the application as its form is platform-dependent and so you should probably use \fIgetSystemEncoding/0\fR\& instead\&.
.LP
Returns a user-readable string value or an empty string if it couldn\&'t be determined\&.
.RE
.LP
.nf

.B
getSystemLanguage() -> integer()
.br
.fi
.br
.RS
.LP
Tries to detect the user\&'s default locale setting\&.
.LP
Returns the ?wxLanguage value or \fIwxLANGUAGE_UNKNOWN\fR\& if the language-guessing algorithm failed\&.
.LP
Note: This function works with \fIlocales\fR\& and returns the user\&'s default locale\&. This may be, and usually is, the same as their preferred UI language, but it\&'s not the same thing\&. Use wxTranslation to obtain \fIlanguage\fR\& information\&.
.LP
See: \fIwxTranslations::GetBestTranslation()\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
isLoaded(This, Domain) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
Domain = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Calls \fIwxTranslations::IsLoaded()\fR\& (not implemented in wx)\&.
.RE
.LP
.nf

.B
isOk(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxLocale()
.br
.RE
.RE
.RS
.LP
Returns true if the locale could be set successfully\&.
.RE