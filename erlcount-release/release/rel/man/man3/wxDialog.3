.TH wxDialog 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxDialog \- Functions for wxDialog class
.SH DESCRIPTION
.LP
A dialog box is a window with a title bar and sometimes a system menu, which can be moved around the screen\&. It can contain controls and other windows and is often used to allow the user to make some choice or to answer a question\&.
.LP
Dialogs can be made scrollable, automatically, for computers with low resolution screens: please see overview_dialog_autoscrolling for further details\&.
.LP
Dialogs usually contain either a single button allowing to close the dialog or two buttons, one accepting the changes and the other one discarding them (such button, if present, is automatically activated if the user presses the "Esc" key)\&. By default, buttons with the standard wxID_OK and wxID_CANCEL identifiers behave as expected\&. Starting with wxWidgets 2\&.7 it is also possible to use a button with a different identifier instead, see \fIsetAffirmativeId/2\fR\& and \fISetEscapeId()\fR\& (not implemented in wx)\&.
.LP
Also notice that the \fIcreateButtonSizer/2\fR\& should be used to create the buttons appropriate for the current platform and positioned correctly (including their order which is platform-dependent)\&.
.LP
Modal and Modeless
.LP
There are two kinds of dialog, modal and modeless\&. A modal dialog blocks program flow and user input on other windows until it is dismissed, whereas a modeless dialog behaves more like a frame in that program flow continues, and input in other windows is still possible\&. To show a modal dialog you should use the \fIshowModal/1\fR\& method while to show a dialog modelessly you simply use \fIshow/2\fR\&, just as with frames\&.
.LP
Note that the modal dialog is one of the very few examples of wxWindow-derived objects which may be created on the stack and not on the heap\&. In other words, while most windows would be created like this:
.LP
You can achieve the same result with dialogs by using simpler code:
.LP
An application can define a \fIwxCloseEvent\fR\& handler for the dialog to respond to system close events\&.
.LP
Styles
.LP
This class supports the following styles:
.LP
See: Overview dialog, \fIwxFrame\fR\&, Overview validator 
.LP
This class is derived (and can use functions) from: \fIwxTopLevelWindow\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxDialog
.SH "EVENTS"

.LP
Event types emitted from this class: \fIclose_window\fR\&, \fIinit_dialog\fR\&
.SH DATA TYPES
.nf

\fBwxDialog()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxDialog()
.br
.fi
.br
.RS
.LP
Default constructor\&.
.RE
.LP
.nf

.B
new(Parent, Id, Title) -> wxDialog()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Id, Title, Options :: [Option]) -> wxDialog()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Constructor\&.
.LP
See: \fIcreate/5\fR\& 
.RE
.LP
.nf

.B
destroy(This :: wxDialog()) -> ok
.br
.fi
.br
.RS
.LP
Destructor\&.
.LP
Deletes any child windows before deleting the physical window\&.
.LP
See overview_windowdeletion for more info\&.
.RE
.LP
.nf

.B
create(This, Parent, Id, Title) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Id, Title, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Title = unicode:chardata()
.br
Option = 
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {style, integer()}
.br
.RE
.RE
.RS
.LP
Used for two-step dialog box construction\&.
.LP
See: \fInew/4\fR\& 
.RE
.LP
.nf

.B
createButtonSizer(This, Flags) -> wxSizer:wxSizer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
Flags = integer()
.br
.RE
.RE
.RS
.LP
Creates a sizer with standard buttons\&.
.LP
\fIflags\fR\& is a bit list of the following flags: wxOK, wxCANCEL, wxYES, wxNO, wxAPPLY, wxCLOSE, wxHELP, wxNO_DEFAULT\&.
.LP
The sizer lays out the buttons in a manner appropriate to the platform\&.
.LP
This function uses \fIcreateStdDialogButtonSizer/2\fR\& internally for most platforms but doesn\&'t create the sizer at all for the platforms with hardware buttons (such as smartphones) for which it sets up the hardware buttons appropriately and returns NULL, so don\&'t forget to test that the return value is valid before using it\&.
.RE
.LP
.nf

.B
createStdDialogButtonSizer(This, Flags) ->
.B
                              wxStdDialogButtonSizer:wxStdDialogButtonSizer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
Flags = integer()
.br
.RE
.RE
.RS
.LP
Creates a \fIwxStdDialogButtonSizer\fR\& with standard buttons\&.
.LP
\fIflags\fR\& is a bit list of the following flags: wxOK, wxCANCEL, wxYES, wxNO, wxAPPLY, wxCLOSE, wxHELP, wxNO_DEFAULT\&.
.LP
The sizer lays out the buttons in a manner appropriate to the platform\&.
.RE
.LP
.nf

.B
endModal(This, RetCode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
RetCode = integer()
.br
.RE
.RE
.RS
.LP
Ends a modal dialog, passing a value to be returned from the \fIshowModal/1\fR\& invocation\&.
.LP
See: \fIshowModal/1\fR\&, \fIgetReturnCode/1\fR\&, \fIsetReturnCode/2\fR\& 
.RE
.LP
.nf

.B
getAffirmativeId(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
.RE
.RE
.RS
.LP
Gets the identifier of the button which works like standard OK button in this dialog\&.
.LP
See: \fIsetAffirmativeId/2\fR\& 
.RE
.LP
.nf

.B
getReturnCode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
.RE
.RE
.RS
.LP
Gets the return code for this window\&.
.LP
Remark: A return code is normally associated with a modal dialog, where \fIshowModal/1\fR\& returns a code to the application\&.
.LP
See: \fIsetReturnCode/2\fR\&, \fIshowModal/1\fR\&, \fIendModal/2\fR\& 
.RE
.LP
.nf

.B
isModal(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
.RE
.RE
.RS
.LP
Returns true if the dialog box is modal, false otherwise\&.
.RE
.LP
.nf

.B
setAffirmativeId(This, Id) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
Id = integer()
.br
.RE
.RE
.RS
.LP
Sets the identifier to be used as OK button\&.
.LP
When the button with this identifier is pressed, the dialog calls \fIwxWindow:validate/1\fR\& and \fIwxWindow:transferDataFromWindow/1\fR\& and, if they both return true, closes the dialog with the affirmative id return code\&.
.LP
Also, when the user presses a hardware OK button on the devices having one or the special OK button in the PocketPC title bar, an event with this id is generated\&.
.LP
By default, the affirmative id is wxID_OK\&.
.LP
See: \fIgetAffirmativeId/1\fR\&, \fISetEscapeId()\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
setReturnCode(This, RetCode) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
RetCode = integer()
.br
.RE
.RE
.RS
.LP
Sets the return code for this window\&.
.LP
A return code is normally associated with a modal dialog, where \fIshowModal/1\fR\& returns a code to the application\&. The function \fIendModal/2\fR\& calls \fIsetReturnCode/2\fR\&\&.
.LP
See: \fIgetReturnCode/1\fR\&, \fIshowModal/1\fR\&, \fIendModal/2\fR\& 
.RE
.LP
.nf

.B
show(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
.RE
.RE
.LP
.nf

.B
show(This, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
Option = {show, boolean()}
.br
.RE
.RE
.RS
.LP
Hides or shows the dialog\&.
.LP
The preferred way of dismissing a modal dialog is to use \fIendModal/2\fR\&\&.
.RE
.LP
.nf

.B
showModal(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxDialog()
.br
.RE
.RE
.RS
.LP
Shows an application-modal dialog\&.
.LP
Program flow does not return until the dialog has been dismissed with \fIendModal/2\fR\&\&.
.LP
Notice that it is possible to call \fIshowModal/1\fR\& for a dialog which had been previously shown with \fIshow/2\fR\&, this allows making an existing modeless dialog modal\&. However \fIshowModal/1\fR\& can\&'t be called twice without intervening \fIendModal/2\fR\& calls\&.
.LP
Note that this function creates a temporary event loop which takes precedence over the application\&'s main event loop (see \fIwxEventLoopBase\fR\& (not implemented in wx)) and which is destroyed when the dialog is dismissed\&. This also results in a call to \fIwxApp::ProcessPendingEvents()\fR\& (not implemented in wx)\&.
.LP
Return: The value set with \fIsetReturnCode/2\fR\&\&.
.LP
See: \fIShowWindowModal()\fR\& (not implemented in wx), \fIShowWindowModalThenDo()\fR\& (not implemented in wx), \fIendModal/2\fR\&, \fIgetReturnCode/1\fR\&, \fIsetReturnCode/2\fR\& 
.RE