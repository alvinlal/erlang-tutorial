.TH wxBookCtrlBase 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxBookCtrlBase \- Functions for wxBookCtrlBase class
.SH DESCRIPTION
.LP
A book control is a convenient way of displaying multiple pages of information, displayed one page at a time\&. wxWidgets has five variants of this control:
.LP
This abstract class is the parent of all these book controls, and provides their basic interface\&. This is a pure virtual class so you cannot allocate it directly\&.
.LP
See: Overview bookctrl 
.LP
This class is derived (and can use functions) from: \fIwxControl\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxBookCtrlBase
.SH DATA TYPES
.nf

\fBwxBookCtrlBase()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
addPage(This, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
addPage(This, Page, Text, Options :: [Option]) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Option = {bSelect, boolean()} | {imageId, integer()}
.br
.RE
.RE
.RS
.LP
Adds a new page\&.
.LP
The page must have the book control itself as the parent and must not have been added to this control previously\&.
.LP
The call to this function will generate the page changing and page changed events if \fIselect\fR\& is true, but not when inserting the very first page (as there is no previous page selection to switch from in this case and so it wouldn\&'t make sense to e\&.g\&. veto such event)\&.
.LP
Return: true if successful, false otherwise\&.
.LP
Remark: Do not delete the page, it will be deleted by the book control\&.
.LP
See: \fIinsertPage/5\fR\& 
.RE
.LP
.nf

.B
insertPage(This, Index, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Index = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
.RE
.RE
.LP
.nf

.B
insertPage(This, Index, Page, Text, Options :: [Option]) ->
.B
              boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Index = integer()
.br
Page = wxWindow:wxWindow()
.br
Text = unicode:chardata()
.br
Option = {bSelect, boolean()} | {imageId, integer()}
.br
.RE
.RE
.RS
.LP
Inserts a new page at the specified position\&.
.LP
Return: true if successful, false otherwise\&.
.LP
Remark: Do not delete the page, it will be deleted by the book control\&.
.LP
See: \fIaddPage/4\fR\& 
.RE
.LP
.nf

.B
deletePage(This, Page) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Deletes the specified page, and the associated window\&.
.LP
The call to this function generates the page changing events when deleting the currently selected page or a page preceding it in the index order, but it does \fInot\fR\& send any events when deleting the last page: while in this case the selection also changes, it becomes invalid and for compatibility reasons the control never generates events with the invalid selection index\&.
.RE
.LP
.nf

.B
removePage(This, Page) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Deletes the specified page, without deleting the associated window\&.
.LP
See \fIdeletePage/2\fR\& for a note about the events generated by this function\&.
.RE
.LP
.nf

.B
deleteAllPages(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
.RE
.RE
.RS
.LP
Deletes all pages\&.
.RE
.LP
.nf

.B
getPage(This, Page) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Returns the window at the given page position\&.
.RE
.LP
.nf

.B
getPageCount(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
.RE
.RE
.RS
.LP
Returns the number of pages in the control\&.
.RE
.LP
.nf

.B
getCurrentPage(This) -> wxWindow:wxWindow()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
.RE
.RE
.RS
.LP
Returns the currently selected page or NULL\&.
.RE
.LP
.nf

.B
advanceSelection(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
.RE
.RE
.LP
.nf

.B
advanceSelection(This, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Option = {forward, boolean()}
.br
.RE
.RE
.RS
.LP
Cycles through the tabs\&.
.LP
The call to this function generates the page changing events\&.
.RE
.LP
.nf

.B
setSelection(This, Page) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Sets the selection to the given page, returning the previous selection\&.
.LP
Notice that the call to this function generates the page changing events, use the \fIchangeSelection/2\fR\& function if you don\&'t want these events to be generated\&.
.LP
See: \fIgetSelection/1\fR\& 
.RE
.LP
.nf

.B
getSelection(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
.RE
.RE
.RS
.LP
Returns the currently selected page, or \fIwxNOT_FOUND\fR\& if none was selected\&.
.LP
Note that this method may return either the previously or newly selected page when called from the \fIEVT_BOOKCTRL_PAGE_CHANGED\fR\& handler depending on the platform and so \fIwxBookCtrlEvent:getSelection/1\fR\& should be used instead in this case\&.
.RE
.LP
.nf

.B
changeSelection(This, Page) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = integer()
.br
.RE
.RE
.RS
.LP
Changes the selection to the given page, returning the previous selection\&.
.LP
This function behaves as \fIsetSelection/2\fR\& but does \fInot\fR\& generate the page changing events\&.
.LP
See overview_events_prog for more information\&.
.RE
.LP
.nf

.B
hitTest(This, Pt) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = {Res :: integer(), Flags :: integer()}
.br
This = wxBookCtrlBase()
.br
Pt = {X :: integer(), Y :: integer()}
.br
.RE
.RE
.RS
.LP
Returns the index of the tab at the specified position or \fIwxNOT_FOUND\fR\& if none\&.
.LP
If \fIflags\fR\& parameter is non-NULL, the position of the point inside the tab is returned as well\&.
.LP
Return: Returns the zero-based tab index or \fIwxNOT_FOUND\fR\& if there is no tab at the specified position\&.
.RE
.LP
.nf

.B
getPageText(This, NPage) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
NPage = integer()
.br
.RE
.RE
.RS
.LP
Returns the string for the given page\&.
.RE
.LP
.nf

.B
setPageText(This, Page, Text) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxBookCtrlBase()
.br
Page = integer()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Sets the text for the given page\&.
.RE