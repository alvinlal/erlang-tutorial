.TH wxCloseEvent 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxCloseEvent \- Functions for wxCloseEvent class
.SH DESCRIPTION
.LP
This event class contains information about window and session close events\&.
.LP
The handler function for EVT_CLOSE is called when the user has tried to close a a frame or dialog box using the window manager (X) or system menu (Windows)\&. It can also be invoked by the application itself programmatically, for example by calling the \fIwxWindow:close/2\fR\& function\&.
.LP
You should check whether the application is forcing the deletion of the window using \fIcanVeto/1\fR\&\&. If this is false, you \fImust\fR\& destroy the window using \fIwxWindow:\&'Destroy\&'/1\fR\&\&.
.LP
If the return value is true, it is up to you whether you respond by destroying the window\&.
.LP
If you don\&'t destroy the window, you should call \fIveto/2\fR\& to let the calling code know that you did not destroy the window\&. This allows the \fIwxWindow:close/2\fR\& function to return true or false depending on whether the close instruction was honoured or not\&.
.LP
Example of a \fIwxCloseEvent\fR\& handler:
.LP
The EVT_END_SESSION event is slightly different as it is sent by the system when the user session is ending (e\&.g\&. because of log out or shutdown) and so all windows are being forcefully closed\&. At least under MSW, after the handler for this event is executed the program is simply killed by the system\&. Because of this, the default handler for this event provided by wxWidgets calls all the usual cleanup code (including \fIwxApp::OnExit()\fR\& (not implemented in wx)) so that it could still be executed and exit()s the process itself, without waiting for being killed\&. If this behaviour is for some reason undesirable, make sure that you define a handler for this event in your wxApp-derived class and do not call \fIevent\&.Skip()\fR\& in it (but be aware that the system will still kill your application)\&.
.LP
See: \fIwxWindow:close/2\fR\&, Overview windowdeletion 
.LP
This class is derived (and can use functions) from: \fIwxEvent\fR\&
.LP
wxWidgets docs: wxCloseEvent
.SH "EVENTS"

.LP
Use \fIwxEvtHandler:connect/3\fR\& with \fIwxCloseEventType\fR\& to subscribe to events of this type\&.
.SH DATA TYPES
.nf

\fBwxCloseEvent()\fR\& = wx:wx_object()
.br
.fi
.nf

\fBwxClose()\fR\& = #wxClose{type = wxCloseEvent:wxCloseEventType()}
.br
.fi
.nf

\fBwxCloseEventType()\fR\& = 
.br
    close_window | end_session | query_end_session
.br
.fi
.SH EXPORTS
.LP
.nf

.B
canVeto(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxCloseEvent()
.br
.RE
.RE
.RS
.LP
Returns true if you can veto a system shutdown or a window close event\&.
.LP
Vetoing a window close event is not possible if the calling code wishes to force the application to exit, and so this function must be called to check this\&.
.RE
.LP
.nf

.B
getLoggingOff(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxCloseEvent()
.br
.RE
.RE
.RS
.LP
Returns true if the user is just logging off or false if the system is shutting down\&.
.LP
This method can only be called for end session and query end session events, it doesn\&'t make sense for close window event\&.
.RE
.LP
.nf

.B
setCanVeto(This, CanVeto) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxCloseEvent()
.br
CanVeto = boolean()
.br
.RE
.RE
.RS
.LP
Sets the \&'can veto\&' flag\&.
.RE
.LP
.nf

.B
setLoggingOff(This, LoggingOff) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxCloseEvent()
.br
LoggingOff = boolean()
.br
.RE
.RE
.RS
.LP
Sets the \&'logging off\&' flag\&.
.RE
.LP
.nf

.B
veto(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxCloseEvent()
.br
.RE
.RE
.LP
.nf

.B
veto(This, Options :: [Option]) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxCloseEvent()
.br
Option = {veto, boolean()}
.br
.RE
.RE
.RS
.LP
Call this from your event handler to veto a system shutdown or to signal to the calling application that a window close did not happen\&.
.LP
You can only veto a shutdown if \fIcanVeto/1\fR\& returns true\&.
.RE