.TH wxKeyEvent 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxKeyEvent \- Functions for wxKeyEvent class
.SH DESCRIPTION
.LP
This event class contains information about key press and release events\&.
.LP
The main information carried by this event is the key being pressed or released\&. It can be accessed using either \fIgetKeyCode/1\fR\& function or \fIgetUnicodeKey/1\fR\&\&. For the printable characters, the latter should be used as it works for any keys, including non-Latin-1 characters that can be entered when using national keyboard layouts\&. \fIgetKeyCode/1\fR\& should be used to handle special characters (such as cursor arrows keys or \fIHOME\fR\& or \fIINS\fR\& and so on) which correspond to ?wxKeyCode enum elements above the \fIWXK_START\fR\& constant\&. While \fIgetKeyCode/1\fR\& also returns the character code for Latin-1 keys for compatibility, it doesn\&'t work for Unicode characters in general and will return \fIWXK_NONE\fR\& for any non-Latin-1 ones\&. For this reason, it\&'s recommended to always use \fIgetUnicodeKey/1\fR\& and only fall back to \fIgetKeyCode/1\fR\& if \fIgetUnicodeKey/1\fR\& returned \fIWXK_NONE\fR\& meaning that the event corresponds to a non-printable special keys\&.
.LP
While both of these functions can be used with the events of \fIwxEVT_KEY_DOWN\fR\&, \fIwxEVT_KEY_UP\fR\& and \fIwxEVT_CHAR\fR\& types, the values returned by them are different for the first two events and the last one\&. For the latter, the key returned corresponds to the character that would appear in e\&.g\&. a text zone if the user pressed the key in it\&. As such, its value depends on the current state of the Shift key and, for the letters, on the state of Caps Lock modifier\&. For example, if \fIA\fR\& key is pressed without Shift being held down, \fIwxKeyEvent\fR\& of type \fIwxEVT_CHAR\fR\& generated for this key press will return (from either \fIgetKeyCode/1\fR\& or \fIgetUnicodeKey/1\fR\& as their meanings coincide for ASCII characters) key code of 97 corresponding the ASCII value of \fIa\fR\&\&. And if the same key is pressed but with Shift being held (or Caps Lock being active), then the key could would be 65, i\&.e\&. ASCII value of capital \fIA\fR\&\&.
.LP
However for the key down and up events the returned key code will instead be \fIA\fR\& independently of the state of the modifier keys i\&.e\&. it depends only on physical key being pressed and is not translated to its logical representation using the current keyboard state\&. Such untranslated key codes are defined as follows:
.LP
Notice that the first rule applies to all Unicode letters, not just the usual Latin-1 ones\&. However for non-Latin-1 letters only \fIgetUnicodeKey/1\fR\& can be used to retrieve the key code as \fIgetKeyCode/1\fR\& just returns \fIWXK_NONE\fR\& in this case\&.
.LP
To summarize: you should handle \fIwxEVT_CHAR\fR\& if you need the translated key and \fIwxEVT_KEY_DOWN\fR\& if you only need the value of the key itself, independent of the current keyboard state\&.
.LP
Note: Not all key down events may be generated by the user\&. As an example, \fIwxEVT_KEY_DOWN\fR\& with \fI=\fR\& key code can be generated using the standard US keyboard layout but not using the German one because the \fI=\fR\& key corresponds to Shift-0 key combination in this layout and the key code for it is \fI0\fR\&, not \fI=\fR\&\&. Because of this you should avoid requiring your users to type key events that might be impossible to enter on their keyboard\&.
.LP
Another difference between key and char events is that another kind of translation is done for the latter ones when the Control key is pressed: char events for ASCII letters in this case carry codes corresponding to the ASCII value of Ctrl-Latter, i\&.e\&. 1 for Ctrl-A, 2 for Ctrl-B and so on until 26 for Ctrl-Z\&. This is convenient for terminal-like applications and can be completely ignored by all the other ones (if you need to handle Ctrl-A it is probably a better idea to use the key event rather than the char one)\&. Notice that currently no translation is done for the presses of [, \fI\\\fR\&, ], \fI^\fR\& and \fI_\fR\& keys which might be mapped to ASCII values from 27 to 31\&. Since version 2\&.9\&.2, the enum values \fIWXK_CONTROL_A\fR\& - \fIWXK_CONTROL_Z\fR\& can be used instead of the non-descriptive constant values 1-26\&.
.LP
Finally, modifier keys only generate key events but no char events at all\&. The modifiers keys are \fIWXK_SHIFT\fR\&, \fIWXK_CONTROL\fR\&, \fIWXK_ALT\fR\& and various \fIWXK_WINDOWS_XXX\fR\& from ?wxKeyCode enum\&.
.LP
Modifier keys events are special in one additional aspect: usually the keyboard state associated with a key press is well defined, e\&.g\&. \fIshiftDown/1\fR\& returns \fItrue\fR\& only if the Shift key was held pressed when the key that generated this event itself was pressed\&. There is an ambiguity for the key press events for Shift key itself however\&. By convention, it is considered to be already pressed when it is pressed and already released when it is released\&. In other words, \fIwxEVT_KEY_DOWN\fR\& event for the Shift key itself will have \fIwxMOD_SHIFT\fR\& in \fIgetModifiers/1\fR\& and \fIshiftDown/1\fR\& will return true while the \fIwxEVT_KEY_UP\fR\& event for Shift itself will not have \fIwxMOD_SHIFT\fR\& in its modifiers and \fIshiftDown/1\fR\& will return false\&.
.LP
\fITip:\fR\& You may discover the key codes and modifiers generated by all the keys on your system interactively by running the page_samples_keyboard wxWidgets sample and pressing some keys in it\&.
.LP
Note: If a key down (\fIEVT_KEY_DOWN\fR\&) event is caught and the event handler does not call \fIevent\&.Skip()\fR\& then the corresponding char event (\fIEVT_CHAR\fR\&) will not happen\&. This is by design and enables the programs that handle both types of events to avoid processing the same key twice\&. As a consequence, if you do not want to suppress the \fIwxEVT_CHAR\fR\& events for the keys you handle, always call \fIevent\&.Skip()\fR\& in your \fIwxEVT_KEY_DOWN\fR\& handler\&. Not doing may also prevent accelerators defined using this key from working\&.
.LP
Note: If a key is maintained in a pressed state, you will typically get a lot of (automatically generated) key down events but only one key up one at the end when the key is released so it is wrong to assume that there is one up event corresponding to each down one\&.
.LP
Note: For Windows programmers: The key and char events in wxWidgets are similar to but slightly different from Windows \fIWM_KEYDOWN\fR\& and \fIWM_CHAR\fR\& events\&. In particular, Alt-x combination will generate a char event in wxWidgets (unless it is used as an accelerator) and almost all keys, including ones without ASCII equivalents, generate char events too\&.
.LP
See: \fIwxKeyboardState\fR\& (not implemented in wx)
.LP
This class is derived (and can use functions) from: \fIwxEvent\fR\&
.LP
wxWidgets docs: wxKeyEvent
.SH "EVENTS"

.LP
Use \fIwxEvtHandler:connect/3\fR\& with \fIwxKeyEventType\fR\& to subscribe to events of this type\&.
.SH DATA TYPES
.nf

\fBwxKeyEvent()\fR\& = wx:wx_object()
.br
.fi
.nf

\fBwxKey()\fR\& = 
.br
    #wxKey{type = wxKeyEvent:wxKeyEventType(),
.br
           x = integer(),
.br
           y = integer(),
.br
           keyCode = integer(),
.br
           controlDown = boolean(),
.br
           shiftDown = boolean(),
.br
           altDown = boolean(),
.br
           metaDown = boolean(),
.br
           uniChar = integer(),
.br
           rawCode = integer(),
.br
           rawFlags = integer()}
.br
.fi
.nf

\fBwxKeyEventType()\fR\& = char | char_hook | key_down | key_up
.br
.fi
.SH EXPORTS
.LP
.nf

.B
altDown(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns true if the Alt key is pressed\&.
.LP
Notice that \fIgetModifiers/1\fR\& should usually be used instead of this one\&.
.RE
.LP
.nf

.B
cmdDown(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns true if the key used for command accelerators is pressed\&.
.LP
Same as \fIcontrolDown/1\fR\&\&. Deprecated\&.
.LP
Notice that \fIgetModifiers/1\fR\& should usually be used instead of this one\&.
.RE
.LP
.nf

.B
controlDown(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns true if the Control key or Apple/Command key under macOS is pressed\&.
.LP
This function doesn\&'t distinguish between right and left control keys\&.
.LP
Notice that \fIgetModifiers/1\fR\& should usually be used instead of this one\&.
.RE
.LP
.nf

.B
getKeyCode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns the key code of the key that generated this event\&.
.LP
ASCII symbols return normal ASCII values, while events from special keys such as "left cursor arrow" (\fIWXK_LEFT\fR\&) return values outside of the ASCII range\&. See ?wxKeyCode for a full list of the virtual key codes\&.
.LP
Note that this method returns a meaningful value only for special non-alphanumeric keys or if the user entered a Latin-1 character (this includes ASCII and the accented letters found in Western European languages but not letters of other alphabets such as e\&.g\&. Cyrillic)\&. Otherwise it simply method returns \fIWXK_NONE\fR\& and \fIgetUnicodeKey/1\fR\& should be used to obtain the corresponding Unicode character\&.
.LP
Using \fIgetUnicodeKey/1\fR\& is in general the right thing to do if you are interested in the characters typed by the user, \fIgetKeyCode/1\fR\& should be only used for special keys (for which \fIgetUnicodeKey/1\fR\& returns \fIWXK_NONE\fR\&)\&. To handle both kinds of keys you might write:
.RE
.LP
.nf

.B
getModifiers(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Return the bit mask of all pressed modifier keys\&.
.LP
The return value is a combination of \fIwxMOD_ALT\fR\&, \fIwxMOD_CONTROL\fR\&, \fIwxMOD_SHIFT\fR\& and \fIwxMOD_META\fR\& bit masks\&. Additionally, \fIwxMOD_NONE\fR\& is defined as 0, i\&.e\&. corresponds to no modifiers (see \fIHasAnyModifiers()\fR\& (not implemented in wx)) and \fIwxMOD_CMD\fR\& is either \fIwxMOD_CONTROL\fR\& (MSW and Unix) or \fIwxMOD_META\fR\& (Mac), see \fIcmdDown/1\fR\&\&. See ?wxKeyModifier for the full list of modifiers\&.
.LP
Notice that this function is easier to use correctly than, for example, \fIcontrolDown/1\fR\& because when using the latter you also have to remember to test that none of the other modifiers is pressed:
.LP
and forgetting to do it can result in serious program bugs (e\&.g\&. program not working with European keyboard layout where \fIAltGr\fR\& key which is seen by the program as combination of CTRL and ALT is used)\&. On the other hand, you can simply write:
.LP
with this function\&.
.RE
.LP
.nf

.B
getPosition(This) -> {X :: integer(), Y :: integer()}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Obtains the position (in client coordinates) at which the key was pressed\&.
.LP
Notice that under most platforms this position is simply the current mouse pointer position and has no special relationship to the key event itself\&.
.LP
\fIx\fR\& and \fIy\fR\& may be NULL if the corresponding coordinate is not needed\&.
.RE
.LP
.nf

.B
getRawKeyCode(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns the raw key code for this event\&.
.LP
The flags are platform-dependent and should only be used if the functionality provided by other \fIwxKeyEvent\fR\& methods is insufficient\&.
.LP
Under MSW, the raw key code is the value of \fIwParam\fR\& parameter of the corresponding message\&.
.LP
Under GTK, the raw key code is the \fIkeyval\fR\& field of the corresponding GDK event\&.
.LP
Under macOS, the raw key code is the \fIkeyCode\fR\& field of the corresponding NSEvent\&.
.LP
Note: Currently the raw key codes are not supported by all ports, use #ifdef wxHAS_RAW_KEY_CODES to determine if this feature is available\&.
.RE
.LP
.nf

.B
getRawKeyFlags(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns the low level key flags for this event\&.
.LP
The flags are platform-dependent and should only be used if the functionality provided by other \fIwxKeyEvent\fR\& methods is insufficient\&.
.LP
Under MSW, the raw flags are just the value of \fIlParam\fR\& parameter of the corresponding message\&.
.LP
Under GTK, the raw flags contain the \fIhardware_keycode\fR\& field of the corresponding GDK event\&.
.LP
Under macOS, the raw flags contain the modifiers state\&.
.LP
Note: Currently the raw key flags are not supported by all ports, use #ifdef wxHAS_RAW_KEY_CODES to determine if this feature is available\&.
.RE
.LP
.nf

.B
getUnicodeKey(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns the Unicode character corresponding to this key event\&.
.LP
If the key pressed doesn\&'t have any character value (e\&.g\&. a cursor key) this method will return \fIWXK_NONE\fR\&\&. In this case you should use \fIgetKeyCode/1\fR\& to retrieve the value of the key\&.
.LP
This function is only available in Unicode build, i\&.e\&. when \fIwxUSE_UNICODE\fR\& is 1\&.
.RE
.LP
.nf

.B
getX(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns the X position (in client coordinates) of the event\&.
.LP
See: \fIgetPosition/1\fR\& 
.RE
.LP
.nf

.B
getY(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns the Y position (in client coordinates) of the event\&.
.LP
See: \fIgetPosition/1\fR\& 
.RE
.LP
.nf

.B
hasModifiers(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns true if Control or Alt are pressed\&.
.LP
Checks if Control, Alt or, under macOS only, Command key are pressed (notice that the real Control key is still taken into account under OS X too)\&.
.LP
This method returns false if only Shift is pressed for compatibility reasons and also because pressing Shift usually doesn\&'t change the interpretation of key events, see \fIHasAnyModifiers()\fR\& (not implemented in wx) if you want to take Shift into account as well\&.
.RE
.LP
.nf

.B
metaDown(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns true if the Meta/Windows/Apple key is pressed\&.
.LP
This function tests the state of the key traditionally called Meta under Unix systems, Windows keys under MSW Notice that \fIgetModifiers/1\fR\& should usually be used instead of this one\&.
.LP
See: \fIcmdDown/1\fR\& 
.RE
.LP
.nf

.B
shiftDown(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxKeyEvent()
.br
.RE
.RE
.RS
.LP
Returns true if the Shift key is pressed\&.
.LP
This function doesn\&'t distinguish between right and left shift keys\&.
.LP
Notice that \fIgetModifiers/1\fR\& should usually be used instead of this one\&.
.RE