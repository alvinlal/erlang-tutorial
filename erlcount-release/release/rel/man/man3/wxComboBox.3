.TH wxComboBox 3 "wx 2.2.2" "wxWidgets team." "Erlang Module Definition"
.SH NAME
wxComboBox \- Functions for wxComboBox class
.SH DESCRIPTION
.LP
A combobox is like a combination of an edit control and a listbox\&.
.LP
It can be displayed as static list with editable or read-only text field; or a drop-down list with text field; or a drop-down list without a text field depending on the platform and presence of wxCB_READONLY style\&.
.LP
A combobox permits a single selection only\&. Combobox items are numbered from zero\&.
.LP
If you need a customized combobox, have a look at \fIwxComboCtrl\fR\& (not implemented in wx), \fIwxOwnerDrawnComboBox\fR\& (not implemented in wx), \fIwxComboPopup\fR\& (not implemented in wx) and the ready-to-use \fIwxBitmapComboBox\fR\& (not implemented in wx)\&.
.LP
Please refer to \fIwxTextEntry\fR\& (not implemented in wx) documentation for the description of methods operating with the text entry part of the combobox and to \fIwxItemContainer\fR\& (not implemented in wx) for the methods operating with the list of strings\&. Notice that at least under MSW \fIwxComboBox\fR\& doesn\&'t behave correctly if it contains strings differing in case only so portable programs should avoid adding such strings to this control\&.
.LP
Styles
.LP
This class supports the following styles:
.LP
See: \fIwxListBox\fR\&, \fIwxTextCtrl\fR\&, \fIwxChoice\fR\&, \fIwxCommandEvent\fR\& 
.LP
This class is derived (and can use functions) from: \fIwxControlWithItems\fR\& \fIwxControl\fR\& \fIwxWindow\fR\& \fIwxEvtHandler\fR\&
.LP
wxWidgets docs: wxComboBox
.SH "EVENTS"

.LP
Event types emitted from this class: \fIcommand_combobox_selected\fR\&, \fIcommand_text_updated\fR\&, \fIcommand_text_enter\fR\&, \fIcombobox_dropdown\fR\&, \fIcombobox_closeup\fR\&
.SH DATA TYPES
.nf

\fBwxComboBox()\fR\& = wx:wx_object()
.br
.fi
.SH EXPORTS
.LP
.nf

.B
new() -> wxComboBox()
.br
.fi
.br
.RS
.LP
Default constructor\&.
.RE
.LP
.nf

.B
new(Parent, Id) -> wxComboBox()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
.RE
.RE
.LP
.nf

.B
new(Parent, Id, Options :: [Option]) -> wxComboBox()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Option = 
.br
    {value, unicode:chardata()} |
.br
    {pos, {X :: integer(), Y :: integer()}} |
.br
    {size, {W :: integer(), H :: integer()}} |
.br
    {choices, [unicode:chardata()]} |
.br
    {style, integer()} |
.br
    {validator, wx:wx_object()}
.br
.RE
.RE
.RS
.LP
Constructor, creating and showing a combobox\&.
.LP
See: \fIcreate/8\fR\&, \fIwxValidator\fR\& (not implemented in wx)
.RE
.LP
.nf

.B
destroy(This :: wxComboBox()) -> ok
.br
.fi
.br
.RS
.LP
Destructor, destroying the combobox\&.
.RE
.LP
.nf

.B
create(This, Parent, Id, Value, Pos, Size, Choices) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Value = unicode:chardata()
.br
Pos = {X :: integer(), Y :: integer()}
.br
Size = {W :: integer(), H :: integer()}
.br
Choices = [unicode:chardata()]
.br
.RE
.RE
.LP
.nf

.B
create(This, Parent, Id, Value, Pos, Size, Choices,
.B
       Options :: [Option]) ->
.B
          boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
Parent = wxWindow:wxWindow()
.br
Id = integer()
.br
Value = unicode:chardata()
.br
Pos = {X :: integer(), Y :: integer()}
.br
Size = {W :: integer(), H :: integer()}
.br
Choices = [unicode:chardata()]
.br
Option = {style, integer()} | {validator, wx:wx_object()}
.br
.RE
.RE
.RS
.RE
.LP
.nf

.B
canCopy(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Returns true if the selection can be copied to the clipboard\&.
.RE
.LP
.nf

.B
canCut(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Returns true if the selection can be cut to the clipboard\&.
.RE
.LP
.nf

.B
canPaste(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Returns true if the contents of the clipboard can be pasted into the text control\&.
.LP
On some platforms (Motif, GTK) this is an approximation and returns true if the control is editable, false otherwise\&.
.RE
.LP
.nf

.B
canRedo(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Returns true if there is a redo facility available and the last operation can be redone\&.
.RE
.LP
.nf

.B
canUndo(This) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Returns true if there is an undo facility available and the last operation can be undone\&.
.RE
.LP
.nf

.B
copy(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Copies the selected text to the clipboard\&.
.RE
.LP
.nf

.B
cut(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Copies the selected text to the clipboard and removes it from the control\&.
.RE
.LP
.nf

.B
getInsertionPoint(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Same as \fIwxTextCtrl:getInsertionPoint/1\fR\&\&.
.LP
Note: Under wxMSW, this function always returns 0 if the combobox doesn\&'t have the focus\&.
.RE
.LP
.nf

.B
getLastPosition(This) -> integer()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Returns the zero based index of the last position in the text control, which is equal to the number of characters in the control\&.
.RE
.LP
.nf

.B
getValue(This) -> unicode:charlist()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Gets the contents of the control\&.
.LP
Notice that for a multiline text control, the lines will be separated by (Unix-style) \fI\\n\fR\& characters, even under Windows where they are separated by a \fI\\r\\n\fR\& sequence in the native control\&.
.RE
.LP
.nf

.B
paste(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Pastes text from the clipboard to the text item\&.
.RE
.LP
.nf

.B
redo(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
If there is a redo facility and the last operation can be redone, redoes the last operation\&.
.LP
Does nothing if there is no redo facility\&.
.RE
.LP
.nf

.B
replace(This, From, To, Value) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
From = To = integer()
.br
Value = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Replaces the text starting at the first position up to (but not including) the character at the last position with the given text\&.
.LP
This function puts the current insertion point position at \fIto\fR\& as a side effect\&.
.RE
.LP
.nf

.B
remove(This, From, To) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
From = To = integer()
.br
.RE
.RE
.RS
.LP
Removes the text starting at the first given position up to (but not including) the character at the last position\&.
.LP
This function puts the current insertion point position at \fIto\fR\& as a side effect\&.
.RE
.LP
.nf

.B
setInsertionPoint(This, Pos) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
Pos = integer()
.br
.RE
.RE
.RS
.LP
Sets the insertion point at the given position\&.
.RE
.LP
.nf

.B
setInsertionPointEnd(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
Sets the insertion point at the end of the text control\&.
.LP
This is equivalent to calling \fIsetInsertionPoint/2\fR\& with \fIgetLastPosition/1\fR\& argument\&.
.RE
.LP
.nf

.B
setSelection(This, N) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
N = integer()
.br
.RE
.RE
.RS
.LP
Sets the selection to the given item \fIn\fR\& or removes the selection entirely if \fIn\fR\& == \fIwxNOT_FOUND\fR\&\&.
.LP
Note that this does not cause any command events to be emitted nor does it deselect any other items in the controls which support multiple selections\&.
.LP
See: \fIwxControlWithItems:setString/3\fR\&, \fIwxControlWithItems:setStringSelection/2\fR\& 
.RE
.LP
.nf

.B
setSelection(This, From, To) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
From = To = integer()
.br
.RE
.RE
.RS
.LP
Same as \fIwxTextCtrl:setSelection/3\fR\&\&.
.RE
.LP
.nf

.B
setValue(This, Text) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
Text = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Sets the text for the combobox text field\&.
.LP
For normal, editable comboboxes with a text entry field calling this method will generate a \fIwxEVT_TEXT\fR\& event, consistently with \fIwxTextCtrl:setValue/2\fR\& behaviour, use \fIwxTextCtrl:changeValue/2\fR\& if this is undesirable\&.
.LP
For controls with \fIwxCB_READONLY\fR\& style the method behaves somewhat differently: the string must be in the combobox choices list (the check for this is case-insensitive) and \fIwxEVT_TEXT\fR\& is \fInot\fR\& generated in this case\&.
.RE
.LP
.nf

.B
undo(This) -> ok
.br
.fi
.br
.RS
.LP
Types:

.RS 3
This = wxComboBox()
.br
.RE
.RE
.RS
.LP
If there is an undo facility and the last operation can be undone, undoes the last operation\&.
.LP
Does nothing if there is no undo facility\&.
.RE